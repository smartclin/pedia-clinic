/* !!! This is code generated by Prisma. Do not edit directly. !!! */
/* eslint-disable */
// biome-ignore-all lint: generated file
// @ts-nocheck
/*
 * This file exports the `Prescription` model and its related types.
 *
 * ðŸŸ¢ You can import this file directly.
 */

import type * as runtime from "@prisma/client/runtime/client";
import type * as $Enums from "../enums";
import type * as Prisma from "../internal/prismaNamespace";
import type * as PJTG from "../pjtg";

/**
 * Model Prescription
 *
 */
export type PrescriptionModel =
  runtime.Types.Result.DefaultSelection<Prisma.$PrescriptionPayload>;

export type AggregatePrescription = {
  _count: PrescriptionCountAggregateOutputType | null;
  _min: PrescriptionMinAggregateOutputType | null;
  _max: PrescriptionMaxAggregateOutputType | null;
};

export type PrescriptionMinAggregateOutputType = {
  id: string | null;
  medicalRecordId: string | null;
  doctorId: string | null;
  patientId: string | null;
  encounterId: string | null;
  medicationName: string | null;
  instructions: string | null;
  issuedDate: Date | null;
  endDate: Date | null;
  status: string | null;
  clinicId: string | null;
  createdAt: Date | null;
  updatedAt: Date | null;
};

export type PrescriptionMaxAggregateOutputType = {
  id: string | null;
  medicalRecordId: string | null;
  doctorId: string | null;
  patientId: string | null;
  encounterId: string | null;
  medicationName: string | null;
  instructions: string | null;
  issuedDate: Date | null;
  endDate: Date | null;
  status: string | null;
  clinicId: string | null;
  createdAt: Date | null;
  updatedAt: Date | null;
};

export type PrescriptionCountAggregateOutputType = {
  id: number;
  medicalRecordId: number;
  doctorId: number;
  patientId: number;
  encounterId: number;
  medicationName: number;
  instructions: number;
  issuedDate: number;
  endDate: number;
  status: number;
  clinicId: number;
  createdAt: number;
  updatedAt: number;
  _all: number;
};

export type PrescriptionMinAggregateInputType = {
  id?: true;
  medicalRecordId?: true;
  doctorId?: true;
  patientId?: true;
  encounterId?: true;
  medicationName?: true;
  instructions?: true;
  issuedDate?: true;
  endDate?: true;
  status?: true;
  clinicId?: true;
  createdAt?: true;
  updatedAt?: true;
};

export type PrescriptionMaxAggregateInputType = {
  id?: true;
  medicalRecordId?: true;
  doctorId?: true;
  patientId?: true;
  encounterId?: true;
  medicationName?: true;
  instructions?: true;
  issuedDate?: true;
  endDate?: true;
  status?: true;
  clinicId?: true;
  createdAt?: true;
  updatedAt?: true;
};

export type PrescriptionCountAggregateInputType = {
  id?: true;
  medicalRecordId?: true;
  doctorId?: true;
  patientId?: true;
  encounterId?: true;
  medicationName?: true;
  instructions?: true;
  issuedDate?: true;
  endDate?: true;
  status?: true;
  clinicId?: true;
  createdAt?: true;
  updatedAt?: true;
  _all?: true;
};

export type PrescriptionAggregateArgs<
  ExtArgs extends
    runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs,
> = {
  /**
   * Filter which Prescription to aggregate.
   */
  where?: Prisma.PrescriptionWhereInput;
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
   *
   * Determine the order of Prescriptions to fetch.
   */
  orderBy?:
    | Prisma.PrescriptionOrderByWithRelationInput
    | Prisma.PrescriptionOrderByWithRelationInput[];
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
   *
   * Sets the start position
   */
  cursor?: Prisma.PrescriptionWhereUniqueInput;
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
   *
   * Take `Â±n` Prescriptions from the position of the cursor.
   */
  take?: number;
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
   *
   * Skip the first `n` Prescriptions.
   */
  skip?: number;
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
   *
   * Count returned Prescriptions
   **/
  _count?: true | PrescriptionCountAggregateInputType;
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
   *
   * Select which fields to find the minimum value
   **/
  _min?: PrescriptionMinAggregateInputType;
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
   *
   * Select which fields to find the maximum value
   **/
  _max?: PrescriptionMaxAggregateInputType;
};

export type GetPrescriptionAggregateType<T extends PrescriptionAggregateArgs> =
  {
    [P in keyof T & keyof AggregatePrescription]: P extends "_count" | "count"
      ? T[P] extends true
        ? number
        : Prisma.GetScalarType<T[P], AggregatePrescription[P]>
      : Prisma.GetScalarType<T[P], AggregatePrescription[P]>;
  };

export type PrescriptionGroupByArgs<
  ExtArgs extends
    runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs,
> = {
  where?: Prisma.PrescriptionWhereInput;
  orderBy?:
    | Prisma.PrescriptionOrderByWithAggregationInput
    | Prisma.PrescriptionOrderByWithAggregationInput[];
  by: Prisma.PrescriptionScalarFieldEnum[] | Prisma.PrescriptionScalarFieldEnum;
  having?: Prisma.PrescriptionScalarWhereWithAggregatesInput;
  take?: number;
  skip?: number;
  _count?: PrescriptionCountAggregateInputType | true;
  _min?: PrescriptionMinAggregateInputType;
  _max?: PrescriptionMaxAggregateInputType;
};

export type PrescriptionGroupByOutputType = {
  id: string;
  medicalRecordId: string;
  doctorId: string | null;
  patientId: string;
  encounterId: string;
  medicationName: string | null;
  instructions: string | null;
  issuedDate: Date;
  endDate: Date | null;
  status: string;
  clinicId: string | null;
  createdAt: Date;
  updatedAt: Date;
  _count: PrescriptionCountAggregateOutputType | null;
  _min: PrescriptionMinAggregateOutputType | null;
  _max: PrescriptionMaxAggregateOutputType | null;
};

type GetPrescriptionGroupByPayload<T extends PrescriptionGroupByArgs> =
  Prisma.PrismaPromise<
    Array<
      Prisma.PickEnumerable<PrescriptionGroupByOutputType, T["by"]> & {
        [P in keyof T & keyof PrescriptionGroupByOutputType]: P extends "_count"
          ? T[P] extends boolean
            ? number
            : Prisma.GetScalarType<T[P], PrescriptionGroupByOutputType[P]>
          : Prisma.GetScalarType<T[P], PrescriptionGroupByOutputType[P]>;
      }
    >
  >;

export type PrescriptionWhereInput = {
  AND?: Prisma.PrescriptionWhereInput | Prisma.PrescriptionWhereInput[];
  OR?: Prisma.PrescriptionWhereInput[];
  NOT?: Prisma.PrescriptionWhereInput | Prisma.PrescriptionWhereInput[];
  id?: Prisma.StringFilter<"Prescription"> | string;
  medicalRecordId?: Prisma.StringFilter<"Prescription"> | string;
  doctorId?: Prisma.StringNullableFilter<"Prescription"> | string | null;
  patientId?: Prisma.StringFilter<"Prescription"> | string;
  encounterId?: Prisma.StringFilter<"Prescription"> | string;
  medicationName?: Prisma.StringNullableFilter<"Prescription"> | string | null;
  instructions?: Prisma.StringNullableFilter<"Prescription"> | string | null;
  issuedDate?: Prisma.DateTimeFilter<"Prescription"> | Date | string;
  endDate?:
    | Prisma.DateTimeNullableFilter<"Prescription">
    | Date
    | string
    | null;
  status?: Prisma.StringFilter<"Prescription"> | string;
  clinicId?: Prisma.StringNullableFilter<"Prescription"> | string | null;
  createdAt?: Prisma.DateTimeFilter<"Prescription"> | Date | string;
  updatedAt?: Prisma.DateTimeFilter<"Prescription"> | Date | string;
  encounter?: Prisma.XOR<
    Prisma.DiagnosisScalarRelationFilter,
    Prisma.DiagnosisWhereInput
  >;
  medicalRecord?: Prisma.XOR<
    Prisma.MedicalRecordsScalarRelationFilter,
    Prisma.MedicalRecordsWhereInput
  >;
  doctor?: Prisma.XOR<
    Prisma.DoctorNullableScalarRelationFilter,
    Prisma.DoctorWhereInput
  > | null;
  patient?: Prisma.XOR<
    Prisma.PatientScalarRelationFilter,
    Prisma.PatientWhereInput
  >;
  clinic?: Prisma.XOR<
    Prisma.ClinicNullableScalarRelationFilter,
    Prisma.ClinicWhereInput
  > | null;
  prescribedItems?: Prisma.PrescribedItemListRelationFilter;
};

export type PrescriptionOrderByWithRelationInput = {
  id?: Prisma.SortOrder;
  medicalRecordId?: Prisma.SortOrder;
  doctorId?: Prisma.SortOrderInput | Prisma.SortOrder;
  patientId?: Prisma.SortOrder;
  encounterId?: Prisma.SortOrder;
  medicationName?: Prisma.SortOrderInput | Prisma.SortOrder;
  instructions?: Prisma.SortOrderInput | Prisma.SortOrder;
  issuedDate?: Prisma.SortOrder;
  endDate?: Prisma.SortOrderInput | Prisma.SortOrder;
  status?: Prisma.SortOrder;
  clinicId?: Prisma.SortOrderInput | Prisma.SortOrder;
  createdAt?: Prisma.SortOrder;
  updatedAt?: Prisma.SortOrder;
  encounter?: Prisma.DiagnosisOrderByWithRelationInput;
  medicalRecord?: Prisma.MedicalRecordsOrderByWithRelationInput;
  doctor?: Prisma.DoctorOrderByWithRelationInput;
  patient?: Prisma.PatientOrderByWithRelationInput;
  clinic?: Prisma.ClinicOrderByWithRelationInput;
  prescribedItems?: Prisma.PrescribedItemOrderByRelationAggregateInput;
};

export type PrescriptionWhereUniqueInput = Prisma.AtLeast<
  {
    id?: string;
    AND?: Prisma.PrescriptionWhereInput | Prisma.PrescriptionWhereInput[];
    OR?: Prisma.PrescriptionWhereInput[];
    NOT?: Prisma.PrescriptionWhereInput | Prisma.PrescriptionWhereInput[];
    medicalRecordId?: Prisma.StringFilter<"Prescription"> | string;
    doctorId?: Prisma.StringNullableFilter<"Prescription"> | string | null;
    patientId?: Prisma.StringFilter<"Prescription"> | string;
    encounterId?: Prisma.StringFilter<"Prescription"> | string;
    medicationName?:
      | Prisma.StringNullableFilter<"Prescription">
      | string
      | null;
    instructions?: Prisma.StringNullableFilter<"Prescription"> | string | null;
    issuedDate?: Prisma.DateTimeFilter<"Prescription"> | Date | string;
    endDate?:
      | Prisma.DateTimeNullableFilter<"Prescription">
      | Date
      | string
      | null;
    status?: Prisma.StringFilter<"Prescription"> | string;
    clinicId?: Prisma.StringNullableFilter<"Prescription"> | string | null;
    createdAt?: Prisma.DateTimeFilter<"Prescription"> | Date | string;
    updatedAt?: Prisma.DateTimeFilter<"Prescription"> | Date | string;
    encounter?: Prisma.XOR<
      Prisma.DiagnosisScalarRelationFilter,
      Prisma.DiagnosisWhereInput
    >;
    medicalRecord?: Prisma.XOR<
      Prisma.MedicalRecordsScalarRelationFilter,
      Prisma.MedicalRecordsWhereInput
    >;
    doctor?: Prisma.XOR<
      Prisma.DoctorNullableScalarRelationFilter,
      Prisma.DoctorWhereInput
    > | null;
    patient?: Prisma.XOR<
      Prisma.PatientScalarRelationFilter,
      Prisma.PatientWhereInput
    >;
    clinic?: Prisma.XOR<
      Prisma.ClinicNullableScalarRelationFilter,
      Prisma.ClinicWhereInput
    > | null;
    prescribedItems?: Prisma.PrescribedItemListRelationFilter;
  },
  "id"
>;

export type PrescriptionOrderByWithAggregationInput = {
  id?: Prisma.SortOrder;
  medicalRecordId?: Prisma.SortOrder;
  doctorId?: Prisma.SortOrderInput | Prisma.SortOrder;
  patientId?: Prisma.SortOrder;
  encounterId?: Prisma.SortOrder;
  medicationName?: Prisma.SortOrderInput | Prisma.SortOrder;
  instructions?: Prisma.SortOrderInput | Prisma.SortOrder;
  issuedDate?: Prisma.SortOrder;
  endDate?: Prisma.SortOrderInput | Prisma.SortOrder;
  status?: Prisma.SortOrder;
  clinicId?: Prisma.SortOrderInput | Prisma.SortOrder;
  createdAt?: Prisma.SortOrder;
  updatedAt?: Prisma.SortOrder;
  _count?: Prisma.PrescriptionCountOrderByAggregateInput;
  _max?: Prisma.PrescriptionMaxOrderByAggregateInput;
  _min?: Prisma.PrescriptionMinOrderByAggregateInput;
};

export type PrescriptionScalarWhereWithAggregatesInput = {
  AND?:
    | Prisma.PrescriptionScalarWhereWithAggregatesInput
    | Prisma.PrescriptionScalarWhereWithAggregatesInput[];
  OR?: Prisma.PrescriptionScalarWhereWithAggregatesInput[];
  NOT?:
    | Prisma.PrescriptionScalarWhereWithAggregatesInput
    | Prisma.PrescriptionScalarWhereWithAggregatesInput[];
  id?: Prisma.StringWithAggregatesFilter<"Prescription"> | string;
  medicalRecordId?: Prisma.StringWithAggregatesFilter<"Prescription"> | string;
  doctorId?:
    | Prisma.StringNullableWithAggregatesFilter<"Prescription">
    | string
    | null;
  patientId?: Prisma.StringWithAggregatesFilter<"Prescription"> | string;
  encounterId?: Prisma.StringWithAggregatesFilter<"Prescription"> | string;
  medicationName?:
    | Prisma.StringNullableWithAggregatesFilter<"Prescription">
    | string
    | null;
  instructions?:
    | Prisma.StringNullableWithAggregatesFilter<"Prescription">
    | string
    | null;
  issuedDate?:
    | Prisma.DateTimeWithAggregatesFilter<"Prescription">
    | Date
    | string;
  endDate?:
    | Prisma.DateTimeNullableWithAggregatesFilter<"Prescription">
    | Date
    | string
    | null;
  status?: Prisma.StringWithAggregatesFilter<"Prescription"> | string;
  clinicId?:
    | Prisma.StringNullableWithAggregatesFilter<"Prescription">
    | string
    | null;
  createdAt?:
    | Prisma.DateTimeWithAggregatesFilter<"Prescription">
    | Date
    | string;
  updatedAt?:
    | Prisma.DateTimeWithAggregatesFilter<"Prescription">
    | Date
    | string;
};

export type PrescriptionCreateInput = {
  id?: string;
  medicationName?: string | null;
  instructions?: string | null;
  issuedDate?: Date | string;
  endDate?: Date | string | null;
  status?: string;
  createdAt?: Date | string;
  updatedAt?: Date | string;
  encounter: Prisma.DiagnosisCreateNestedOneWithoutPrescriptionsInput;
  medicalRecord: Prisma.MedicalRecordsCreateNestedOneWithoutPrescriptionsInput;
  doctor?: Prisma.DoctorCreateNestedOneWithoutPrescriptionInput;
  patient: Prisma.PatientCreateNestedOneWithoutPrescriptionsInput;
  clinic?: Prisma.ClinicCreateNestedOneWithoutPrescriptionsInput;
  prescribedItems?: Prisma.PrescribedItemCreateNestedManyWithoutPrescriptionInput;
};

export type PrescriptionUncheckedCreateInput = {
  id?: string;
  medicalRecordId: string;
  doctorId?: string | null;
  patientId: string;
  encounterId: string;
  medicationName?: string | null;
  instructions?: string | null;
  issuedDate?: Date | string;
  endDate?: Date | string | null;
  status?: string;
  clinicId?: string | null;
  createdAt?: Date | string;
  updatedAt?: Date | string;
  prescribedItems?: Prisma.PrescribedItemUncheckedCreateNestedManyWithoutPrescriptionInput;
};

export type PrescriptionUpdateInput = {
  id?: Prisma.StringFieldUpdateOperationsInput | string;
  medicationName?:
    | Prisma.NullableStringFieldUpdateOperationsInput
    | string
    | null;
  instructions?:
    | Prisma.NullableStringFieldUpdateOperationsInput
    | string
    | null;
  issuedDate?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string;
  endDate?:
    | Prisma.NullableDateTimeFieldUpdateOperationsInput
    | Date
    | string
    | null;
  status?: Prisma.StringFieldUpdateOperationsInput | string;
  createdAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string;
  updatedAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string;
  encounter?: Prisma.DiagnosisUpdateOneRequiredWithoutPrescriptionsNestedInput;
  medicalRecord?: Prisma.MedicalRecordsUpdateOneRequiredWithoutPrescriptionsNestedInput;
  doctor?: Prisma.DoctorUpdateOneWithoutPrescriptionNestedInput;
  patient?: Prisma.PatientUpdateOneRequiredWithoutPrescriptionsNestedInput;
  clinic?: Prisma.ClinicUpdateOneWithoutPrescriptionsNestedInput;
  prescribedItems?: Prisma.PrescribedItemUpdateManyWithoutPrescriptionNestedInput;
};

export type PrescriptionUncheckedUpdateInput = {
  id?: Prisma.StringFieldUpdateOperationsInput | string;
  medicalRecordId?: Prisma.StringFieldUpdateOperationsInput | string;
  doctorId?: Prisma.NullableStringFieldUpdateOperationsInput | string | null;
  patientId?: Prisma.StringFieldUpdateOperationsInput | string;
  encounterId?: Prisma.StringFieldUpdateOperationsInput | string;
  medicationName?:
    | Prisma.NullableStringFieldUpdateOperationsInput
    | string
    | null;
  instructions?:
    | Prisma.NullableStringFieldUpdateOperationsInput
    | string
    | null;
  issuedDate?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string;
  endDate?:
    | Prisma.NullableDateTimeFieldUpdateOperationsInput
    | Date
    | string
    | null;
  status?: Prisma.StringFieldUpdateOperationsInput | string;
  clinicId?: Prisma.NullableStringFieldUpdateOperationsInput | string | null;
  createdAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string;
  updatedAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string;
  prescribedItems?: Prisma.PrescribedItemUncheckedUpdateManyWithoutPrescriptionNestedInput;
};

export type PrescriptionCreateManyInput = {
  id?: string;
  medicalRecordId: string;
  doctorId?: string | null;
  patientId: string;
  encounterId: string;
  medicationName?: string | null;
  instructions?: string | null;
  issuedDate?: Date | string;
  endDate?: Date | string | null;
  status?: string;
  clinicId?: string | null;
  createdAt?: Date | string;
  updatedAt?: Date | string;
};

export type PrescriptionUpdateManyMutationInput = {
  id?: Prisma.StringFieldUpdateOperationsInput | string;
  medicationName?:
    | Prisma.NullableStringFieldUpdateOperationsInput
    | string
    | null;
  instructions?:
    | Prisma.NullableStringFieldUpdateOperationsInput
    | string
    | null;
  issuedDate?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string;
  endDate?:
    | Prisma.NullableDateTimeFieldUpdateOperationsInput
    | Date
    | string
    | null;
  status?: Prisma.StringFieldUpdateOperationsInput | string;
  createdAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string;
  updatedAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string;
};

export type PrescriptionUncheckedUpdateManyInput = {
  id?: Prisma.StringFieldUpdateOperationsInput | string;
  medicalRecordId?: Prisma.StringFieldUpdateOperationsInput | string;
  doctorId?: Prisma.NullableStringFieldUpdateOperationsInput | string | null;
  patientId?: Prisma.StringFieldUpdateOperationsInput | string;
  encounterId?: Prisma.StringFieldUpdateOperationsInput | string;
  medicationName?:
    | Prisma.NullableStringFieldUpdateOperationsInput
    | string
    | null;
  instructions?:
    | Prisma.NullableStringFieldUpdateOperationsInput
    | string
    | null;
  issuedDate?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string;
  endDate?:
    | Prisma.NullableDateTimeFieldUpdateOperationsInput
    | Date
    | string
    | null;
  status?: Prisma.StringFieldUpdateOperationsInput | string;
  clinicId?: Prisma.NullableStringFieldUpdateOperationsInput | string | null;
  createdAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string;
  updatedAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string;
};

export type PrescriptionListRelationFilter = {
  every?: Prisma.PrescriptionWhereInput;
  some?: Prisma.PrescriptionWhereInput;
  none?: Prisma.PrescriptionWhereInput;
};

export type PrescriptionOrderByRelationAggregateInput = {
  _count?: Prisma.SortOrder;
};

export type PrescriptionCountOrderByAggregateInput = {
  id?: Prisma.SortOrder;
  medicalRecordId?: Prisma.SortOrder;
  doctorId?: Prisma.SortOrder;
  patientId?: Prisma.SortOrder;
  encounterId?: Prisma.SortOrder;
  medicationName?: Prisma.SortOrder;
  instructions?: Prisma.SortOrder;
  issuedDate?: Prisma.SortOrder;
  endDate?: Prisma.SortOrder;
  status?: Prisma.SortOrder;
  clinicId?: Prisma.SortOrder;
  createdAt?: Prisma.SortOrder;
  updatedAt?: Prisma.SortOrder;
};

export type PrescriptionMaxOrderByAggregateInput = {
  id?: Prisma.SortOrder;
  medicalRecordId?: Prisma.SortOrder;
  doctorId?: Prisma.SortOrder;
  patientId?: Prisma.SortOrder;
  encounterId?: Prisma.SortOrder;
  medicationName?: Prisma.SortOrder;
  instructions?: Prisma.SortOrder;
  issuedDate?: Prisma.SortOrder;
  endDate?: Prisma.SortOrder;
  status?: Prisma.SortOrder;
  clinicId?: Prisma.SortOrder;
  createdAt?: Prisma.SortOrder;
  updatedAt?: Prisma.SortOrder;
};

export type PrescriptionMinOrderByAggregateInput = {
  id?: Prisma.SortOrder;
  medicalRecordId?: Prisma.SortOrder;
  doctorId?: Prisma.SortOrder;
  patientId?: Prisma.SortOrder;
  encounterId?: Prisma.SortOrder;
  medicationName?: Prisma.SortOrder;
  instructions?: Prisma.SortOrder;
  issuedDate?: Prisma.SortOrder;
  endDate?: Prisma.SortOrder;
  status?: Prisma.SortOrder;
  clinicId?: Prisma.SortOrder;
  createdAt?: Prisma.SortOrder;
  updatedAt?: Prisma.SortOrder;
};

export type PrescriptionScalarRelationFilter = {
  is?: Prisma.PrescriptionWhereInput;
  isNot?: Prisma.PrescriptionWhereInput;
};

export type PrescriptionCreateNestedManyWithoutClinicInput = {
  create?:
    | Prisma.XOR<
        Prisma.PrescriptionCreateWithoutClinicInput,
        Prisma.PrescriptionUncheckedCreateWithoutClinicInput
      >
    | Prisma.PrescriptionCreateWithoutClinicInput[]
    | Prisma.PrescriptionUncheckedCreateWithoutClinicInput[];
  connectOrCreate?:
    | Prisma.PrescriptionCreateOrConnectWithoutClinicInput
    | Prisma.PrescriptionCreateOrConnectWithoutClinicInput[];
  createMany?: Prisma.PrescriptionCreateManyClinicInputEnvelope;
  connect?:
    | Prisma.PrescriptionWhereUniqueInput
    | Prisma.PrescriptionWhereUniqueInput[];
};

export type PrescriptionUncheckedCreateNestedManyWithoutClinicInput = {
  create?:
    | Prisma.XOR<
        Prisma.PrescriptionCreateWithoutClinicInput,
        Prisma.PrescriptionUncheckedCreateWithoutClinicInput
      >
    | Prisma.PrescriptionCreateWithoutClinicInput[]
    | Prisma.PrescriptionUncheckedCreateWithoutClinicInput[];
  connectOrCreate?:
    | Prisma.PrescriptionCreateOrConnectWithoutClinicInput
    | Prisma.PrescriptionCreateOrConnectWithoutClinicInput[];
  createMany?: Prisma.PrescriptionCreateManyClinicInputEnvelope;
  connect?:
    | Prisma.PrescriptionWhereUniqueInput
    | Prisma.PrescriptionWhereUniqueInput[];
};

export type PrescriptionUpdateManyWithoutClinicNestedInput = {
  create?:
    | Prisma.XOR<
        Prisma.PrescriptionCreateWithoutClinicInput,
        Prisma.PrescriptionUncheckedCreateWithoutClinicInput
      >
    | Prisma.PrescriptionCreateWithoutClinicInput[]
    | Prisma.PrescriptionUncheckedCreateWithoutClinicInput[];
  connectOrCreate?:
    | Prisma.PrescriptionCreateOrConnectWithoutClinicInput
    | Prisma.PrescriptionCreateOrConnectWithoutClinicInput[];
  upsert?:
    | Prisma.PrescriptionUpsertWithWhereUniqueWithoutClinicInput
    | Prisma.PrescriptionUpsertWithWhereUniqueWithoutClinicInput[];
  createMany?: Prisma.PrescriptionCreateManyClinicInputEnvelope;
  set?:
    | Prisma.PrescriptionWhereUniqueInput
    | Prisma.PrescriptionWhereUniqueInput[];
  disconnect?:
    | Prisma.PrescriptionWhereUniqueInput
    | Prisma.PrescriptionWhereUniqueInput[];
  delete?:
    | Prisma.PrescriptionWhereUniqueInput
    | Prisma.PrescriptionWhereUniqueInput[];
  connect?:
    | Prisma.PrescriptionWhereUniqueInput
    | Prisma.PrescriptionWhereUniqueInput[];
  update?:
    | Prisma.PrescriptionUpdateWithWhereUniqueWithoutClinicInput
    | Prisma.PrescriptionUpdateWithWhereUniqueWithoutClinicInput[];
  updateMany?:
    | Prisma.PrescriptionUpdateManyWithWhereWithoutClinicInput
    | Prisma.PrescriptionUpdateManyWithWhereWithoutClinicInput[];
  deleteMany?:
    | Prisma.PrescriptionScalarWhereInput
    | Prisma.PrescriptionScalarWhereInput[];
};

export type PrescriptionUncheckedUpdateManyWithoutClinicNestedInput = {
  create?:
    | Prisma.XOR<
        Prisma.PrescriptionCreateWithoutClinicInput,
        Prisma.PrescriptionUncheckedCreateWithoutClinicInput
      >
    | Prisma.PrescriptionCreateWithoutClinicInput[]
    | Prisma.PrescriptionUncheckedCreateWithoutClinicInput[];
  connectOrCreate?:
    | Prisma.PrescriptionCreateOrConnectWithoutClinicInput
    | Prisma.PrescriptionCreateOrConnectWithoutClinicInput[];
  upsert?:
    | Prisma.PrescriptionUpsertWithWhereUniqueWithoutClinicInput
    | Prisma.PrescriptionUpsertWithWhereUniqueWithoutClinicInput[];
  createMany?: Prisma.PrescriptionCreateManyClinicInputEnvelope;
  set?:
    | Prisma.PrescriptionWhereUniqueInput
    | Prisma.PrescriptionWhereUniqueInput[];
  disconnect?:
    | Prisma.PrescriptionWhereUniqueInput
    | Prisma.PrescriptionWhereUniqueInput[];
  delete?:
    | Prisma.PrescriptionWhereUniqueInput
    | Prisma.PrescriptionWhereUniqueInput[];
  connect?:
    | Prisma.PrescriptionWhereUniqueInput
    | Prisma.PrescriptionWhereUniqueInput[];
  update?:
    | Prisma.PrescriptionUpdateWithWhereUniqueWithoutClinicInput
    | Prisma.PrescriptionUpdateWithWhereUniqueWithoutClinicInput[];
  updateMany?:
    | Prisma.PrescriptionUpdateManyWithWhereWithoutClinicInput
    | Prisma.PrescriptionUpdateManyWithWhereWithoutClinicInput[];
  deleteMany?:
    | Prisma.PrescriptionScalarWhereInput
    | Prisma.PrescriptionScalarWhereInput[];
};

export type PrescriptionCreateNestedManyWithoutDoctorInput = {
  create?:
    | Prisma.XOR<
        Prisma.PrescriptionCreateWithoutDoctorInput,
        Prisma.PrescriptionUncheckedCreateWithoutDoctorInput
      >
    | Prisma.PrescriptionCreateWithoutDoctorInput[]
    | Prisma.PrescriptionUncheckedCreateWithoutDoctorInput[];
  connectOrCreate?:
    | Prisma.PrescriptionCreateOrConnectWithoutDoctorInput
    | Prisma.PrescriptionCreateOrConnectWithoutDoctorInput[];
  createMany?: Prisma.PrescriptionCreateManyDoctorInputEnvelope;
  connect?:
    | Prisma.PrescriptionWhereUniqueInput
    | Prisma.PrescriptionWhereUniqueInput[];
};

export type PrescriptionUncheckedCreateNestedManyWithoutDoctorInput = {
  create?:
    | Prisma.XOR<
        Prisma.PrescriptionCreateWithoutDoctorInput,
        Prisma.PrescriptionUncheckedCreateWithoutDoctorInput
      >
    | Prisma.PrescriptionCreateWithoutDoctorInput[]
    | Prisma.PrescriptionUncheckedCreateWithoutDoctorInput[];
  connectOrCreate?:
    | Prisma.PrescriptionCreateOrConnectWithoutDoctorInput
    | Prisma.PrescriptionCreateOrConnectWithoutDoctorInput[];
  createMany?: Prisma.PrescriptionCreateManyDoctorInputEnvelope;
  connect?:
    | Prisma.PrescriptionWhereUniqueInput
    | Prisma.PrescriptionWhereUniqueInput[];
};

export type PrescriptionUpdateManyWithoutDoctorNestedInput = {
  create?:
    | Prisma.XOR<
        Prisma.PrescriptionCreateWithoutDoctorInput,
        Prisma.PrescriptionUncheckedCreateWithoutDoctorInput
      >
    | Prisma.PrescriptionCreateWithoutDoctorInput[]
    | Prisma.PrescriptionUncheckedCreateWithoutDoctorInput[];
  connectOrCreate?:
    | Prisma.PrescriptionCreateOrConnectWithoutDoctorInput
    | Prisma.PrescriptionCreateOrConnectWithoutDoctorInput[];
  upsert?:
    | Prisma.PrescriptionUpsertWithWhereUniqueWithoutDoctorInput
    | Prisma.PrescriptionUpsertWithWhereUniqueWithoutDoctorInput[];
  createMany?: Prisma.PrescriptionCreateManyDoctorInputEnvelope;
  set?:
    | Prisma.PrescriptionWhereUniqueInput
    | Prisma.PrescriptionWhereUniqueInput[];
  disconnect?:
    | Prisma.PrescriptionWhereUniqueInput
    | Prisma.PrescriptionWhereUniqueInput[];
  delete?:
    | Prisma.PrescriptionWhereUniqueInput
    | Prisma.PrescriptionWhereUniqueInput[];
  connect?:
    | Prisma.PrescriptionWhereUniqueInput
    | Prisma.PrescriptionWhereUniqueInput[];
  update?:
    | Prisma.PrescriptionUpdateWithWhereUniqueWithoutDoctorInput
    | Prisma.PrescriptionUpdateWithWhereUniqueWithoutDoctorInput[];
  updateMany?:
    | Prisma.PrescriptionUpdateManyWithWhereWithoutDoctorInput
    | Prisma.PrescriptionUpdateManyWithWhereWithoutDoctorInput[];
  deleteMany?:
    | Prisma.PrescriptionScalarWhereInput
    | Prisma.PrescriptionScalarWhereInput[];
};

export type PrescriptionUncheckedUpdateManyWithoutDoctorNestedInput = {
  create?:
    | Prisma.XOR<
        Prisma.PrescriptionCreateWithoutDoctorInput,
        Prisma.PrescriptionUncheckedCreateWithoutDoctorInput
      >
    | Prisma.PrescriptionCreateWithoutDoctorInput[]
    | Prisma.PrescriptionUncheckedCreateWithoutDoctorInput[];
  connectOrCreate?:
    | Prisma.PrescriptionCreateOrConnectWithoutDoctorInput
    | Prisma.PrescriptionCreateOrConnectWithoutDoctorInput[];
  upsert?:
    | Prisma.PrescriptionUpsertWithWhereUniqueWithoutDoctorInput
    | Prisma.PrescriptionUpsertWithWhereUniqueWithoutDoctorInput[];
  createMany?: Prisma.PrescriptionCreateManyDoctorInputEnvelope;
  set?:
    | Prisma.PrescriptionWhereUniqueInput
    | Prisma.PrescriptionWhereUniqueInput[];
  disconnect?:
    | Prisma.PrescriptionWhereUniqueInput
    | Prisma.PrescriptionWhereUniqueInput[];
  delete?:
    | Prisma.PrescriptionWhereUniqueInput
    | Prisma.PrescriptionWhereUniqueInput[];
  connect?:
    | Prisma.PrescriptionWhereUniqueInput
    | Prisma.PrescriptionWhereUniqueInput[];
  update?:
    | Prisma.PrescriptionUpdateWithWhereUniqueWithoutDoctorInput
    | Prisma.PrescriptionUpdateWithWhereUniqueWithoutDoctorInput[];
  updateMany?:
    | Prisma.PrescriptionUpdateManyWithWhereWithoutDoctorInput
    | Prisma.PrescriptionUpdateManyWithWhereWithoutDoctorInput[];
  deleteMany?:
    | Prisma.PrescriptionScalarWhereInput
    | Prisma.PrescriptionScalarWhereInput[];
};

export type PrescriptionCreateNestedOneWithoutPrescribedItemsInput = {
  create?: Prisma.XOR<
    Prisma.PrescriptionCreateWithoutPrescribedItemsInput,
    Prisma.PrescriptionUncheckedCreateWithoutPrescribedItemsInput
  >;
  connectOrCreate?: Prisma.PrescriptionCreateOrConnectWithoutPrescribedItemsInput;
  connect?: Prisma.PrescriptionWhereUniqueInput;
};

export type PrescriptionUpdateOneRequiredWithoutPrescribedItemsNestedInput = {
  create?: Prisma.XOR<
    Prisma.PrescriptionCreateWithoutPrescribedItemsInput,
    Prisma.PrescriptionUncheckedCreateWithoutPrescribedItemsInput
  >;
  connectOrCreate?: Prisma.PrescriptionCreateOrConnectWithoutPrescribedItemsInput;
  upsert?: Prisma.PrescriptionUpsertWithoutPrescribedItemsInput;
  connect?: Prisma.PrescriptionWhereUniqueInput;
  update?: Prisma.XOR<
    Prisma.XOR<
      Prisma.PrescriptionUpdateToOneWithWhereWithoutPrescribedItemsInput,
      Prisma.PrescriptionUpdateWithoutPrescribedItemsInput
    >,
    Prisma.PrescriptionUncheckedUpdateWithoutPrescribedItemsInput
  >;
};

export type PrescriptionCreateNestedManyWithoutPatientInput = {
  create?:
    | Prisma.XOR<
        Prisma.PrescriptionCreateWithoutPatientInput,
        Prisma.PrescriptionUncheckedCreateWithoutPatientInput
      >
    | Prisma.PrescriptionCreateWithoutPatientInput[]
    | Prisma.PrescriptionUncheckedCreateWithoutPatientInput[];
  connectOrCreate?:
    | Prisma.PrescriptionCreateOrConnectWithoutPatientInput
    | Prisma.PrescriptionCreateOrConnectWithoutPatientInput[];
  createMany?: Prisma.PrescriptionCreateManyPatientInputEnvelope;
  connect?:
    | Prisma.PrescriptionWhereUniqueInput
    | Prisma.PrescriptionWhereUniqueInput[];
};

export type PrescriptionUncheckedCreateNestedManyWithoutPatientInput = {
  create?:
    | Prisma.XOR<
        Prisma.PrescriptionCreateWithoutPatientInput,
        Prisma.PrescriptionUncheckedCreateWithoutPatientInput
      >
    | Prisma.PrescriptionCreateWithoutPatientInput[]
    | Prisma.PrescriptionUncheckedCreateWithoutPatientInput[];
  connectOrCreate?:
    | Prisma.PrescriptionCreateOrConnectWithoutPatientInput
    | Prisma.PrescriptionCreateOrConnectWithoutPatientInput[];
  createMany?: Prisma.PrescriptionCreateManyPatientInputEnvelope;
  connect?:
    | Prisma.PrescriptionWhereUniqueInput
    | Prisma.PrescriptionWhereUniqueInput[];
};

export type PrescriptionUpdateManyWithoutPatientNestedInput = {
  create?:
    | Prisma.XOR<
        Prisma.PrescriptionCreateWithoutPatientInput,
        Prisma.PrescriptionUncheckedCreateWithoutPatientInput
      >
    | Prisma.PrescriptionCreateWithoutPatientInput[]
    | Prisma.PrescriptionUncheckedCreateWithoutPatientInput[];
  connectOrCreate?:
    | Prisma.PrescriptionCreateOrConnectWithoutPatientInput
    | Prisma.PrescriptionCreateOrConnectWithoutPatientInput[];
  upsert?:
    | Prisma.PrescriptionUpsertWithWhereUniqueWithoutPatientInput
    | Prisma.PrescriptionUpsertWithWhereUniqueWithoutPatientInput[];
  createMany?: Prisma.PrescriptionCreateManyPatientInputEnvelope;
  set?:
    | Prisma.PrescriptionWhereUniqueInput
    | Prisma.PrescriptionWhereUniqueInput[];
  disconnect?:
    | Prisma.PrescriptionWhereUniqueInput
    | Prisma.PrescriptionWhereUniqueInput[];
  delete?:
    | Prisma.PrescriptionWhereUniqueInput
    | Prisma.PrescriptionWhereUniqueInput[];
  connect?:
    | Prisma.PrescriptionWhereUniqueInput
    | Prisma.PrescriptionWhereUniqueInput[];
  update?:
    | Prisma.PrescriptionUpdateWithWhereUniqueWithoutPatientInput
    | Prisma.PrescriptionUpdateWithWhereUniqueWithoutPatientInput[];
  updateMany?:
    | Prisma.PrescriptionUpdateManyWithWhereWithoutPatientInput
    | Prisma.PrescriptionUpdateManyWithWhereWithoutPatientInput[];
  deleteMany?:
    | Prisma.PrescriptionScalarWhereInput
    | Prisma.PrescriptionScalarWhereInput[];
};

export type PrescriptionUncheckedUpdateManyWithoutPatientNestedInput = {
  create?:
    | Prisma.XOR<
        Prisma.PrescriptionCreateWithoutPatientInput,
        Prisma.PrescriptionUncheckedCreateWithoutPatientInput
      >
    | Prisma.PrescriptionCreateWithoutPatientInput[]
    | Prisma.PrescriptionUncheckedCreateWithoutPatientInput[];
  connectOrCreate?:
    | Prisma.PrescriptionCreateOrConnectWithoutPatientInput
    | Prisma.PrescriptionCreateOrConnectWithoutPatientInput[];
  upsert?:
    | Prisma.PrescriptionUpsertWithWhereUniqueWithoutPatientInput
    | Prisma.PrescriptionUpsertWithWhereUniqueWithoutPatientInput[];
  createMany?: Prisma.PrescriptionCreateManyPatientInputEnvelope;
  set?:
    | Prisma.PrescriptionWhereUniqueInput
    | Prisma.PrescriptionWhereUniqueInput[];
  disconnect?:
    | Prisma.PrescriptionWhereUniqueInput
    | Prisma.PrescriptionWhereUniqueInput[];
  delete?:
    | Prisma.PrescriptionWhereUniqueInput
    | Prisma.PrescriptionWhereUniqueInput[];
  connect?:
    | Prisma.PrescriptionWhereUniqueInput
    | Prisma.PrescriptionWhereUniqueInput[];
  update?:
    | Prisma.PrescriptionUpdateWithWhereUniqueWithoutPatientInput
    | Prisma.PrescriptionUpdateWithWhereUniqueWithoutPatientInput[];
  updateMany?:
    | Prisma.PrescriptionUpdateManyWithWhereWithoutPatientInput
    | Prisma.PrescriptionUpdateManyWithWhereWithoutPatientInput[];
  deleteMany?:
    | Prisma.PrescriptionScalarWhereInput
    | Prisma.PrescriptionScalarWhereInput[];
};

export type PrescriptionCreateNestedManyWithoutMedicalRecordInput = {
  create?:
    | Prisma.XOR<
        Prisma.PrescriptionCreateWithoutMedicalRecordInput,
        Prisma.PrescriptionUncheckedCreateWithoutMedicalRecordInput
      >
    | Prisma.PrescriptionCreateWithoutMedicalRecordInput[]
    | Prisma.PrescriptionUncheckedCreateWithoutMedicalRecordInput[];
  connectOrCreate?:
    | Prisma.PrescriptionCreateOrConnectWithoutMedicalRecordInput
    | Prisma.PrescriptionCreateOrConnectWithoutMedicalRecordInput[];
  createMany?: Prisma.PrescriptionCreateManyMedicalRecordInputEnvelope;
  connect?:
    | Prisma.PrescriptionWhereUniqueInput
    | Prisma.PrescriptionWhereUniqueInput[];
};

export type PrescriptionUncheckedCreateNestedManyWithoutMedicalRecordInput = {
  create?:
    | Prisma.XOR<
        Prisma.PrescriptionCreateWithoutMedicalRecordInput,
        Prisma.PrescriptionUncheckedCreateWithoutMedicalRecordInput
      >
    | Prisma.PrescriptionCreateWithoutMedicalRecordInput[]
    | Prisma.PrescriptionUncheckedCreateWithoutMedicalRecordInput[];
  connectOrCreate?:
    | Prisma.PrescriptionCreateOrConnectWithoutMedicalRecordInput
    | Prisma.PrescriptionCreateOrConnectWithoutMedicalRecordInput[];
  createMany?: Prisma.PrescriptionCreateManyMedicalRecordInputEnvelope;
  connect?:
    | Prisma.PrescriptionWhereUniqueInput
    | Prisma.PrescriptionWhereUniqueInput[];
};

export type PrescriptionUpdateManyWithoutMedicalRecordNestedInput = {
  create?:
    | Prisma.XOR<
        Prisma.PrescriptionCreateWithoutMedicalRecordInput,
        Prisma.PrescriptionUncheckedCreateWithoutMedicalRecordInput
      >
    | Prisma.PrescriptionCreateWithoutMedicalRecordInput[]
    | Prisma.PrescriptionUncheckedCreateWithoutMedicalRecordInput[];
  connectOrCreate?:
    | Prisma.PrescriptionCreateOrConnectWithoutMedicalRecordInput
    | Prisma.PrescriptionCreateOrConnectWithoutMedicalRecordInput[];
  upsert?:
    | Prisma.PrescriptionUpsertWithWhereUniqueWithoutMedicalRecordInput
    | Prisma.PrescriptionUpsertWithWhereUniqueWithoutMedicalRecordInput[];
  createMany?: Prisma.PrescriptionCreateManyMedicalRecordInputEnvelope;
  set?:
    | Prisma.PrescriptionWhereUniqueInput
    | Prisma.PrescriptionWhereUniqueInput[];
  disconnect?:
    | Prisma.PrescriptionWhereUniqueInput
    | Prisma.PrescriptionWhereUniqueInput[];
  delete?:
    | Prisma.PrescriptionWhereUniqueInput
    | Prisma.PrescriptionWhereUniqueInput[];
  connect?:
    | Prisma.PrescriptionWhereUniqueInput
    | Prisma.PrescriptionWhereUniqueInput[];
  update?:
    | Prisma.PrescriptionUpdateWithWhereUniqueWithoutMedicalRecordInput
    | Prisma.PrescriptionUpdateWithWhereUniqueWithoutMedicalRecordInput[];
  updateMany?:
    | Prisma.PrescriptionUpdateManyWithWhereWithoutMedicalRecordInput
    | Prisma.PrescriptionUpdateManyWithWhereWithoutMedicalRecordInput[];
  deleteMany?:
    | Prisma.PrescriptionScalarWhereInput
    | Prisma.PrescriptionScalarWhereInput[];
};

export type PrescriptionUncheckedUpdateManyWithoutMedicalRecordNestedInput = {
  create?:
    | Prisma.XOR<
        Prisma.PrescriptionCreateWithoutMedicalRecordInput,
        Prisma.PrescriptionUncheckedCreateWithoutMedicalRecordInput
      >
    | Prisma.PrescriptionCreateWithoutMedicalRecordInput[]
    | Prisma.PrescriptionUncheckedCreateWithoutMedicalRecordInput[];
  connectOrCreate?:
    | Prisma.PrescriptionCreateOrConnectWithoutMedicalRecordInput
    | Prisma.PrescriptionCreateOrConnectWithoutMedicalRecordInput[];
  upsert?:
    | Prisma.PrescriptionUpsertWithWhereUniqueWithoutMedicalRecordInput
    | Prisma.PrescriptionUpsertWithWhereUniqueWithoutMedicalRecordInput[];
  createMany?: Prisma.PrescriptionCreateManyMedicalRecordInputEnvelope;
  set?:
    | Prisma.PrescriptionWhereUniqueInput
    | Prisma.PrescriptionWhereUniqueInput[];
  disconnect?:
    | Prisma.PrescriptionWhereUniqueInput
    | Prisma.PrescriptionWhereUniqueInput[];
  delete?:
    | Prisma.PrescriptionWhereUniqueInput
    | Prisma.PrescriptionWhereUniqueInput[];
  connect?:
    | Prisma.PrescriptionWhereUniqueInput
    | Prisma.PrescriptionWhereUniqueInput[];
  update?:
    | Prisma.PrescriptionUpdateWithWhereUniqueWithoutMedicalRecordInput
    | Prisma.PrescriptionUpdateWithWhereUniqueWithoutMedicalRecordInput[];
  updateMany?:
    | Prisma.PrescriptionUpdateManyWithWhereWithoutMedicalRecordInput
    | Prisma.PrescriptionUpdateManyWithWhereWithoutMedicalRecordInput[];
  deleteMany?:
    | Prisma.PrescriptionScalarWhereInput
    | Prisma.PrescriptionScalarWhereInput[];
};

export type PrescriptionCreateNestedManyWithoutEncounterInput = {
  create?:
    | Prisma.XOR<
        Prisma.PrescriptionCreateWithoutEncounterInput,
        Prisma.PrescriptionUncheckedCreateWithoutEncounterInput
      >
    | Prisma.PrescriptionCreateWithoutEncounterInput[]
    | Prisma.PrescriptionUncheckedCreateWithoutEncounterInput[];
  connectOrCreate?:
    | Prisma.PrescriptionCreateOrConnectWithoutEncounterInput
    | Prisma.PrescriptionCreateOrConnectWithoutEncounterInput[];
  createMany?: Prisma.PrescriptionCreateManyEncounterInputEnvelope;
  connect?:
    | Prisma.PrescriptionWhereUniqueInput
    | Prisma.PrescriptionWhereUniqueInput[];
};

export type PrescriptionUncheckedCreateNestedManyWithoutEncounterInput = {
  create?:
    | Prisma.XOR<
        Prisma.PrescriptionCreateWithoutEncounterInput,
        Prisma.PrescriptionUncheckedCreateWithoutEncounterInput
      >
    | Prisma.PrescriptionCreateWithoutEncounterInput[]
    | Prisma.PrescriptionUncheckedCreateWithoutEncounterInput[];
  connectOrCreate?:
    | Prisma.PrescriptionCreateOrConnectWithoutEncounterInput
    | Prisma.PrescriptionCreateOrConnectWithoutEncounterInput[];
  createMany?: Prisma.PrescriptionCreateManyEncounterInputEnvelope;
  connect?:
    | Prisma.PrescriptionWhereUniqueInput
    | Prisma.PrescriptionWhereUniqueInput[];
};

export type PrescriptionUpdateManyWithoutEncounterNestedInput = {
  create?:
    | Prisma.XOR<
        Prisma.PrescriptionCreateWithoutEncounterInput,
        Prisma.PrescriptionUncheckedCreateWithoutEncounterInput
      >
    | Prisma.PrescriptionCreateWithoutEncounterInput[]
    | Prisma.PrescriptionUncheckedCreateWithoutEncounterInput[];
  connectOrCreate?:
    | Prisma.PrescriptionCreateOrConnectWithoutEncounterInput
    | Prisma.PrescriptionCreateOrConnectWithoutEncounterInput[];
  upsert?:
    | Prisma.PrescriptionUpsertWithWhereUniqueWithoutEncounterInput
    | Prisma.PrescriptionUpsertWithWhereUniqueWithoutEncounterInput[];
  createMany?: Prisma.PrescriptionCreateManyEncounterInputEnvelope;
  set?:
    | Prisma.PrescriptionWhereUniqueInput
    | Prisma.PrescriptionWhereUniqueInput[];
  disconnect?:
    | Prisma.PrescriptionWhereUniqueInput
    | Prisma.PrescriptionWhereUniqueInput[];
  delete?:
    | Prisma.PrescriptionWhereUniqueInput
    | Prisma.PrescriptionWhereUniqueInput[];
  connect?:
    | Prisma.PrescriptionWhereUniqueInput
    | Prisma.PrescriptionWhereUniqueInput[];
  update?:
    | Prisma.PrescriptionUpdateWithWhereUniqueWithoutEncounterInput
    | Prisma.PrescriptionUpdateWithWhereUniqueWithoutEncounterInput[];
  updateMany?:
    | Prisma.PrescriptionUpdateManyWithWhereWithoutEncounterInput
    | Prisma.PrescriptionUpdateManyWithWhereWithoutEncounterInput[];
  deleteMany?:
    | Prisma.PrescriptionScalarWhereInput
    | Prisma.PrescriptionScalarWhereInput[];
};

export type PrescriptionUncheckedUpdateManyWithoutEncounterNestedInput = {
  create?:
    | Prisma.XOR<
        Prisma.PrescriptionCreateWithoutEncounterInput,
        Prisma.PrescriptionUncheckedCreateWithoutEncounterInput
      >
    | Prisma.PrescriptionCreateWithoutEncounterInput[]
    | Prisma.PrescriptionUncheckedCreateWithoutEncounterInput[];
  connectOrCreate?:
    | Prisma.PrescriptionCreateOrConnectWithoutEncounterInput
    | Prisma.PrescriptionCreateOrConnectWithoutEncounterInput[];
  upsert?:
    | Prisma.PrescriptionUpsertWithWhereUniqueWithoutEncounterInput
    | Prisma.PrescriptionUpsertWithWhereUniqueWithoutEncounterInput[];
  createMany?: Prisma.PrescriptionCreateManyEncounterInputEnvelope;
  set?:
    | Prisma.PrescriptionWhereUniqueInput
    | Prisma.PrescriptionWhereUniqueInput[];
  disconnect?:
    | Prisma.PrescriptionWhereUniqueInput
    | Prisma.PrescriptionWhereUniqueInput[];
  delete?:
    | Prisma.PrescriptionWhereUniqueInput
    | Prisma.PrescriptionWhereUniqueInput[];
  connect?:
    | Prisma.PrescriptionWhereUniqueInput
    | Prisma.PrescriptionWhereUniqueInput[];
  update?:
    | Prisma.PrescriptionUpdateWithWhereUniqueWithoutEncounterInput
    | Prisma.PrescriptionUpdateWithWhereUniqueWithoutEncounterInput[];
  updateMany?:
    | Prisma.PrescriptionUpdateManyWithWhereWithoutEncounterInput
    | Prisma.PrescriptionUpdateManyWithWhereWithoutEncounterInput[];
  deleteMany?:
    | Prisma.PrescriptionScalarWhereInput
    | Prisma.PrescriptionScalarWhereInput[];
};

export type PrescriptionCreateWithoutClinicInput = {
  id?: string;
  medicationName?: string | null;
  instructions?: string | null;
  issuedDate?: Date | string;
  endDate?: Date | string | null;
  status?: string;
  createdAt?: Date | string;
  updatedAt?: Date | string;
  encounter: Prisma.DiagnosisCreateNestedOneWithoutPrescriptionsInput;
  medicalRecord: Prisma.MedicalRecordsCreateNestedOneWithoutPrescriptionsInput;
  doctor?: Prisma.DoctorCreateNestedOneWithoutPrescriptionInput;
  patient: Prisma.PatientCreateNestedOneWithoutPrescriptionsInput;
  prescribedItems?: Prisma.PrescribedItemCreateNestedManyWithoutPrescriptionInput;
};

export type PrescriptionUncheckedCreateWithoutClinicInput = {
  id?: string;
  medicalRecordId: string;
  doctorId?: string | null;
  patientId: string;
  encounterId: string;
  medicationName?: string | null;
  instructions?: string | null;
  issuedDate?: Date | string;
  endDate?: Date | string | null;
  status?: string;
  createdAt?: Date | string;
  updatedAt?: Date | string;
  prescribedItems?: Prisma.PrescribedItemUncheckedCreateNestedManyWithoutPrescriptionInput;
};

export type PrescriptionCreateOrConnectWithoutClinicInput = {
  where: Prisma.PrescriptionWhereUniqueInput;
  create: Prisma.XOR<
    Prisma.PrescriptionCreateWithoutClinicInput,
    Prisma.PrescriptionUncheckedCreateWithoutClinicInput
  >;
};

export type PrescriptionCreateManyClinicInputEnvelope = {
  data:
    | Prisma.PrescriptionCreateManyClinicInput
    | Prisma.PrescriptionCreateManyClinicInput[];
  skipDuplicates?: boolean;
};

export type PrescriptionUpsertWithWhereUniqueWithoutClinicInput = {
  where: Prisma.PrescriptionWhereUniqueInput;
  update: Prisma.XOR<
    Prisma.PrescriptionUpdateWithoutClinicInput,
    Prisma.PrescriptionUncheckedUpdateWithoutClinicInput
  >;
  create: Prisma.XOR<
    Prisma.PrescriptionCreateWithoutClinicInput,
    Prisma.PrescriptionUncheckedCreateWithoutClinicInput
  >;
};

export type PrescriptionUpdateWithWhereUniqueWithoutClinicInput = {
  where: Prisma.PrescriptionWhereUniqueInput;
  data: Prisma.XOR<
    Prisma.PrescriptionUpdateWithoutClinicInput,
    Prisma.PrescriptionUncheckedUpdateWithoutClinicInput
  >;
};

export type PrescriptionUpdateManyWithWhereWithoutClinicInput = {
  where: Prisma.PrescriptionScalarWhereInput;
  data: Prisma.XOR<
    Prisma.PrescriptionUpdateManyMutationInput,
    Prisma.PrescriptionUncheckedUpdateManyWithoutClinicInput
  >;
};

export type PrescriptionScalarWhereInput = {
  AND?:
    | Prisma.PrescriptionScalarWhereInput
    | Prisma.PrescriptionScalarWhereInput[];
  OR?: Prisma.PrescriptionScalarWhereInput[];
  NOT?:
    | Prisma.PrescriptionScalarWhereInput
    | Prisma.PrescriptionScalarWhereInput[];
  id?: Prisma.StringFilter<"Prescription"> | string;
  medicalRecordId?: Prisma.StringFilter<"Prescription"> | string;
  doctorId?: Prisma.StringNullableFilter<"Prescription"> | string | null;
  patientId?: Prisma.StringFilter<"Prescription"> | string;
  encounterId?: Prisma.StringFilter<"Prescription"> | string;
  medicationName?: Prisma.StringNullableFilter<"Prescription"> | string | null;
  instructions?: Prisma.StringNullableFilter<"Prescription"> | string | null;
  issuedDate?: Prisma.DateTimeFilter<"Prescription"> | Date | string;
  endDate?:
    | Prisma.DateTimeNullableFilter<"Prescription">
    | Date
    | string
    | null;
  status?: Prisma.StringFilter<"Prescription"> | string;
  clinicId?: Prisma.StringNullableFilter<"Prescription"> | string | null;
  createdAt?: Prisma.DateTimeFilter<"Prescription"> | Date | string;
  updatedAt?: Prisma.DateTimeFilter<"Prescription"> | Date | string;
};

export type PrescriptionCreateWithoutDoctorInput = {
  id?: string;
  medicationName?: string | null;
  instructions?: string | null;
  issuedDate?: Date | string;
  endDate?: Date | string | null;
  status?: string;
  createdAt?: Date | string;
  updatedAt?: Date | string;
  encounter: Prisma.DiagnosisCreateNestedOneWithoutPrescriptionsInput;
  medicalRecord: Prisma.MedicalRecordsCreateNestedOneWithoutPrescriptionsInput;
  patient: Prisma.PatientCreateNestedOneWithoutPrescriptionsInput;
  clinic?: Prisma.ClinicCreateNestedOneWithoutPrescriptionsInput;
  prescribedItems?: Prisma.PrescribedItemCreateNestedManyWithoutPrescriptionInput;
};

export type PrescriptionUncheckedCreateWithoutDoctorInput = {
  id?: string;
  medicalRecordId: string;
  patientId: string;
  encounterId: string;
  medicationName?: string | null;
  instructions?: string | null;
  issuedDate?: Date | string;
  endDate?: Date | string | null;
  status?: string;
  clinicId?: string | null;
  createdAt?: Date | string;
  updatedAt?: Date | string;
  prescribedItems?: Prisma.PrescribedItemUncheckedCreateNestedManyWithoutPrescriptionInput;
};

export type PrescriptionCreateOrConnectWithoutDoctorInput = {
  where: Prisma.PrescriptionWhereUniqueInput;
  create: Prisma.XOR<
    Prisma.PrescriptionCreateWithoutDoctorInput,
    Prisma.PrescriptionUncheckedCreateWithoutDoctorInput
  >;
};

export type PrescriptionCreateManyDoctorInputEnvelope = {
  data:
    | Prisma.PrescriptionCreateManyDoctorInput
    | Prisma.PrescriptionCreateManyDoctorInput[];
  skipDuplicates?: boolean;
};

export type PrescriptionUpsertWithWhereUniqueWithoutDoctorInput = {
  where: Prisma.PrescriptionWhereUniqueInput;
  update: Prisma.XOR<
    Prisma.PrescriptionUpdateWithoutDoctorInput,
    Prisma.PrescriptionUncheckedUpdateWithoutDoctorInput
  >;
  create: Prisma.XOR<
    Prisma.PrescriptionCreateWithoutDoctorInput,
    Prisma.PrescriptionUncheckedCreateWithoutDoctorInput
  >;
};

export type PrescriptionUpdateWithWhereUniqueWithoutDoctorInput = {
  where: Prisma.PrescriptionWhereUniqueInput;
  data: Prisma.XOR<
    Prisma.PrescriptionUpdateWithoutDoctorInput,
    Prisma.PrescriptionUncheckedUpdateWithoutDoctorInput
  >;
};

export type PrescriptionUpdateManyWithWhereWithoutDoctorInput = {
  where: Prisma.PrescriptionScalarWhereInput;
  data: Prisma.XOR<
    Prisma.PrescriptionUpdateManyMutationInput,
    Prisma.PrescriptionUncheckedUpdateManyWithoutDoctorInput
  >;
};

export type PrescriptionCreateWithoutPrescribedItemsInput = {
  id?: string;
  medicationName?: string | null;
  instructions?: string | null;
  issuedDate?: Date | string;
  endDate?: Date | string | null;
  status?: string;
  createdAt?: Date | string;
  updatedAt?: Date | string;
  encounter: Prisma.DiagnosisCreateNestedOneWithoutPrescriptionsInput;
  medicalRecord: Prisma.MedicalRecordsCreateNestedOneWithoutPrescriptionsInput;
  doctor?: Prisma.DoctorCreateNestedOneWithoutPrescriptionInput;
  patient: Prisma.PatientCreateNestedOneWithoutPrescriptionsInput;
  clinic?: Prisma.ClinicCreateNestedOneWithoutPrescriptionsInput;
};

export type PrescriptionUncheckedCreateWithoutPrescribedItemsInput = {
  id?: string;
  medicalRecordId: string;
  doctorId?: string | null;
  patientId: string;
  encounterId: string;
  medicationName?: string | null;
  instructions?: string | null;
  issuedDate?: Date | string;
  endDate?: Date | string | null;
  status?: string;
  clinicId?: string | null;
  createdAt?: Date | string;
  updatedAt?: Date | string;
};

export type PrescriptionCreateOrConnectWithoutPrescribedItemsInput = {
  where: Prisma.PrescriptionWhereUniqueInput;
  create: Prisma.XOR<
    Prisma.PrescriptionCreateWithoutPrescribedItemsInput,
    Prisma.PrescriptionUncheckedCreateWithoutPrescribedItemsInput
  >;
};

export type PrescriptionUpsertWithoutPrescribedItemsInput = {
  update: Prisma.XOR<
    Prisma.PrescriptionUpdateWithoutPrescribedItemsInput,
    Prisma.PrescriptionUncheckedUpdateWithoutPrescribedItemsInput
  >;
  create: Prisma.XOR<
    Prisma.PrescriptionCreateWithoutPrescribedItemsInput,
    Prisma.PrescriptionUncheckedCreateWithoutPrescribedItemsInput
  >;
  where?: Prisma.PrescriptionWhereInput;
};

export type PrescriptionUpdateToOneWithWhereWithoutPrescribedItemsInput = {
  where?: Prisma.PrescriptionWhereInput;
  data: Prisma.XOR<
    Prisma.PrescriptionUpdateWithoutPrescribedItemsInput,
    Prisma.PrescriptionUncheckedUpdateWithoutPrescribedItemsInput
  >;
};

export type PrescriptionUpdateWithoutPrescribedItemsInput = {
  id?: Prisma.StringFieldUpdateOperationsInput | string;
  medicationName?:
    | Prisma.NullableStringFieldUpdateOperationsInput
    | string
    | null;
  instructions?:
    | Prisma.NullableStringFieldUpdateOperationsInput
    | string
    | null;
  issuedDate?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string;
  endDate?:
    | Prisma.NullableDateTimeFieldUpdateOperationsInput
    | Date
    | string
    | null;
  status?: Prisma.StringFieldUpdateOperationsInput | string;
  createdAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string;
  updatedAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string;
  encounter?: Prisma.DiagnosisUpdateOneRequiredWithoutPrescriptionsNestedInput;
  medicalRecord?: Prisma.MedicalRecordsUpdateOneRequiredWithoutPrescriptionsNestedInput;
  doctor?: Prisma.DoctorUpdateOneWithoutPrescriptionNestedInput;
  patient?: Prisma.PatientUpdateOneRequiredWithoutPrescriptionsNestedInput;
  clinic?: Prisma.ClinicUpdateOneWithoutPrescriptionsNestedInput;
};

export type PrescriptionUncheckedUpdateWithoutPrescribedItemsInput = {
  id?: Prisma.StringFieldUpdateOperationsInput | string;
  medicalRecordId?: Prisma.StringFieldUpdateOperationsInput | string;
  doctorId?: Prisma.NullableStringFieldUpdateOperationsInput | string | null;
  patientId?: Prisma.StringFieldUpdateOperationsInput | string;
  encounterId?: Prisma.StringFieldUpdateOperationsInput | string;
  medicationName?:
    | Prisma.NullableStringFieldUpdateOperationsInput
    | string
    | null;
  instructions?:
    | Prisma.NullableStringFieldUpdateOperationsInput
    | string
    | null;
  issuedDate?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string;
  endDate?:
    | Prisma.NullableDateTimeFieldUpdateOperationsInput
    | Date
    | string
    | null;
  status?: Prisma.StringFieldUpdateOperationsInput | string;
  clinicId?: Prisma.NullableStringFieldUpdateOperationsInput | string | null;
  createdAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string;
  updatedAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string;
};

export type PrescriptionCreateWithoutPatientInput = {
  id?: string;
  medicationName?: string | null;
  instructions?: string | null;
  issuedDate?: Date | string;
  endDate?: Date | string | null;
  status?: string;
  createdAt?: Date | string;
  updatedAt?: Date | string;
  encounter: Prisma.DiagnosisCreateNestedOneWithoutPrescriptionsInput;
  medicalRecord: Prisma.MedicalRecordsCreateNestedOneWithoutPrescriptionsInput;
  doctor?: Prisma.DoctorCreateNestedOneWithoutPrescriptionInput;
  clinic?: Prisma.ClinicCreateNestedOneWithoutPrescriptionsInput;
  prescribedItems?: Prisma.PrescribedItemCreateNestedManyWithoutPrescriptionInput;
};

export type PrescriptionUncheckedCreateWithoutPatientInput = {
  id?: string;
  medicalRecordId: string;
  doctorId?: string | null;
  encounterId: string;
  medicationName?: string | null;
  instructions?: string | null;
  issuedDate?: Date | string;
  endDate?: Date | string | null;
  status?: string;
  clinicId?: string | null;
  createdAt?: Date | string;
  updatedAt?: Date | string;
  prescribedItems?: Prisma.PrescribedItemUncheckedCreateNestedManyWithoutPrescriptionInput;
};

export type PrescriptionCreateOrConnectWithoutPatientInput = {
  where: Prisma.PrescriptionWhereUniqueInput;
  create: Prisma.XOR<
    Prisma.PrescriptionCreateWithoutPatientInput,
    Prisma.PrescriptionUncheckedCreateWithoutPatientInput
  >;
};

export type PrescriptionCreateManyPatientInputEnvelope = {
  data:
    | Prisma.PrescriptionCreateManyPatientInput
    | Prisma.PrescriptionCreateManyPatientInput[];
  skipDuplicates?: boolean;
};

export type PrescriptionUpsertWithWhereUniqueWithoutPatientInput = {
  where: Prisma.PrescriptionWhereUniqueInput;
  update: Prisma.XOR<
    Prisma.PrescriptionUpdateWithoutPatientInput,
    Prisma.PrescriptionUncheckedUpdateWithoutPatientInput
  >;
  create: Prisma.XOR<
    Prisma.PrescriptionCreateWithoutPatientInput,
    Prisma.PrescriptionUncheckedCreateWithoutPatientInput
  >;
};

export type PrescriptionUpdateWithWhereUniqueWithoutPatientInput = {
  where: Prisma.PrescriptionWhereUniqueInput;
  data: Prisma.XOR<
    Prisma.PrescriptionUpdateWithoutPatientInput,
    Prisma.PrescriptionUncheckedUpdateWithoutPatientInput
  >;
};

export type PrescriptionUpdateManyWithWhereWithoutPatientInput = {
  where: Prisma.PrescriptionScalarWhereInput;
  data: Prisma.XOR<
    Prisma.PrescriptionUpdateManyMutationInput,
    Prisma.PrescriptionUncheckedUpdateManyWithoutPatientInput
  >;
};

export type PrescriptionCreateWithoutMedicalRecordInput = {
  id?: string;
  medicationName?: string | null;
  instructions?: string | null;
  issuedDate?: Date | string;
  endDate?: Date | string | null;
  status?: string;
  createdAt?: Date | string;
  updatedAt?: Date | string;
  encounter: Prisma.DiagnosisCreateNestedOneWithoutPrescriptionsInput;
  doctor?: Prisma.DoctorCreateNestedOneWithoutPrescriptionInput;
  patient: Prisma.PatientCreateNestedOneWithoutPrescriptionsInput;
  clinic?: Prisma.ClinicCreateNestedOneWithoutPrescriptionsInput;
  prescribedItems?: Prisma.PrescribedItemCreateNestedManyWithoutPrescriptionInput;
};

export type PrescriptionUncheckedCreateWithoutMedicalRecordInput = {
  id?: string;
  doctorId?: string | null;
  patientId: string;
  encounterId: string;
  medicationName?: string | null;
  instructions?: string | null;
  issuedDate?: Date | string;
  endDate?: Date | string | null;
  status?: string;
  clinicId?: string | null;
  createdAt?: Date | string;
  updatedAt?: Date | string;
  prescribedItems?: Prisma.PrescribedItemUncheckedCreateNestedManyWithoutPrescriptionInput;
};

export type PrescriptionCreateOrConnectWithoutMedicalRecordInput = {
  where: Prisma.PrescriptionWhereUniqueInput;
  create: Prisma.XOR<
    Prisma.PrescriptionCreateWithoutMedicalRecordInput,
    Prisma.PrescriptionUncheckedCreateWithoutMedicalRecordInput
  >;
};

export type PrescriptionCreateManyMedicalRecordInputEnvelope = {
  data:
    | Prisma.PrescriptionCreateManyMedicalRecordInput
    | Prisma.PrescriptionCreateManyMedicalRecordInput[];
  skipDuplicates?: boolean;
};

export type PrescriptionUpsertWithWhereUniqueWithoutMedicalRecordInput = {
  where: Prisma.PrescriptionWhereUniqueInput;
  update: Prisma.XOR<
    Prisma.PrescriptionUpdateWithoutMedicalRecordInput,
    Prisma.PrescriptionUncheckedUpdateWithoutMedicalRecordInput
  >;
  create: Prisma.XOR<
    Prisma.PrescriptionCreateWithoutMedicalRecordInput,
    Prisma.PrescriptionUncheckedCreateWithoutMedicalRecordInput
  >;
};

export type PrescriptionUpdateWithWhereUniqueWithoutMedicalRecordInput = {
  where: Prisma.PrescriptionWhereUniqueInput;
  data: Prisma.XOR<
    Prisma.PrescriptionUpdateWithoutMedicalRecordInput,
    Prisma.PrescriptionUncheckedUpdateWithoutMedicalRecordInput
  >;
};

export type PrescriptionUpdateManyWithWhereWithoutMedicalRecordInput = {
  where: Prisma.PrescriptionScalarWhereInput;
  data: Prisma.XOR<
    Prisma.PrescriptionUpdateManyMutationInput,
    Prisma.PrescriptionUncheckedUpdateManyWithoutMedicalRecordInput
  >;
};

export type PrescriptionCreateWithoutEncounterInput = {
  id?: string;
  medicationName?: string | null;
  instructions?: string | null;
  issuedDate?: Date | string;
  endDate?: Date | string | null;
  status?: string;
  createdAt?: Date | string;
  updatedAt?: Date | string;
  medicalRecord: Prisma.MedicalRecordsCreateNestedOneWithoutPrescriptionsInput;
  doctor?: Prisma.DoctorCreateNestedOneWithoutPrescriptionInput;
  patient: Prisma.PatientCreateNestedOneWithoutPrescriptionsInput;
  clinic?: Prisma.ClinicCreateNestedOneWithoutPrescriptionsInput;
  prescribedItems?: Prisma.PrescribedItemCreateNestedManyWithoutPrescriptionInput;
};

export type PrescriptionUncheckedCreateWithoutEncounterInput = {
  id?: string;
  medicalRecordId: string;
  doctorId?: string | null;
  patientId: string;
  medicationName?: string | null;
  instructions?: string | null;
  issuedDate?: Date | string;
  endDate?: Date | string | null;
  status?: string;
  clinicId?: string | null;
  createdAt?: Date | string;
  updatedAt?: Date | string;
  prescribedItems?: Prisma.PrescribedItemUncheckedCreateNestedManyWithoutPrescriptionInput;
};

export type PrescriptionCreateOrConnectWithoutEncounterInput = {
  where: Prisma.PrescriptionWhereUniqueInput;
  create: Prisma.XOR<
    Prisma.PrescriptionCreateWithoutEncounterInput,
    Prisma.PrescriptionUncheckedCreateWithoutEncounterInput
  >;
};

export type PrescriptionCreateManyEncounterInputEnvelope = {
  data:
    | Prisma.PrescriptionCreateManyEncounterInput
    | Prisma.PrescriptionCreateManyEncounterInput[];
  skipDuplicates?: boolean;
};

export type PrescriptionUpsertWithWhereUniqueWithoutEncounterInput = {
  where: Prisma.PrescriptionWhereUniqueInput;
  update: Prisma.XOR<
    Prisma.PrescriptionUpdateWithoutEncounterInput,
    Prisma.PrescriptionUncheckedUpdateWithoutEncounterInput
  >;
  create: Prisma.XOR<
    Prisma.PrescriptionCreateWithoutEncounterInput,
    Prisma.PrescriptionUncheckedCreateWithoutEncounterInput
  >;
};

export type PrescriptionUpdateWithWhereUniqueWithoutEncounterInput = {
  where: Prisma.PrescriptionWhereUniqueInput;
  data: Prisma.XOR<
    Prisma.PrescriptionUpdateWithoutEncounterInput,
    Prisma.PrescriptionUncheckedUpdateWithoutEncounterInput
  >;
};

export type PrescriptionUpdateManyWithWhereWithoutEncounterInput = {
  where: Prisma.PrescriptionScalarWhereInput;
  data: Prisma.XOR<
    Prisma.PrescriptionUpdateManyMutationInput,
    Prisma.PrescriptionUncheckedUpdateManyWithoutEncounterInput
  >;
};

export type PrescriptionCreateManyClinicInput = {
  id?: string;
  medicalRecordId: string;
  doctorId?: string | null;
  patientId: string;
  encounterId: string;
  medicationName?: string | null;
  instructions?: string | null;
  issuedDate?: Date | string;
  endDate?: Date | string | null;
  status?: string;
  createdAt?: Date | string;
  updatedAt?: Date | string;
};

export type PrescriptionUpdateWithoutClinicInput = {
  id?: Prisma.StringFieldUpdateOperationsInput | string;
  medicationName?:
    | Prisma.NullableStringFieldUpdateOperationsInput
    | string
    | null;
  instructions?:
    | Prisma.NullableStringFieldUpdateOperationsInput
    | string
    | null;
  issuedDate?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string;
  endDate?:
    | Prisma.NullableDateTimeFieldUpdateOperationsInput
    | Date
    | string
    | null;
  status?: Prisma.StringFieldUpdateOperationsInput | string;
  createdAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string;
  updatedAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string;
  encounter?: Prisma.DiagnosisUpdateOneRequiredWithoutPrescriptionsNestedInput;
  medicalRecord?: Prisma.MedicalRecordsUpdateOneRequiredWithoutPrescriptionsNestedInput;
  doctor?: Prisma.DoctorUpdateOneWithoutPrescriptionNestedInput;
  patient?: Prisma.PatientUpdateOneRequiredWithoutPrescriptionsNestedInput;
  prescribedItems?: Prisma.PrescribedItemUpdateManyWithoutPrescriptionNestedInput;
};

export type PrescriptionUncheckedUpdateWithoutClinicInput = {
  id?: Prisma.StringFieldUpdateOperationsInput | string;
  medicalRecordId?: Prisma.StringFieldUpdateOperationsInput | string;
  doctorId?: Prisma.NullableStringFieldUpdateOperationsInput | string | null;
  patientId?: Prisma.StringFieldUpdateOperationsInput | string;
  encounterId?: Prisma.StringFieldUpdateOperationsInput | string;
  medicationName?:
    | Prisma.NullableStringFieldUpdateOperationsInput
    | string
    | null;
  instructions?:
    | Prisma.NullableStringFieldUpdateOperationsInput
    | string
    | null;
  issuedDate?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string;
  endDate?:
    | Prisma.NullableDateTimeFieldUpdateOperationsInput
    | Date
    | string
    | null;
  status?: Prisma.StringFieldUpdateOperationsInput | string;
  createdAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string;
  updatedAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string;
  prescribedItems?: Prisma.PrescribedItemUncheckedUpdateManyWithoutPrescriptionNestedInput;
};

export type PrescriptionUncheckedUpdateManyWithoutClinicInput = {
  id?: Prisma.StringFieldUpdateOperationsInput | string;
  medicalRecordId?: Prisma.StringFieldUpdateOperationsInput | string;
  doctorId?: Prisma.NullableStringFieldUpdateOperationsInput | string | null;
  patientId?: Prisma.StringFieldUpdateOperationsInput | string;
  encounterId?: Prisma.StringFieldUpdateOperationsInput | string;
  medicationName?:
    | Prisma.NullableStringFieldUpdateOperationsInput
    | string
    | null;
  instructions?:
    | Prisma.NullableStringFieldUpdateOperationsInput
    | string
    | null;
  issuedDate?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string;
  endDate?:
    | Prisma.NullableDateTimeFieldUpdateOperationsInput
    | Date
    | string
    | null;
  status?: Prisma.StringFieldUpdateOperationsInput | string;
  createdAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string;
  updatedAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string;
};

export type PrescriptionCreateManyDoctorInput = {
  id?: string;
  medicalRecordId: string;
  patientId: string;
  encounterId: string;
  medicationName?: string | null;
  instructions?: string | null;
  issuedDate?: Date | string;
  endDate?: Date | string | null;
  status?: string;
  clinicId?: string | null;
  createdAt?: Date | string;
  updatedAt?: Date | string;
};

export type PrescriptionUpdateWithoutDoctorInput = {
  id?: Prisma.StringFieldUpdateOperationsInput | string;
  medicationName?:
    | Prisma.NullableStringFieldUpdateOperationsInput
    | string
    | null;
  instructions?:
    | Prisma.NullableStringFieldUpdateOperationsInput
    | string
    | null;
  issuedDate?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string;
  endDate?:
    | Prisma.NullableDateTimeFieldUpdateOperationsInput
    | Date
    | string
    | null;
  status?: Prisma.StringFieldUpdateOperationsInput | string;
  createdAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string;
  updatedAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string;
  encounter?: Prisma.DiagnosisUpdateOneRequiredWithoutPrescriptionsNestedInput;
  medicalRecord?: Prisma.MedicalRecordsUpdateOneRequiredWithoutPrescriptionsNestedInput;
  patient?: Prisma.PatientUpdateOneRequiredWithoutPrescriptionsNestedInput;
  clinic?: Prisma.ClinicUpdateOneWithoutPrescriptionsNestedInput;
  prescribedItems?: Prisma.PrescribedItemUpdateManyWithoutPrescriptionNestedInput;
};

export type PrescriptionUncheckedUpdateWithoutDoctorInput = {
  id?: Prisma.StringFieldUpdateOperationsInput | string;
  medicalRecordId?: Prisma.StringFieldUpdateOperationsInput | string;
  patientId?: Prisma.StringFieldUpdateOperationsInput | string;
  encounterId?: Prisma.StringFieldUpdateOperationsInput | string;
  medicationName?:
    | Prisma.NullableStringFieldUpdateOperationsInput
    | string
    | null;
  instructions?:
    | Prisma.NullableStringFieldUpdateOperationsInput
    | string
    | null;
  issuedDate?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string;
  endDate?:
    | Prisma.NullableDateTimeFieldUpdateOperationsInput
    | Date
    | string
    | null;
  status?: Prisma.StringFieldUpdateOperationsInput | string;
  clinicId?: Prisma.NullableStringFieldUpdateOperationsInput | string | null;
  createdAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string;
  updatedAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string;
  prescribedItems?: Prisma.PrescribedItemUncheckedUpdateManyWithoutPrescriptionNestedInput;
};

export type PrescriptionUncheckedUpdateManyWithoutDoctorInput = {
  id?: Prisma.StringFieldUpdateOperationsInput | string;
  medicalRecordId?: Prisma.StringFieldUpdateOperationsInput | string;
  patientId?: Prisma.StringFieldUpdateOperationsInput | string;
  encounterId?: Prisma.StringFieldUpdateOperationsInput | string;
  medicationName?:
    | Prisma.NullableStringFieldUpdateOperationsInput
    | string
    | null;
  instructions?:
    | Prisma.NullableStringFieldUpdateOperationsInput
    | string
    | null;
  issuedDate?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string;
  endDate?:
    | Prisma.NullableDateTimeFieldUpdateOperationsInput
    | Date
    | string
    | null;
  status?: Prisma.StringFieldUpdateOperationsInput | string;
  clinicId?: Prisma.NullableStringFieldUpdateOperationsInput | string | null;
  createdAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string;
  updatedAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string;
};

export type PrescriptionCreateManyPatientInput = {
  id?: string;
  medicalRecordId: string;
  doctorId?: string | null;
  encounterId: string;
  medicationName?: string | null;
  instructions?: string | null;
  issuedDate?: Date | string;
  endDate?: Date | string | null;
  status?: string;
  clinicId?: string | null;
  createdAt?: Date | string;
  updatedAt?: Date | string;
};

export type PrescriptionUpdateWithoutPatientInput = {
  id?: Prisma.StringFieldUpdateOperationsInput | string;
  medicationName?:
    | Prisma.NullableStringFieldUpdateOperationsInput
    | string
    | null;
  instructions?:
    | Prisma.NullableStringFieldUpdateOperationsInput
    | string
    | null;
  issuedDate?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string;
  endDate?:
    | Prisma.NullableDateTimeFieldUpdateOperationsInput
    | Date
    | string
    | null;
  status?: Prisma.StringFieldUpdateOperationsInput | string;
  createdAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string;
  updatedAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string;
  encounter?: Prisma.DiagnosisUpdateOneRequiredWithoutPrescriptionsNestedInput;
  medicalRecord?: Prisma.MedicalRecordsUpdateOneRequiredWithoutPrescriptionsNestedInput;
  doctor?: Prisma.DoctorUpdateOneWithoutPrescriptionNestedInput;
  clinic?: Prisma.ClinicUpdateOneWithoutPrescriptionsNestedInput;
  prescribedItems?: Prisma.PrescribedItemUpdateManyWithoutPrescriptionNestedInput;
};

export type PrescriptionUncheckedUpdateWithoutPatientInput = {
  id?: Prisma.StringFieldUpdateOperationsInput | string;
  medicalRecordId?: Prisma.StringFieldUpdateOperationsInput | string;
  doctorId?: Prisma.NullableStringFieldUpdateOperationsInput | string | null;
  encounterId?: Prisma.StringFieldUpdateOperationsInput | string;
  medicationName?:
    | Prisma.NullableStringFieldUpdateOperationsInput
    | string
    | null;
  instructions?:
    | Prisma.NullableStringFieldUpdateOperationsInput
    | string
    | null;
  issuedDate?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string;
  endDate?:
    | Prisma.NullableDateTimeFieldUpdateOperationsInput
    | Date
    | string
    | null;
  status?: Prisma.StringFieldUpdateOperationsInput | string;
  clinicId?: Prisma.NullableStringFieldUpdateOperationsInput | string | null;
  createdAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string;
  updatedAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string;
  prescribedItems?: Prisma.PrescribedItemUncheckedUpdateManyWithoutPrescriptionNestedInput;
};

export type PrescriptionUncheckedUpdateManyWithoutPatientInput = {
  id?: Prisma.StringFieldUpdateOperationsInput | string;
  medicalRecordId?: Prisma.StringFieldUpdateOperationsInput | string;
  doctorId?: Prisma.NullableStringFieldUpdateOperationsInput | string | null;
  encounterId?: Prisma.StringFieldUpdateOperationsInput | string;
  medicationName?:
    | Prisma.NullableStringFieldUpdateOperationsInput
    | string
    | null;
  instructions?:
    | Prisma.NullableStringFieldUpdateOperationsInput
    | string
    | null;
  issuedDate?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string;
  endDate?:
    | Prisma.NullableDateTimeFieldUpdateOperationsInput
    | Date
    | string
    | null;
  status?: Prisma.StringFieldUpdateOperationsInput | string;
  clinicId?: Prisma.NullableStringFieldUpdateOperationsInput | string | null;
  createdAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string;
  updatedAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string;
};

export type PrescriptionCreateManyMedicalRecordInput = {
  id?: string;
  doctorId?: string | null;
  patientId: string;
  encounterId: string;
  medicationName?: string | null;
  instructions?: string | null;
  issuedDate?: Date | string;
  endDate?: Date | string | null;
  status?: string;
  clinicId?: string | null;
  createdAt?: Date | string;
  updatedAt?: Date | string;
};

export type PrescriptionUpdateWithoutMedicalRecordInput = {
  id?: Prisma.StringFieldUpdateOperationsInput | string;
  medicationName?:
    | Prisma.NullableStringFieldUpdateOperationsInput
    | string
    | null;
  instructions?:
    | Prisma.NullableStringFieldUpdateOperationsInput
    | string
    | null;
  issuedDate?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string;
  endDate?:
    | Prisma.NullableDateTimeFieldUpdateOperationsInput
    | Date
    | string
    | null;
  status?: Prisma.StringFieldUpdateOperationsInput | string;
  createdAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string;
  updatedAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string;
  encounter?: Prisma.DiagnosisUpdateOneRequiredWithoutPrescriptionsNestedInput;
  doctor?: Prisma.DoctorUpdateOneWithoutPrescriptionNestedInput;
  patient?: Prisma.PatientUpdateOneRequiredWithoutPrescriptionsNestedInput;
  clinic?: Prisma.ClinicUpdateOneWithoutPrescriptionsNestedInput;
  prescribedItems?: Prisma.PrescribedItemUpdateManyWithoutPrescriptionNestedInput;
};

export type PrescriptionUncheckedUpdateWithoutMedicalRecordInput = {
  id?: Prisma.StringFieldUpdateOperationsInput | string;
  doctorId?: Prisma.NullableStringFieldUpdateOperationsInput | string | null;
  patientId?: Prisma.StringFieldUpdateOperationsInput | string;
  encounterId?: Prisma.StringFieldUpdateOperationsInput | string;
  medicationName?:
    | Prisma.NullableStringFieldUpdateOperationsInput
    | string
    | null;
  instructions?:
    | Prisma.NullableStringFieldUpdateOperationsInput
    | string
    | null;
  issuedDate?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string;
  endDate?:
    | Prisma.NullableDateTimeFieldUpdateOperationsInput
    | Date
    | string
    | null;
  status?: Prisma.StringFieldUpdateOperationsInput | string;
  clinicId?: Prisma.NullableStringFieldUpdateOperationsInput | string | null;
  createdAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string;
  updatedAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string;
  prescribedItems?: Prisma.PrescribedItemUncheckedUpdateManyWithoutPrescriptionNestedInput;
};

export type PrescriptionUncheckedUpdateManyWithoutMedicalRecordInput = {
  id?: Prisma.StringFieldUpdateOperationsInput | string;
  doctorId?: Prisma.NullableStringFieldUpdateOperationsInput | string | null;
  patientId?: Prisma.StringFieldUpdateOperationsInput | string;
  encounterId?: Prisma.StringFieldUpdateOperationsInput | string;
  medicationName?:
    | Prisma.NullableStringFieldUpdateOperationsInput
    | string
    | null;
  instructions?:
    | Prisma.NullableStringFieldUpdateOperationsInput
    | string
    | null;
  issuedDate?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string;
  endDate?:
    | Prisma.NullableDateTimeFieldUpdateOperationsInput
    | Date
    | string
    | null;
  status?: Prisma.StringFieldUpdateOperationsInput | string;
  clinicId?: Prisma.NullableStringFieldUpdateOperationsInput | string | null;
  createdAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string;
  updatedAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string;
};

export type PrescriptionCreateManyEncounterInput = {
  id?: string;
  medicalRecordId: string;
  doctorId?: string | null;
  patientId: string;
  medicationName?: string | null;
  instructions?: string | null;
  issuedDate?: Date | string;
  endDate?: Date | string | null;
  status?: string;
  clinicId?: string | null;
  createdAt?: Date | string;
  updatedAt?: Date | string;
};

export type PrescriptionUpdateWithoutEncounterInput = {
  id?: Prisma.StringFieldUpdateOperationsInput | string;
  medicationName?:
    | Prisma.NullableStringFieldUpdateOperationsInput
    | string
    | null;
  instructions?:
    | Prisma.NullableStringFieldUpdateOperationsInput
    | string
    | null;
  issuedDate?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string;
  endDate?:
    | Prisma.NullableDateTimeFieldUpdateOperationsInput
    | Date
    | string
    | null;
  status?: Prisma.StringFieldUpdateOperationsInput | string;
  createdAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string;
  updatedAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string;
  medicalRecord?: Prisma.MedicalRecordsUpdateOneRequiredWithoutPrescriptionsNestedInput;
  doctor?: Prisma.DoctorUpdateOneWithoutPrescriptionNestedInput;
  patient?: Prisma.PatientUpdateOneRequiredWithoutPrescriptionsNestedInput;
  clinic?: Prisma.ClinicUpdateOneWithoutPrescriptionsNestedInput;
  prescribedItems?: Prisma.PrescribedItemUpdateManyWithoutPrescriptionNestedInput;
};

export type PrescriptionUncheckedUpdateWithoutEncounterInput = {
  id?: Prisma.StringFieldUpdateOperationsInput | string;
  medicalRecordId?: Prisma.StringFieldUpdateOperationsInput | string;
  doctorId?: Prisma.NullableStringFieldUpdateOperationsInput | string | null;
  patientId?: Prisma.StringFieldUpdateOperationsInput | string;
  medicationName?:
    | Prisma.NullableStringFieldUpdateOperationsInput
    | string
    | null;
  instructions?:
    | Prisma.NullableStringFieldUpdateOperationsInput
    | string
    | null;
  issuedDate?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string;
  endDate?:
    | Prisma.NullableDateTimeFieldUpdateOperationsInput
    | Date
    | string
    | null;
  status?: Prisma.StringFieldUpdateOperationsInput | string;
  clinicId?: Prisma.NullableStringFieldUpdateOperationsInput | string | null;
  createdAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string;
  updatedAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string;
  prescribedItems?: Prisma.PrescribedItemUncheckedUpdateManyWithoutPrescriptionNestedInput;
};

export type PrescriptionUncheckedUpdateManyWithoutEncounterInput = {
  id?: Prisma.StringFieldUpdateOperationsInput | string;
  medicalRecordId?: Prisma.StringFieldUpdateOperationsInput | string;
  doctorId?: Prisma.NullableStringFieldUpdateOperationsInput | string | null;
  patientId?: Prisma.StringFieldUpdateOperationsInput | string;
  medicationName?:
    | Prisma.NullableStringFieldUpdateOperationsInput
    | string
    | null;
  instructions?:
    | Prisma.NullableStringFieldUpdateOperationsInput
    | string
    | null;
  issuedDate?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string;
  endDate?:
    | Prisma.NullableDateTimeFieldUpdateOperationsInput
    | Date
    | string
    | null;
  status?: Prisma.StringFieldUpdateOperationsInput | string;
  clinicId?: Prisma.NullableStringFieldUpdateOperationsInput | string | null;
  createdAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string;
  updatedAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string;
};

/**
 * Count Type PrescriptionCountOutputType
 */

export type PrescriptionCountOutputType = {
  prescribedItems: number;
};

export type PrescriptionCountOutputTypeSelect<
  ExtArgs extends
    runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs,
> = {
  prescribedItems?:
    | boolean
    | PrescriptionCountOutputTypeCountPrescribedItemsArgs;
};

/**
 * PrescriptionCountOutputType without action
 */
export type PrescriptionCountOutputTypeDefaultArgs<
  ExtArgs extends
    runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs,
> = {
  /**
   * Select specific fields to fetch from the PrescriptionCountOutputType
   */
  select?: Prisma.PrescriptionCountOutputTypeSelect<ExtArgs> | null;
};

/**
 * PrescriptionCountOutputType without action
 */
export type PrescriptionCountOutputTypeCountPrescribedItemsArgs<
  ExtArgs extends
    runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs,
> = {
  where?: Prisma.PrescribedItemWhereInput;
};

export type PrescriptionSelect<
  ExtArgs extends
    runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs,
> = runtime.Types.Extensions.GetSelect<
  {
    id?: boolean;
    medicalRecordId?: boolean;
    doctorId?: boolean;
    patientId?: boolean;
    encounterId?: boolean;
    medicationName?: boolean;
    instructions?: boolean;
    issuedDate?: boolean;
    endDate?: boolean;
    status?: boolean;
    clinicId?: boolean;
    createdAt?: boolean;
    updatedAt?: boolean;
    encounter?: boolean | Prisma.DiagnosisDefaultArgs<ExtArgs>;
    medicalRecord?: boolean | Prisma.MedicalRecordsDefaultArgs<ExtArgs>;
    doctor?: boolean | Prisma.Prescription$doctorArgs<ExtArgs>;
    patient?: boolean | Prisma.PatientDefaultArgs<ExtArgs>;
    clinic?: boolean | Prisma.Prescription$clinicArgs<ExtArgs>;
    prescribedItems?:
      | boolean
      | Prisma.Prescription$prescribedItemsArgs<ExtArgs>;
    _count?: boolean | Prisma.PrescriptionCountOutputTypeDefaultArgs<ExtArgs>;
  },
  ExtArgs["result"]["prescription"]
>;

export type PrescriptionSelectCreateManyAndReturn<
  ExtArgs extends
    runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs,
> = runtime.Types.Extensions.GetSelect<
  {
    id?: boolean;
    medicalRecordId?: boolean;
    doctorId?: boolean;
    patientId?: boolean;
    encounterId?: boolean;
    medicationName?: boolean;
    instructions?: boolean;
    issuedDate?: boolean;
    endDate?: boolean;
    status?: boolean;
    clinicId?: boolean;
    createdAt?: boolean;
    updatedAt?: boolean;
    encounter?: boolean | Prisma.DiagnosisDefaultArgs<ExtArgs>;
    medicalRecord?: boolean | Prisma.MedicalRecordsDefaultArgs<ExtArgs>;
    doctor?: boolean | Prisma.Prescription$doctorArgs<ExtArgs>;
    patient?: boolean | Prisma.PatientDefaultArgs<ExtArgs>;
    clinic?: boolean | Prisma.Prescription$clinicArgs<ExtArgs>;
  },
  ExtArgs["result"]["prescription"]
>;

export type PrescriptionSelectUpdateManyAndReturn<
  ExtArgs extends
    runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs,
> = runtime.Types.Extensions.GetSelect<
  {
    id?: boolean;
    medicalRecordId?: boolean;
    doctorId?: boolean;
    patientId?: boolean;
    encounterId?: boolean;
    medicationName?: boolean;
    instructions?: boolean;
    issuedDate?: boolean;
    endDate?: boolean;
    status?: boolean;
    clinicId?: boolean;
    createdAt?: boolean;
    updatedAt?: boolean;
    encounter?: boolean | Prisma.DiagnosisDefaultArgs<ExtArgs>;
    medicalRecord?: boolean | Prisma.MedicalRecordsDefaultArgs<ExtArgs>;
    doctor?: boolean | Prisma.Prescription$doctorArgs<ExtArgs>;
    patient?: boolean | Prisma.PatientDefaultArgs<ExtArgs>;
    clinic?: boolean | Prisma.Prescription$clinicArgs<ExtArgs>;
  },
  ExtArgs["result"]["prescription"]
>;

export type PrescriptionSelectScalar = {
  id?: boolean;
  medicalRecordId?: boolean;
  doctorId?: boolean;
  patientId?: boolean;
  encounterId?: boolean;
  medicationName?: boolean;
  instructions?: boolean;
  issuedDate?: boolean;
  endDate?: boolean;
  status?: boolean;
  clinicId?: boolean;
  createdAt?: boolean;
  updatedAt?: boolean;
};

export type PrescriptionOmit<
  ExtArgs extends
    runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs,
> = runtime.Types.Extensions.GetOmit<
  | "id"
  | "medicalRecordId"
  | "doctorId"
  | "patientId"
  | "encounterId"
  | "medicationName"
  | "instructions"
  | "issuedDate"
  | "endDate"
  | "status"
  | "clinicId"
  | "createdAt"
  | "updatedAt",
  ExtArgs["result"]["prescription"]
>;
export type PrescriptionInclude<
  ExtArgs extends
    runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs,
> = {
  encounter?: boolean | Prisma.DiagnosisDefaultArgs<ExtArgs>;
  medicalRecord?: boolean | Prisma.MedicalRecordsDefaultArgs<ExtArgs>;
  doctor?: boolean | Prisma.Prescription$doctorArgs<ExtArgs>;
  patient?: boolean | Prisma.PatientDefaultArgs<ExtArgs>;
  clinic?: boolean | Prisma.Prescription$clinicArgs<ExtArgs>;
  prescribedItems?: boolean | Prisma.Prescription$prescribedItemsArgs<ExtArgs>;
  _count?: boolean | Prisma.PrescriptionCountOutputTypeDefaultArgs<ExtArgs>;
};
export type PrescriptionIncludeCreateManyAndReturn<
  ExtArgs extends
    runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs,
> = {
  encounter?: boolean | Prisma.DiagnosisDefaultArgs<ExtArgs>;
  medicalRecord?: boolean | Prisma.MedicalRecordsDefaultArgs<ExtArgs>;
  doctor?: boolean | Prisma.Prescription$doctorArgs<ExtArgs>;
  patient?: boolean | Prisma.PatientDefaultArgs<ExtArgs>;
  clinic?: boolean | Prisma.Prescription$clinicArgs<ExtArgs>;
};
export type PrescriptionIncludeUpdateManyAndReturn<
  ExtArgs extends
    runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs,
> = {
  encounter?: boolean | Prisma.DiagnosisDefaultArgs<ExtArgs>;
  medicalRecord?: boolean | Prisma.MedicalRecordsDefaultArgs<ExtArgs>;
  doctor?: boolean | Prisma.Prescription$doctorArgs<ExtArgs>;
  patient?: boolean | Prisma.PatientDefaultArgs<ExtArgs>;
  clinic?: boolean | Prisma.Prescription$clinicArgs<ExtArgs>;
};

export type $PrescriptionPayload<
  ExtArgs extends
    runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs,
> = {
  name: "Prescription";
  objects: {
    encounter: Prisma.$DiagnosisPayload<ExtArgs>;
    medicalRecord: Prisma.$MedicalRecordsPayload<ExtArgs>;
    doctor: Prisma.$DoctorPayload<ExtArgs> | null;
    patient: Prisma.$PatientPayload<ExtArgs>;
    clinic: Prisma.$ClinicPayload<ExtArgs> | null;
    prescribedItems: Prisma.$PrescribedItemPayload<ExtArgs>[];
  };
  scalars: runtime.Types.Extensions.GetPayloadResult<
    {
      id: string;
      medicalRecordId: string;
      doctorId: string | null;
      patientId: string;
      encounterId: string;
      medicationName: string | null;
      instructions: string | null;
      issuedDate: Date;
      endDate: Date | null;
      status: string;
      clinicId: string | null;
      createdAt: Date;
      updatedAt: Date;
    },
    ExtArgs["result"]["prescription"]
  >;
  composites: {};
};

export type PrescriptionGetPayload<
  S extends boolean | null | undefined | PrescriptionDefaultArgs,
> = runtime.Types.Result.GetResult<Prisma.$PrescriptionPayload, S>;

export type PrescriptionCountArgs<
  ExtArgs extends
    runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs,
> = Omit<
  PrescriptionFindManyArgs,
  "select" | "include" | "distinct" | "omit" | "relationLoadStrategy"
> & {
  select?: PrescriptionCountAggregateInputType | true;
};

export interface PrescriptionDelegate<
  ExtArgs extends
    runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs,
  GlobalOmitOptions = {},
> {
  [K: symbol]: {
    types: Prisma.TypeMap<ExtArgs>["model"]["Prescription"];
    meta: { name: "Prescription" };
  };
  /**
   * Find zero or one Prescription that matches the filter.
   * @param {PrescriptionFindUniqueArgs} args - Arguments to find a Prescription
   * @example
   * // Get one Prescription
   * const prescription = await prisma.prescription.findUnique({
   *   where: {
   *     // ... provide filter here
   *   }
   * })
   */
  findUnique<T extends PrescriptionFindUniqueArgs>(
    args: Prisma.SelectSubset<T, PrescriptionFindUniqueArgs<ExtArgs>>,
  ): Prisma.Prisma__PrescriptionClient<
    runtime.Types.Result.GetResult<
      Prisma.$PrescriptionPayload<ExtArgs>,
      T,
      "findUnique",
      GlobalOmitOptions
    > | null,
    null,
    ExtArgs,
    GlobalOmitOptions
  >;

  /**
   * Find one Prescription that matches the filter or throw an error with `error.code='P2025'`
   * if no matches were found.
   * @param {PrescriptionFindUniqueOrThrowArgs} args - Arguments to find a Prescription
   * @example
   * // Get one Prescription
   * const prescription = await prisma.prescription.findUniqueOrThrow({
   *   where: {
   *     // ... provide filter here
   *   }
   * })
   */
  findUniqueOrThrow<T extends PrescriptionFindUniqueOrThrowArgs>(
    args: Prisma.SelectSubset<T, PrescriptionFindUniqueOrThrowArgs<ExtArgs>>,
  ): Prisma.Prisma__PrescriptionClient<
    runtime.Types.Result.GetResult<
      Prisma.$PrescriptionPayload<ExtArgs>,
      T,
      "findUniqueOrThrow",
      GlobalOmitOptions
    >,
    never,
    ExtArgs,
    GlobalOmitOptions
  >;

  /**
   * Find the first Prescription that matches the filter.
   * Note, that providing `undefined` is treated as the value not being there.
   * Read more here: https://pris.ly/d/null-undefined
   * @param {PrescriptionFindFirstArgs} args - Arguments to find a Prescription
   * @example
   * // Get one Prescription
   * const prescription = await prisma.prescription.findFirst({
   *   where: {
   *     // ... provide filter here
   *   }
   * })
   */
  findFirst<T extends PrescriptionFindFirstArgs>(
    args?: Prisma.SelectSubset<T, PrescriptionFindFirstArgs<ExtArgs>>,
  ): Prisma.Prisma__PrescriptionClient<
    runtime.Types.Result.GetResult<
      Prisma.$PrescriptionPayload<ExtArgs>,
      T,
      "findFirst",
      GlobalOmitOptions
    > | null,
    null,
    ExtArgs,
    GlobalOmitOptions
  >;

  /**
   * Find the first Prescription that matches the filter or
   * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
   * Note, that providing `undefined` is treated as the value not being there.
   * Read more here: https://pris.ly/d/null-undefined
   * @param {PrescriptionFindFirstOrThrowArgs} args - Arguments to find a Prescription
   * @example
   * // Get one Prescription
   * const prescription = await prisma.prescription.findFirstOrThrow({
   *   where: {
   *     // ... provide filter here
   *   }
   * })
   */
  findFirstOrThrow<T extends PrescriptionFindFirstOrThrowArgs>(
    args?: Prisma.SelectSubset<T, PrescriptionFindFirstOrThrowArgs<ExtArgs>>,
  ): Prisma.Prisma__PrescriptionClient<
    runtime.Types.Result.GetResult<
      Prisma.$PrescriptionPayload<ExtArgs>,
      T,
      "findFirstOrThrow",
      GlobalOmitOptions
    >,
    never,
    ExtArgs,
    GlobalOmitOptions
  >;

  /**
   * Find zero or more Prescriptions that matches the filter.
   * Note, that providing `undefined` is treated as the value not being there.
   * Read more here: https://pris.ly/d/null-undefined
   * @param {PrescriptionFindManyArgs} args - Arguments to filter and select certain fields only.
   * @example
   * // Get all Prescriptions
   * const prescriptions = await prisma.prescription.findMany()
   *
   * // Get first 10 Prescriptions
   * const prescriptions = await prisma.prescription.findMany({ take: 10 })
   *
   * // Only select the `id`
   * const prescriptionWithIdOnly = await prisma.prescription.findMany({ select: { id: true } })
   *
   */
  findMany<T extends PrescriptionFindManyArgs>(
    args?: Prisma.SelectSubset<T, PrescriptionFindManyArgs<ExtArgs>>,
  ): Prisma.PrismaPromise<
    runtime.Types.Result.GetResult<
      Prisma.$PrescriptionPayload<ExtArgs>,
      T,
      "findMany",
      GlobalOmitOptions
    >
  >;

  /**
   * Create a Prescription.
   * @param {PrescriptionCreateArgs} args - Arguments to create a Prescription.
   * @example
   * // Create one Prescription
   * const Prescription = await prisma.prescription.create({
   *   data: {
   *     // ... data to create a Prescription
   *   }
   * })
   *
   */
  create<T extends PrescriptionCreateArgs>(
    args: Prisma.SelectSubset<T, PrescriptionCreateArgs<ExtArgs>>,
  ): Prisma.Prisma__PrescriptionClient<
    runtime.Types.Result.GetResult<
      Prisma.$PrescriptionPayload<ExtArgs>,
      T,
      "create",
      GlobalOmitOptions
    >,
    never,
    ExtArgs,
    GlobalOmitOptions
  >;

  /**
   * Create many Prescriptions.
   * @param {PrescriptionCreateManyArgs} args - Arguments to create many Prescriptions.
   * @example
   * // Create many Prescriptions
   * const prescription = await prisma.prescription.createMany({
   *   data: [
   *     // ... provide data here
   *   ]
   * })
   *
   */
  createMany<T extends PrescriptionCreateManyArgs>(
    args?: Prisma.SelectSubset<T, PrescriptionCreateManyArgs<ExtArgs>>,
  ): Prisma.PrismaPromise<Prisma.BatchPayload>;

  /**
   * Create many Prescriptions and returns the data saved in the database.
   * @param {PrescriptionCreateManyAndReturnArgs} args - Arguments to create many Prescriptions.
   * @example
   * // Create many Prescriptions
   * const prescription = await prisma.prescription.createManyAndReturn({
   *   data: [
   *     // ... provide data here
   *   ]
   * })
   *
   * // Create many Prescriptions and only return the `id`
   * const prescriptionWithIdOnly = await prisma.prescription.createManyAndReturn({
   *   select: { id: true },
   *   data: [
   *     // ... provide data here
   *   ]
   * })
   * Note, that providing `undefined` is treated as the value not being there.
   * Read more here: https://pris.ly/d/null-undefined
   *
   */
  createManyAndReturn<T extends PrescriptionCreateManyAndReturnArgs>(
    args?: Prisma.SelectSubset<T, PrescriptionCreateManyAndReturnArgs<ExtArgs>>,
  ): Prisma.PrismaPromise<
    runtime.Types.Result.GetResult<
      Prisma.$PrescriptionPayload<ExtArgs>,
      T,
      "createManyAndReturn",
      GlobalOmitOptions
    >
  >;

  /**
   * Delete a Prescription.
   * @param {PrescriptionDeleteArgs} args - Arguments to delete one Prescription.
   * @example
   * // Delete one Prescription
   * const Prescription = await prisma.prescription.delete({
   *   where: {
   *     // ... filter to delete one Prescription
   *   }
   * })
   *
   */
  delete<T extends PrescriptionDeleteArgs>(
    args: Prisma.SelectSubset<T, PrescriptionDeleteArgs<ExtArgs>>,
  ): Prisma.Prisma__PrescriptionClient<
    runtime.Types.Result.GetResult<
      Prisma.$PrescriptionPayload<ExtArgs>,
      T,
      "delete",
      GlobalOmitOptions
    >,
    never,
    ExtArgs,
    GlobalOmitOptions
  >;

  /**
   * Update one Prescription.
   * @param {PrescriptionUpdateArgs} args - Arguments to update one Prescription.
   * @example
   * // Update one Prescription
   * const prescription = await prisma.prescription.update({
   *   where: {
   *     // ... provide filter here
   *   },
   *   data: {
   *     // ... provide data here
   *   }
   * })
   *
   */
  update<T extends PrescriptionUpdateArgs>(
    args: Prisma.SelectSubset<T, PrescriptionUpdateArgs<ExtArgs>>,
  ): Prisma.Prisma__PrescriptionClient<
    runtime.Types.Result.GetResult<
      Prisma.$PrescriptionPayload<ExtArgs>,
      T,
      "update",
      GlobalOmitOptions
    >,
    never,
    ExtArgs,
    GlobalOmitOptions
  >;

  /**
   * Delete zero or more Prescriptions.
   * @param {PrescriptionDeleteManyArgs} args - Arguments to filter Prescriptions to delete.
   * @example
   * // Delete a few Prescriptions
   * const { count } = await prisma.prescription.deleteMany({
   *   where: {
   *     // ... provide filter here
   *   }
   * })
   *
   */
  deleteMany<T extends PrescriptionDeleteManyArgs>(
    args?: Prisma.SelectSubset<T, PrescriptionDeleteManyArgs<ExtArgs>>,
  ): Prisma.PrismaPromise<Prisma.BatchPayload>;

  /**
   * Update zero or more Prescriptions.
   * Note, that providing `undefined` is treated as the value not being there.
   * Read more here: https://pris.ly/d/null-undefined
   * @param {PrescriptionUpdateManyArgs} args - Arguments to update one or more rows.
   * @example
   * // Update many Prescriptions
   * const prescription = await prisma.prescription.updateMany({
   *   where: {
   *     // ... provide filter here
   *   },
   *   data: {
   *     // ... provide data here
   *   }
   * })
   *
   */
  updateMany<T extends PrescriptionUpdateManyArgs>(
    args: Prisma.SelectSubset<T, PrescriptionUpdateManyArgs<ExtArgs>>,
  ): Prisma.PrismaPromise<Prisma.BatchPayload>;

  /**
   * Update zero or more Prescriptions and returns the data updated in the database.
   * @param {PrescriptionUpdateManyAndReturnArgs} args - Arguments to update many Prescriptions.
   * @example
   * // Update many Prescriptions
   * const prescription = await prisma.prescription.updateManyAndReturn({
   *   where: {
   *     // ... provide filter here
   *   },
   *   data: [
   *     // ... provide data here
   *   ]
   * })
   *
   * // Update zero or more Prescriptions and only return the `id`
   * const prescriptionWithIdOnly = await prisma.prescription.updateManyAndReturn({
   *   select: { id: true },
   *   where: {
   *     // ... provide filter here
   *   },
   *   data: [
   *     // ... provide data here
   *   ]
   * })
   * Note, that providing `undefined` is treated as the value not being there.
   * Read more here: https://pris.ly/d/null-undefined
   *
   */
  updateManyAndReturn<T extends PrescriptionUpdateManyAndReturnArgs>(
    args: Prisma.SelectSubset<T, PrescriptionUpdateManyAndReturnArgs<ExtArgs>>,
  ): Prisma.PrismaPromise<
    runtime.Types.Result.GetResult<
      Prisma.$PrescriptionPayload<ExtArgs>,
      T,
      "updateManyAndReturn",
      GlobalOmitOptions
    >
  >;

  /**
   * Create or update one Prescription.
   * @param {PrescriptionUpsertArgs} args - Arguments to update or create a Prescription.
   * @example
   * // Update or create a Prescription
   * const prescription = await prisma.prescription.upsert({
   *   create: {
   *     // ... data to create a Prescription
   *   },
   *   update: {
   *     // ... in case it already exists, update
   *   },
   *   where: {
   *     // ... the filter for the Prescription we want to update
   *   }
   * })
   */
  upsert<T extends PrescriptionUpsertArgs>(
    args: Prisma.SelectSubset<T, PrescriptionUpsertArgs<ExtArgs>>,
  ): Prisma.Prisma__PrescriptionClient<
    runtime.Types.Result.GetResult<
      Prisma.$PrescriptionPayload<ExtArgs>,
      T,
      "upsert",
      GlobalOmitOptions
    >,
    never,
    ExtArgs,
    GlobalOmitOptions
  >;

  /**
   * Count the number of Prescriptions.
   * Note, that providing `undefined` is treated as the value not being there.
   * Read more here: https://pris.ly/d/null-undefined
   * @param {PrescriptionCountArgs} args - Arguments to filter Prescriptions to count.
   * @example
   * // Count the number of Prescriptions
   * const count = await prisma.prescription.count({
   *   where: {
   *     // ... the filter for the Prescriptions we want to count
   *   }
   * })
   **/
  count<T extends PrescriptionCountArgs>(
    args?: Prisma.Subset<T, PrescriptionCountArgs>,
  ): Prisma.PrismaPromise<
    T extends runtime.Types.Utils.Record<"select", any>
      ? T["select"] extends true
        ? number
        : Prisma.GetScalarType<
            T["select"],
            PrescriptionCountAggregateOutputType
          >
      : number
  >;

  /**
   * Allows you to perform aggregations operations on a Prescription.
   * Note, that providing `undefined` is treated as the value not being there.
   * Read more here: https://pris.ly/d/null-undefined
   * @param {PrescriptionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
   * @example
   * // Ordered by age ascending
   * // Where email contains prisma.io
   * // Limited to the 10 users
   * const aggregations = await prisma.user.aggregate({
   *   _avg: {
   *     age: true,
   *   },
   *   where: {
   *     email: {
   *       contains: "prisma.io",
   *     },
   *   },
   *   orderBy: {
   *     age: "asc",
   *   },
   *   take: 10,
   * })
   **/
  aggregate<T extends PrescriptionAggregateArgs>(
    args: Prisma.Subset<T, PrescriptionAggregateArgs>,
  ): Prisma.PrismaPromise<GetPrescriptionAggregateType<T>>;

  /**
   * Group by Prescription.
   * Note, that providing `undefined` is treated as the value not being there.
   * Read more here: https://pris.ly/d/null-undefined
   * @param {PrescriptionGroupByArgs} args - Group by arguments.
   * @example
   * // Group by city, order by createdAt, get count
   * const result = await prisma.user.groupBy({
   *   by: ['city', 'createdAt'],
   *   orderBy: {
   *     createdAt: true
   *   },
   *   _count: {
   *     _all: true
   *   },
   * })
   *
   **/
  groupBy<
    T extends PrescriptionGroupByArgs,
    HasSelectOrTake extends Prisma.Or<
      Prisma.Extends<"skip", Prisma.Keys<T>>,
      Prisma.Extends<"take", Prisma.Keys<T>>
    >,
    OrderByArg extends Prisma.True extends HasSelectOrTake
      ? { orderBy: PrescriptionGroupByArgs["orderBy"] }
      : { orderBy?: PrescriptionGroupByArgs["orderBy"] },
    OrderFields extends Prisma.ExcludeUnderscoreKeys<
      Prisma.Keys<Prisma.MaybeTupleToUnion<T["orderBy"]>>
    >,
    ByFields extends Prisma.MaybeTupleToUnion<T["by"]>,
    ByValid extends Prisma.Has<ByFields, OrderFields>,
    HavingFields extends Prisma.GetHavingFields<T["having"]>,
    HavingValid extends Prisma.Has<ByFields, HavingFields>,
    ByEmpty extends T["by"] extends never[] ? Prisma.True : Prisma.False,
    InputErrors extends ByEmpty extends Prisma.True
      ? `Error: "by" must not be empty.`
      : HavingValid extends Prisma.False
        ? {
            [P in HavingFields]: P extends ByFields
              ? never
              : P extends string
                ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
                : [
                    Error,
                    "Field ",
                    P,
                    ` in "having" needs to be provided in "by"`,
                  ];
          }[HavingFields]
        : "take" extends Prisma.Keys<T>
          ? "orderBy" extends Prisma.Keys<T>
            ? ByValid extends Prisma.True
              ? {}
              : {
                  [P in OrderFields]: P extends ByFields
                    ? never
                    : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                }[OrderFields]
            : 'Error: If you provide "take", you also need to provide "orderBy"'
          : "skip" extends Prisma.Keys<T>
            ? "orderBy" extends Prisma.Keys<T>
              ? ByValid extends Prisma.True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                  }[OrderFields]
              : 'Error: If you provide "skip", you also need to provide "orderBy"'
            : ByValid extends Prisma.True
              ? {}
              : {
                  [P in OrderFields]: P extends ByFields
                    ? never
                    : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                }[OrderFields],
  >(
    args: Prisma.SubsetIntersection<T, PrescriptionGroupByArgs, OrderByArg> &
      InputErrors,
  ): {} extends InputErrors
    ? GetPrescriptionGroupByPayload<T>
    : Prisma.PrismaPromise<InputErrors>;
  /**
   * Fields of the Prescription model
   */
  readonly fields: PrescriptionFieldRefs;
}

/**
 * The delegate class that acts as a "Promise-like" for Prescription.
 * Why is this prefixed with `Prisma__`?
 * Because we want to prevent naming conflicts as mentioned in
 * https://github.com/prisma/prisma-client-js/issues/707
 */
export interface Prisma__PrescriptionClient<
  T,
  Null = never,
  ExtArgs extends
    runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs,
  GlobalOmitOptions = {},
> extends Prisma.PrismaPromise<T> {
  readonly [Symbol.toStringTag]: "PrismaPromise";
  encounter<T extends Prisma.DiagnosisDefaultArgs<ExtArgs> = {}>(
    args?: Prisma.Subset<T, Prisma.DiagnosisDefaultArgs<ExtArgs>>,
  ): Prisma.Prisma__DiagnosisClient<
    | runtime.Types.Result.GetResult<
        Prisma.$DiagnosisPayload<ExtArgs>,
        T,
        "findUniqueOrThrow",
        GlobalOmitOptions
      >
    | Null,
    Null,
    ExtArgs,
    GlobalOmitOptions
  >;
  medicalRecord<T extends Prisma.MedicalRecordsDefaultArgs<ExtArgs> = {}>(
    args?: Prisma.Subset<T, Prisma.MedicalRecordsDefaultArgs<ExtArgs>>,
  ): Prisma.Prisma__MedicalRecordsClient<
    | runtime.Types.Result.GetResult<
        Prisma.$MedicalRecordsPayload<ExtArgs>,
        T,
        "findUniqueOrThrow",
        GlobalOmitOptions
      >
    | Null,
    Null,
    ExtArgs,
    GlobalOmitOptions
  >;
  doctor<T extends Prisma.Prescription$doctorArgs<ExtArgs> = {}>(
    args?: Prisma.Subset<T, Prisma.Prescription$doctorArgs<ExtArgs>>,
  ): Prisma.Prisma__DoctorClient<
    runtime.Types.Result.GetResult<
      Prisma.$DoctorPayload<ExtArgs>,
      T,
      "findUniqueOrThrow",
      GlobalOmitOptions
    > | null,
    null,
    ExtArgs,
    GlobalOmitOptions
  >;
  patient<T extends Prisma.PatientDefaultArgs<ExtArgs> = {}>(
    args?: Prisma.Subset<T, Prisma.PatientDefaultArgs<ExtArgs>>,
  ): Prisma.Prisma__PatientClient<
    | runtime.Types.Result.GetResult<
        Prisma.$PatientPayload<ExtArgs>,
        T,
        "findUniqueOrThrow",
        GlobalOmitOptions
      >
    | Null,
    Null,
    ExtArgs,
    GlobalOmitOptions
  >;
  clinic<T extends Prisma.Prescription$clinicArgs<ExtArgs> = {}>(
    args?: Prisma.Subset<T, Prisma.Prescription$clinicArgs<ExtArgs>>,
  ): Prisma.Prisma__ClinicClient<
    runtime.Types.Result.GetResult<
      Prisma.$ClinicPayload<ExtArgs>,
      T,
      "findUniqueOrThrow",
      GlobalOmitOptions
    > | null,
    null,
    ExtArgs,
    GlobalOmitOptions
  >;
  prescribedItems<
    T extends Prisma.Prescription$prescribedItemsArgs<ExtArgs> = {},
  >(
    args?: Prisma.Subset<T, Prisma.Prescription$prescribedItemsArgs<ExtArgs>>,
  ): Prisma.PrismaPromise<
    | runtime.Types.Result.GetResult<
        Prisma.$PrescribedItemPayload<ExtArgs>,
        T,
        "findMany",
        GlobalOmitOptions
      >
    | Null
  >;
  /**
   * Attaches callbacks for the resolution and/or rejection of the Promise.
   * @param onfulfilled The callback to execute when the Promise is resolved.
   * @param onrejected The callback to execute when the Promise is rejected.
   * @returns A Promise for the completion of which ever callback is executed.
   */
  then<TResult1 = T, TResult2 = never>(
    onfulfilled?:
      | ((value: T) => TResult1 | PromiseLike<TResult1>)
      | undefined
      | null,
    onrejected?:
      | ((reason: any) => TResult2 | PromiseLike<TResult2>)
      | undefined
      | null,
  ): runtime.Types.Utils.JsPromise<TResult1 | TResult2>;
  /**
   * Attaches a callback for only the rejection of the Promise.
   * @param onrejected The callback to execute when the Promise is rejected.
   * @returns A Promise for the completion of the callback.
   */
  catch<TResult = never>(
    onrejected?:
      | ((reason: any) => TResult | PromiseLike<TResult>)
      | undefined
      | null,
  ): runtime.Types.Utils.JsPromise<T | TResult>;
  /**
   * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
   * resolved value cannot be modified from the callback.
   * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
   * @returns A Promise for the completion of the callback.
   */
  finally(
    onfinally?: (() => void) | undefined | null,
  ): runtime.Types.Utils.JsPromise<T>;
}

/**
 * Fields of the Prescription model
 */
export interface PrescriptionFieldRefs {
  readonly id: Prisma.FieldRef<"Prescription", "String">;
  readonly medicalRecordId: Prisma.FieldRef<"Prescription", "String">;
  readonly doctorId: Prisma.FieldRef<"Prescription", "String">;
  readonly patientId: Prisma.FieldRef<"Prescription", "String">;
  readonly encounterId: Prisma.FieldRef<"Prescription", "String">;
  readonly medicationName: Prisma.FieldRef<"Prescription", "String">;
  readonly instructions: Prisma.FieldRef<"Prescription", "String">;
  readonly issuedDate: Prisma.FieldRef<"Prescription", "DateTime">;
  readonly endDate: Prisma.FieldRef<"Prescription", "DateTime">;
  readonly status: Prisma.FieldRef<"Prescription", "String">;
  readonly clinicId: Prisma.FieldRef<"Prescription", "String">;
  readonly createdAt: Prisma.FieldRef<"Prescription", "DateTime">;
  readonly updatedAt: Prisma.FieldRef<"Prescription", "DateTime">;
}

// Custom InputTypes
/**
 * Prescription findUnique
 */
export type PrescriptionFindUniqueArgs<
  ExtArgs extends
    runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs,
> = {
  /**
   * Select specific fields to fetch from the Prescription
   */
  select?: Prisma.PrescriptionSelect<ExtArgs> | null;
  /**
   * Omit specific fields from the Prescription
   */
  omit?: Prisma.PrescriptionOmit<ExtArgs> | null;
  /**
   * Choose, which related nodes to fetch as well
   */
  include?: Prisma.PrescriptionInclude<ExtArgs> | null;
  /**
   * Filter, which Prescription to fetch.
   */
  where: Prisma.PrescriptionWhereUniqueInput;
  relationLoadStrategy?: Prisma.RelationLoadStrategy;
};

/**
 * Prescription findUniqueOrThrow
 */
export type PrescriptionFindUniqueOrThrowArgs<
  ExtArgs extends
    runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs,
> = {
  /**
   * Select specific fields to fetch from the Prescription
   */
  select?: Prisma.PrescriptionSelect<ExtArgs> | null;
  /**
   * Omit specific fields from the Prescription
   */
  omit?: Prisma.PrescriptionOmit<ExtArgs> | null;
  /**
   * Choose, which related nodes to fetch as well
   */
  include?: Prisma.PrescriptionInclude<ExtArgs> | null;
  /**
   * Filter, which Prescription to fetch.
   */
  where: Prisma.PrescriptionWhereUniqueInput;
  relationLoadStrategy?: Prisma.RelationLoadStrategy;
};

/**
 * Prescription findFirst
 */
export type PrescriptionFindFirstArgs<
  ExtArgs extends
    runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs,
> = {
  /**
   * Select specific fields to fetch from the Prescription
   */
  select?: Prisma.PrescriptionSelect<ExtArgs> | null;
  /**
   * Omit specific fields from the Prescription
   */
  omit?: Prisma.PrescriptionOmit<ExtArgs> | null;
  /**
   * Choose, which related nodes to fetch as well
   */
  include?: Prisma.PrescriptionInclude<ExtArgs> | null;
  /**
   * Filter, which Prescription to fetch.
   */
  where?: Prisma.PrescriptionWhereInput;
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
   *
   * Determine the order of Prescriptions to fetch.
   */
  orderBy?:
    | Prisma.PrescriptionOrderByWithRelationInput
    | Prisma.PrescriptionOrderByWithRelationInput[];
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
   *
   * Sets the position for searching for Prescriptions.
   */
  cursor?: Prisma.PrescriptionWhereUniqueInput;
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
   *
   * Take `Â±n` Prescriptions from the position of the cursor.
   */
  take?: number;
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
   *
   * Skip the first `n` Prescriptions.
   */
  skip?: number;
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
   *
   * Filter by unique combinations of Prescriptions.
   */
  distinct?:
    | Prisma.PrescriptionScalarFieldEnum
    | Prisma.PrescriptionScalarFieldEnum[];
  relationLoadStrategy?: Prisma.RelationLoadStrategy;
};

/**
 * Prescription findFirstOrThrow
 */
export type PrescriptionFindFirstOrThrowArgs<
  ExtArgs extends
    runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs,
> = {
  /**
   * Select specific fields to fetch from the Prescription
   */
  select?: Prisma.PrescriptionSelect<ExtArgs> | null;
  /**
   * Omit specific fields from the Prescription
   */
  omit?: Prisma.PrescriptionOmit<ExtArgs> | null;
  /**
   * Choose, which related nodes to fetch as well
   */
  include?: Prisma.PrescriptionInclude<ExtArgs> | null;
  /**
   * Filter, which Prescription to fetch.
   */
  where?: Prisma.PrescriptionWhereInput;
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
   *
   * Determine the order of Prescriptions to fetch.
   */
  orderBy?:
    | Prisma.PrescriptionOrderByWithRelationInput
    | Prisma.PrescriptionOrderByWithRelationInput[];
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
   *
   * Sets the position for searching for Prescriptions.
   */
  cursor?: Prisma.PrescriptionWhereUniqueInput;
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
   *
   * Take `Â±n` Prescriptions from the position of the cursor.
   */
  take?: number;
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
   *
   * Skip the first `n` Prescriptions.
   */
  skip?: number;
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
   *
   * Filter by unique combinations of Prescriptions.
   */
  distinct?:
    | Prisma.PrescriptionScalarFieldEnum
    | Prisma.PrescriptionScalarFieldEnum[];
  relationLoadStrategy?: Prisma.RelationLoadStrategy;
};

/**
 * Prescription findMany
 */
export type PrescriptionFindManyArgs<
  ExtArgs extends
    runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs,
> = {
  /**
   * Select specific fields to fetch from the Prescription
   */
  select?: Prisma.PrescriptionSelect<ExtArgs> | null;
  /**
   * Omit specific fields from the Prescription
   */
  omit?: Prisma.PrescriptionOmit<ExtArgs> | null;
  /**
   * Choose, which related nodes to fetch as well
   */
  include?: Prisma.PrescriptionInclude<ExtArgs> | null;
  /**
   * Filter, which Prescriptions to fetch.
   */
  where?: Prisma.PrescriptionWhereInput;
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
   *
   * Determine the order of Prescriptions to fetch.
   */
  orderBy?:
    | Prisma.PrescriptionOrderByWithRelationInput
    | Prisma.PrescriptionOrderByWithRelationInput[];
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
   *
   * Sets the position for listing Prescriptions.
   */
  cursor?: Prisma.PrescriptionWhereUniqueInput;
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
   *
   * Take `Â±n` Prescriptions from the position of the cursor.
   */
  take?: number;
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
   *
   * Skip the first `n` Prescriptions.
   */
  skip?: number;
  distinct?:
    | Prisma.PrescriptionScalarFieldEnum
    | Prisma.PrescriptionScalarFieldEnum[];
  relationLoadStrategy?: Prisma.RelationLoadStrategy;
};

/**
 * Prescription create
 */
export type PrescriptionCreateArgs<
  ExtArgs extends
    runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs,
> = {
  /**
   * Select specific fields to fetch from the Prescription
   */
  select?: Prisma.PrescriptionSelect<ExtArgs> | null;
  /**
   * Omit specific fields from the Prescription
   */
  omit?: Prisma.PrescriptionOmit<ExtArgs> | null;
  /**
   * Choose, which related nodes to fetch as well
   */
  include?: Prisma.PrescriptionInclude<ExtArgs> | null;
  /**
   * The data needed to create a Prescription.
   */
  data: Prisma.XOR<
    Prisma.PrescriptionCreateInput,
    Prisma.PrescriptionUncheckedCreateInput
  >;
  relationLoadStrategy?: Prisma.RelationLoadStrategy;
};

/**
 * Prescription createMany
 */
export type PrescriptionCreateManyArgs<
  ExtArgs extends
    runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs,
> = {
  /**
   * The data used to create many Prescriptions.
   */
  data:
    | Prisma.PrescriptionCreateManyInput
    | Prisma.PrescriptionCreateManyInput[];
  skipDuplicates?: boolean;
};

/**
 * Prescription createManyAndReturn
 */
export type PrescriptionCreateManyAndReturnArgs<
  ExtArgs extends
    runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs,
> = {
  /**
   * Select specific fields to fetch from the Prescription
   */
  select?: Prisma.PrescriptionSelectCreateManyAndReturn<ExtArgs> | null;
  /**
   * Omit specific fields from the Prescription
   */
  omit?: Prisma.PrescriptionOmit<ExtArgs> | null;
  /**
   * The data used to create many Prescriptions.
   */
  data:
    | Prisma.PrescriptionCreateManyInput
    | Prisma.PrescriptionCreateManyInput[];
  skipDuplicates?: boolean;
  /**
   * Choose, which related nodes to fetch as well
   */
  include?: Prisma.PrescriptionIncludeCreateManyAndReturn<ExtArgs> | null;
};

/**
 * Prescription update
 */
export type PrescriptionUpdateArgs<
  ExtArgs extends
    runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs,
> = {
  /**
   * Select specific fields to fetch from the Prescription
   */
  select?: Prisma.PrescriptionSelect<ExtArgs> | null;
  /**
   * Omit specific fields from the Prescription
   */
  omit?: Prisma.PrescriptionOmit<ExtArgs> | null;
  /**
   * Choose, which related nodes to fetch as well
   */
  include?: Prisma.PrescriptionInclude<ExtArgs> | null;
  /**
   * The data needed to update a Prescription.
   */
  data: Prisma.XOR<
    Prisma.PrescriptionUpdateInput,
    Prisma.PrescriptionUncheckedUpdateInput
  >;
  /**
   * Choose, which Prescription to update.
   */
  where: Prisma.PrescriptionWhereUniqueInput;
  relationLoadStrategy?: Prisma.RelationLoadStrategy;
};

/**
 * Prescription updateMany
 */
export type PrescriptionUpdateManyArgs<
  ExtArgs extends
    runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs,
> = {
  /**
   * The data used to update Prescriptions.
   */
  data: Prisma.XOR<
    Prisma.PrescriptionUpdateManyMutationInput,
    Prisma.PrescriptionUncheckedUpdateManyInput
  >;
  /**
   * Filter which Prescriptions to update
   */
  where?: Prisma.PrescriptionWhereInput;
  /**
   * Limit how many Prescriptions to update.
   */
  limit?: number;
};

/**
 * Prescription updateManyAndReturn
 */
export type PrescriptionUpdateManyAndReturnArgs<
  ExtArgs extends
    runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs,
> = {
  /**
   * Select specific fields to fetch from the Prescription
   */
  select?: Prisma.PrescriptionSelectUpdateManyAndReturn<ExtArgs> | null;
  /**
   * Omit specific fields from the Prescription
   */
  omit?: Prisma.PrescriptionOmit<ExtArgs> | null;
  /**
   * The data used to update Prescriptions.
   */
  data: Prisma.XOR<
    Prisma.PrescriptionUpdateManyMutationInput,
    Prisma.PrescriptionUncheckedUpdateManyInput
  >;
  /**
   * Filter which Prescriptions to update
   */
  where?: Prisma.PrescriptionWhereInput;
  /**
   * Limit how many Prescriptions to update.
   */
  limit?: number;
  /**
   * Choose, which related nodes to fetch as well
   */
  include?: Prisma.PrescriptionIncludeUpdateManyAndReturn<ExtArgs> | null;
};

/**
 * Prescription upsert
 */
export type PrescriptionUpsertArgs<
  ExtArgs extends
    runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs,
> = {
  /**
   * Select specific fields to fetch from the Prescription
   */
  select?: Prisma.PrescriptionSelect<ExtArgs> | null;
  /**
   * Omit specific fields from the Prescription
   */
  omit?: Prisma.PrescriptionOmit<ExtArgs> | null;
  /**
   * Choose, which related nodes to fetch as well
   */
  include?: Prisma.PrescriptionInclude<ExtArgs> | null;
  /**
   * The filter to search for the Prescription to update in case it exists.
   */
  where: Prisma.PrescriptionWhereUniqueInput;
  /**
   * In case the Prescription found by the `where` argument doesn't exist, create a new Prescription with this data.
   */
  create: Prisma.XOR<
    Prisma.PrescriptionCreateInput,
    Prisma.PrescriptionUncheckedCreateInput
  >;
  /**
   * In case the Prescription was found with the provided `where` argument, update it with this data.
   */
  update: Prisma.XOR<
    Prisma.PrescriptionUpdateInput,
    Prisma.PrescriptionUncheckedUpdateInput
  >;
  relationLoadStrategy?: Prisma.RelationLoadStrategy;
};

/**
 * Prescription delete
 */
export type PrescriptionDeleteArgs<
  ExtArgs extends
    runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs,
> = {
  /**
   * Select specific fields to fetch from the Prescription
   */
  select?: Prisma.PrescriptionSelect<ExtArgs> | null;
  /**
   * Omit specific fields from the Prescription
   */
  omit?: Prisma.PrescriptionOmit<ExtArgs> | null;
  /**
   * Choose, which related nodes to fetch as well
   */
  include?: Prisma.PrescriptionInclude<ExtArgs> | null;
  /**
   * Filter which Prescription to delete.
   */
  where: Prisma.PrescriptionWhereUniqueInput;
  relationLoadStrategy?: Prisma.RelationLoadStrategy;
};

/**
 * Prescription deleteMany
 */
export type PrescriptionDeleteManyArgs<
  ExtArgs extends
    runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs,
> = {
  /**
   * Filter which Prescriptions to delete
   */
  where?: Prisma.PrescriptionWhereInput;
  /**
   * Limit how many Prescriptions to delete.
   */
  limit?: number;
};

/**
 * Prescription.doctor
 */
export type Prescription$doctorArgs<
  ExtArgs extends
    runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs,
> = {
  /**
   * Select specific fields to fetch from the Doctor
   */
  select?: Prisma.DoctorSelect<ExtArgs> | null;
  /**
   * Omit specific fields from the Doctor
   */
  omit?: Prisma.DoctorOmit<ExtArgs> | null;
  /**
   * Choose, which related nodes to fetch as well
   */
  include?: Prisma.DoctorInclude<ExtArgs> | null;
  where?: Prisma.DoctorWhereInput;
};

/**
 * Prescription.clinic
 */
export type Prescription$clinicArgs<
  ExtArgs extends
    runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs,
> = {
  /**
   * Select specific fields to fetch from the Clinic
   */
  select?: Prisma.ClinicSelect<ExtArgs> | null;
  /**
   * Omit specific fields from the Clinic
   */
  omit?: Prisma.ClinicOmit<ExtArgs> | null;
  /**
   * Choose, which related nodes to fetch as well
   */
  include?: Prisma.ClinicInclude<ExtArgs> | null;
  where?: Prisma.ClinicWhereInput;
};

/**
 * Prescription.prescribedItems
 */
export type Prescription$prescribedItemsArgs<
  ExtArgs extends
    runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs,
> = {
  /**
   * Select specific fields to fetch from the PrescribedItem
   */
  select?: Prisma.PrescribedItemSelect<ExtArgs> | null;
  /**
   * Omit specific fields from the PrescribedItem
   */
  omit?: Prisma.PrescribedItemOmit<ExtArgs> | null;
  /**
   * Choose, which related nodes to fetch as well
   */
  include?: Prisma.PrescribedItemInclude<ExtArgs> | null;
  where?: Prisma.PrescribedItemWhereInput;
  orderBy?:
    | Prisma.PrescribedItemOrderByWithRelationInput
    | Prisma.PrescribedItemOrderByWithRelationInput[];
  cursor?: Prisma.PrescribedItemWhereUniqueInput;
  take?: number;
  skip?: number;
  distinct?:
    | Prisma.PrescribedItemScalarFieldEnum
    | Prisma.PrescribedItemScalarFieldEnum[];
};

/**
 * Prescription without action
 */
export type PrescriptionDefaultArgs<
  ExtArgs extends
    runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs,
> = {
  /**
   * Select specific fields to fetch from the Prescription
   */
  select?: Prisma.PrescriptionSelect<ExtArgs> | null;
  /**
   * Omit specific fields from the Prescription
   */
  omit?: Prisma.PrescriptionOmit<ExtArgs> | null;
  /**
   * Choose, which related nodes to fetch as well
   */
  include?: Prisma.PrescriptionInclude<ExtArgs> | null;
};
