/* !!! This is code generated by Prisma. Do not edit directly. !!! */
/* eslint-disable */
// biome-ignore-all lint: generated file
// @ts-nocheck
/*
 * WARNING: This is an internal file that is subject to change!
 *
 * ðŸ›‘ Under no circumstances should you import this file directly! ðŸ›‘
 *
 * All exports from this file are wrapped under a `Prisma` namespace object in the client.ts file.
 * While this enables partial backward compatibility, it is not part of the stable public API.
 *
 * If you are looking for your Models, Enums, and Input Types, please import them from the respective
 * model files in the `model` directory!
 */

import * as runtime from "@prisma/client/runtime/client";
import type * as Prisma from "../models";
import { type PrismaClient } from "./class";

export type * from "../models";

export type DMMF = typeof runtime.DMMF;

export type PrismaPromise<T> = runtime.Types.Public.PrismaPromise<T>;

/**
 * Prisma Errors
 */

export const PrismaClientKnownRequestError =
  runtime.PrismaClientKnownRequestError;
export type PrismaClientKnownRequestError =
  runtime.PrismaClientKnownRequestError;

export const PrismaClientUnknownRequestError =
  runtime.PrismaClientUnknownRequestError;
export type PrismaClientUnknownRequestError =
  runtime.PrismaClientUnknownRequestError;

export const PrismaClientRustPanicError = runtime.PrismaClientRustPanicError;
export type PrismaClientRustPanicError = runtime.PrismaClientRustPanicError;

export const PrismaClientInitializationError =
  runtime.PrismaClientInitializationError;
export type PrismaClientInitializationError =
  runtime.PrismaClientInitializationError;

export const PrismaClientValidationError = runtime.PrismaClientValidationError;
export type PrismaClientValidationError = runtime.PrismaClientValidationError;

/**
 * Re-export of sql-template-tag
 */
export const sql = runtime.sqltag;
export const empty = runtime.empty;
export const join = runtime.join;
export const raw = runtime.raw;
export const Sql = runtime.Sql;
export type Sql = runtime.Sql;

/**
 * Decimal.js
 */
export const Decimal = runtime.Decimal;
export type Decimal = runtime.Decimal;

export type DecimalJsLike = runtime.DecimalJsLike;

/**
 * Extensions
 */
export type Extension = runtime.Types.Extensions.UserArgs;
export const getExtensionContext = runtime.Extensions.getExtensionContext;
export type Args<T, F extends runtime.Operation> = runtime.Types.Public.Args<
  T,
  F
>;
export type Payload<
  T,
  F extends runtime.Operation = never,
> = runtime.Types.Public.Payload<T, F>;
export type Result<
  T,
  A,
  F extends runtime.Operation,
> = runtime.Types.Public.Result<T, A, F>;
export type Exact<A, W> = runtime.Types.Public.Exact<A, W>;

export type PrismaVersion = {
  client: string;
  engine: string;
};

/**
 * Prisma Client JS version: 7.4.1
 * Query Engine version: 55ae170b1ced7fc6ed07a15f110549408c501bb3
 */
export const prismaVersion: PrismaVersion = {
  client: "7.4.1",
  engine: "55ae170b1ced7fc6ed07a15f110549408c501bb3",
};

/**
 * Utility Types
 */

export type Bytes = runtime.Bytes;
export type JsonObject = runtime.JsonObject;
export type JsonArray = runtime.JsonArray;
export type JsonValue = runtime.JsonValue;
export type InputJsonObject = runtime.InputJsonObject;
export type InputJsonArray = runtime.InputJsonArray;
export type InputJsonValue = runtime.InputJsonValue;

export const NullTypes = {
  DbNull: runtime.NullTypes.DbNull as new (
    secret: never,
  ) => typeof runtime.DbNull,
  JsonNull: runtime.NullTypes.JsonNull as new (
    secret: never,
  ) => typeof runtime.JsonNull,
  AnyNull: runtime.NullTypes.AnyNull as new (
    secret: never,
  ) => typeof runtime.AnyNull,
};
/**
 * Helper for filtering JSON entries that have `null` on the database (empty on the db)
 *
 * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
 */
export const DbNull = runtime.DbNull;

/**
 * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
 *
 * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
 */
export const JsonNull = runtime.JsonNull;

/**
 * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
 *
 * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
 */
export const AnyNull = runtime.AnyNull;

type SelectAndInclude = {
  select: any;
  include: any;
};

type SelectAndOmit = {
  select: any;
  omit: any;
};

/**
 * From T, pick a set of properties whose keys are in the union K
 */
type Prisma__Pick<T, K extends keyof T> = {
  [P in K]: T[P];
};

export type Enumerable<T> = T | Array<T>;

/**
 * Subset
 * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
 */
export type Subset<T, U> = {
  [key in keyof T]: key extends keyof U ? T[key] : never;
};

/**
 * SelectSubset
 * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
 * Additionally, it validates, if both select and include are present. If the case, it errors.
 */
export type SelectSubset<T, U> = {
  [key in keyof T]: key extends keyof U ? T[key] : never;
} & (T extends SelectAndInclude
  ? "Please either choose `select` or `include`."
  : T extends SelectAndOmit
    ? "Please either choose `select` or `omit`."
    : {});

/**
 * Subset + Intersection
 * @desc From `T` pick properties that exist in `U` and intersect `K`
 */
export type SubsetIntersection<T, U, K> = {
  [key in keyof T]: key extends keyof U ? T[key] : never;
} & K;

type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

/**
 * XOR is needed to have a real mutually exclusive union type
 * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
 */
export type XOR<T, U> = T extends object
  ? U extends object
    ? (Without<T, U> & U) | (Without<U, T> & T)
    : U
  : T;

/**
 * Is T a Record?
 */
type IsObject<T extends any> =
  T extends Array<any>
    ? False
    : T extends Date
      ? False
      : T extends Uint8Array
        ? False
        : T extends BigInt
          ? False
          : T extends object
            ? True
            : False;

/**
 * If it's T[], return T
 */
export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T;

/**
 * From ts-toolbelt
 */

type __Either<O extends object, K extends Key> = Omit<O, K> &
  {
    // Merge all but K
    [P in K]: Prisma__Pick<O, P & keyof O>; // With K possibilities
  }[K];

type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>;

type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>;

type _Either<O extends object, K extends Key, strict extends Boolean> = {
  1: EitherStrict<O, K>;
  0: EitherLoose<O, K>;
}[strict];

export type Either<
  O extends object,
  K extends Key,
  strict extends Boolean = 1,
> = O extends unknown ? _Either<O, K, strict> : never;

export type Union = any;

export type PatchUndefined<O extends object, O1 extends object> = {
  [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K];
} & {};

/** Helper Types for "Merge" **/
export type IntersectOf<U extends Union> = (
  U extends unknown
    ? (k: U) => void
    : never
) extends (k: infer I) => void
  ? I
  : never;

export type Overwrite<O extends object, O1 extends object> = {
  [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
} & {};

type _Merge<U extends object> = IntersectOf<
  Overwrite<
    U,
    {
      [K in keyof U]-?: At<U, K>;
    }
  >
>;

type Key = string | number | symbol;
type AtStrict<O extends object, K extends Key> = O[K & keyof O];
type AtLoose<O extends object, K extends Key> = O extends unknown
  ? AtStrict<O, K>
  : never;
export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
  1: AtStrict<O, K>;
  0: AtLoose<O, K>;
}[strict];

export type ComputeRaw<A extends any> = A extends Function
  ? A
  : {
      [K in keyof A]: A[K];
    } & {};

export type OptionalFlat<O> = {
  [K in keyof O]?: O[K];
} & {};

type _Record<K extends keyof any, T> = {
  [P in K]: T;
};

// cause typescript not to expand types and preserve names
type NoExpand<T> = T extends unknown ? T : never;

// this type assumes the passed object is entirely optional
export type AtLeast<O extends object, K extends string> = NoExpand<
  O extends unknown
    ?
        | (K extends keyof O ? { [P in K]: O[P] } & O : O)
        | ({ [P in keyof O as P extends K ? P : never]-?: O[P] } & O)
    : never
>;

type _Strict<U, _U = U> = U extends unknown
  ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>>
  : never;

export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
/** End Helper Types for "Merge" **/

export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

export type Boolean = True | False;

export type True = 1;

export type False = 0;

export type Not<B extends Boolean> = {
  0: 1;
  1: 0;
}[B];

export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
  ? 0 // anything `never` is false
  : A1 extends A2
    ? 1
    : 0;

export type Has<U extends Union, U1 extends Union> = Not<
  Extends<Exclude<U1, U>, U1>
>;

export type Or<B1 extends Boolean, B2 extends Boolean> = {
  0: {
    0: 0;
    1: 1;
  };
  1: {
    0: 1;
    1: 1;
  };
}[B1][B2];

export type Keys<U extends Union> = U extends unknown ? keyof U : never;

export type GetScalarType<T, O> = O extends object
  ? {
      [P in keyof T]: P extends keyof O ? O[P] : never;
    }
  : never;

type FieldPaths<T, U = Omit<T, "_avg" | "_sum" | "_count" | "_min" | "_max">> =
  IsObject<T> extends True ? U : T;

export type GetHavingFields<T> = {
  [K in keyof T]: Or<
    Or<Extends<"OR", K>, Extends<"AND", K>>,
    Extends<"NOT", K>
  > extends True
    ? // infer is only needed to not hit TS limit
      // based on the brilliant idea of Pierre-Antoine Mills
      // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
      T[K] extends infer TK
      ? GetHavingFields<
          UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never
        >
      : never
    : {} extends FieldPaths<T[K]>
      ? never
      : K;
}[keyof T];

/**
 * Convert tuple to union
 */
type _TupleToUnion<T> = T extends (infer E)[] ? E : never;
type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>;
export type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T;

/**
 * Like `Pick`, but additionally can also accept an array of keys
 */
export type PickEnumerable<
  T,
  K extends Enumerable<keyof T> | keyof T,
> = Prisma__Pick<T, MaybeTupleToUnion<K>>;

/**
 * Exclude all keys with underscores
 */
export type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}`
  ? never
  : T;

export type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>;

type FieldRefInputType<Model, FieldType> = Model extends never
  ? never
  : FieldRef<Model, FieldType>;

export const ModelName = {
  TwoFactor: "TwoFactor",
  User: "User",
  Session: "Session",
  Account: "Account",
  Verification: "Verification",
  ClinicMember: "ClinicMember",
  Role: "Role",
  clinicInvitation: "clinicInvitation",
  Notification: "Notification",
  TwoFactorAuth: "TwoFactorAuth",
  Passkey: "Passkey",
  SystemSettings: "SystemSettings",
  APIKey: "APIKey",
  Settings: "Settings",
  AuditLog: "AuditLog",
  Todo: "Todo",
  Feature: "Feature",
  File: "File",
  Folder: "Folder",
  Clinic: "Clinic",
  Doctor: "Doctor",
  WorkingDays: "WorkingDays",
  Staff: "Staff",
  Payment: "Payment",
  Reminder: "Reminder",
  PatientBill: "PatientBill",
  Service: "Service",
  ClinicSetting: "ClinicSetting",
  WHOGrowthStandard: "WHOGrowthStandard",
  Rating: "Rating",
  Prescription: "Prescription",
  Drug: "Drug",
  DoseGuideline: "DoseGuideline",
  PrescribedItem: "PrescribedItem",
  Guardian: "Guardian",
  Patient: "Patient",
  Appointment: "Appointment",
  MedicalRecords: "MedicalRecords",
  MedicalRecordAccess: "MedicalRecordAccess",
  Diagnosis: "Diagnosis",
  VitalSigns: "VitalSigns",
  GrowthRecord: "GrowthRecord",
  Immunization: "Immunization",
  ConfigStore: "ConfigStore",
  UserQuota: "UserQuota",
  LabTest: "LabTest",
  FeedingLog: "FeedingLog",
  DevelopmentalMilestone: "DevelopmentalMilestone",
  DevelopmentalCheck: "DevelopmentalCheck",
  VaccineSchedule: "VaccineSchedule",
  Expense: "Expense",
  ExpenseCategory: "ExpenseCategory",
  ExpenseSubCategory: "ExpenseSubCategory",
  FileStorage: "FileStorage",
  TrainingFile: "TrainingFile",
  KnowledgeBase: "KnowledgeBase",
  TrainingWebsite: "TrainingWebsite",
  Agent: "Agent",
  ClinicDashboardMV: "ClinicDashboardMV",
  PatientOverviewMV: "PatientOverviewMV",
  DoctorPerformanceMV: "DoctorPerformanceMV",
  FinancialOverviewMV: "FinancialOverviewMV",
  AppointmentScheduleMV: "AppointmentScheduleMV",
  PatientGrowthChartMV: "PatientGrowthChartMV",
  ImmunizationScheduleMV: "ImmunizationScheduleMV",
  MedicalRecordsMV: "MedicalRecordsMV",
  NotificationsMV: "NotificationsMV",
  ExpenseAnalysisMV: "ExpenseAnalysisMV",
} as const;

export type ModelName = (typeof ModelName)[keyof typeof ModelName];

export interface TypeMapCb<GlobalOmitOptions = {}>
  extends runtime.Types.Utils.Fn<
    { extArgs: runtime.Types.Extensions.InternalArgs },
    runtime.Types.Utils.Record<string, any>
  > {
  returns: TypeMap<this["params"]["extArgs"], GlobalOmitOptions>;
}

export type TypeMap<
  ExtArgs extends
    runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs,
  GlobalOmitOptions = {},
> = {
  globalOmitOptions: {
    omit: GlobalOmitOptions;
  };
  meta: {
    modelProps:
      | "twoFactor"
      | "user"
      | "session"
      | "account"
      | "verification"
      | "clinicMember"
      | "role"
      | "clinicInvitation"
      | "notification"
      | "twoFactorAuth"
      | "passkey"
      | "systemSettings"
      | "aPIKey"
      | "settings"
      | "auditLog"
      | "todo"
      | "feature"
      | "file"
      | "folder"
      | "clinic"
      | "doctor"
      | "workingDays"
      | "staff"
      | "payment"
      | "reminder"
      | "patientBill"
      | "service"
      | "clinicSetting"
      | "wHOGrowthStandard"
      | "rating"
      | "prescription"
      | "drug"
      | "doseGuideline"
      | "prescribedItem"
      | "guardian"
      | "patient"
      | "appointment"
      | "medicalRecords"
      | "medicalRecordAccess"
      | "diagnosis"
      | "vitalSigns"
      | "growthRecord"
      | "immunization"
      | "configStore"
      | "userQuota"
      | "labTest"
      | "feedingLog"
      | "developmentalMilestone"
      | "developmentalCheck"
      | "vaccineSchedule"
      | "expense"
      | "expenseCategory"
      | "expenseSubCategory"
      | "fileStorage"
      | "trainingFile"
      | "knowledgeBase"
      | "trainingWebsite"
      | "agent"
      | "clinicDashboardMV"
      | "patientOverviewMV"
      | "doctorPerformanceMV"
      | "financialOverviewMV"
      | "appointmentScheduleMV"
      | "patientGrowthChartMV"
      | "immunizationScheduleMV"
      | "medicalRecordsMV"
      | "notificationsMV"
      | "expenseAnalysisMV";
    txIsolationLevel: TransactionIsolationLevel;
  };
  model: {
    TwoFactor: {
      payload: Prisma.$TwoFactorPayload<ExtArgs>;
      fields: Prisma.TwoFactorFieldRefs;
      operations: {
        findUnique: {
          args: Prisma.TwoFactorFindUniqueArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TwoFactorPayload> | null;
        };
        findUniqueOrThrow: {
          args: Prisma.TwoFactorFindUniqueOrThrowArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TwoFactorPayload>;
        };
        findFirst: {
          args: Prisma.TwoFactorFindFirstArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TwoFactorPayload> | null;
        };
        findFirstOrThrow: {
          args: Prisma.TwoFactorFindFirstOrThrowArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TwoFactorPayload>;
        };
        findMany: {
          args: Prisma.TwoFactorFindManyArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TwoFactorPayload>[];
        };
        create: {
          args: Prisma.TwoFactorCreateArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TwoFactorPayload>;
        };
        createMany: {
          args: Prisma.TwoFactorCreateManyArgs<ExtArgs>;
          result: BatchPayload;
        };
        createManyAndReturn: {
          args: Prisma.TwoFactorCreateManyAndReturnArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TwoFactorPayload>[];
        };
        delete: {
          args: Prisma.TwoFactorDeleteArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TwoFactorPayload>;
        };
        update: {
          args: Prisma.TwoFactorUpdateArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TwoFactorPayload>;
        };
        deleteMany: {
          args: Prisma.TwoFactorDeleteManyArgs<ExtArgs>;
          result: BatchPayload;
        };
        updateMany: {
          args: Prisma.TwoFactorUpdateManyArgs<ExtArgs>;
          result: BatchPayload;
        };
        updateManyAndReturn: {
          args: Prisma.TwoFactorUpdateManyAndReturnArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TwoFactorPayload>[];
        };
        upsert: {
          args: Prisma.TwoFactorUpsertArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TwoFactorPayload>;
        };
        aggregate: {
          args: Prisma.TwoFactorAggregateArgs<ExtArgs>;
          result: runtime.Types.Utils.Optional<Prisma.AggregateTwoFactor>;
        };
        groupBy: {
          args: Prisma.TwoFactorGroupByArgs<ExtArgs>;
          result: runtime.Types.Utils.Optional<Prisma.TwoFactorGroupByOutputType>[];
        };
        count: {
          args: Prisma.TwoFactorCountArgs<ExtArgs>;
          result:
            | runtime.Types.Utils.Optional<Prisma.TwoFactorCountAggregateOutputType>
            | number;
        };
      };
    };
    User: {
      payload: Prisma.$UserPayload<ExtArgs>;
      fields: Prisma.UserFieldRefs;
      operations: {
        findUnique: {
          args: Prisma.UserFindUniqueArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$UserPayload> | null;
        };
        findUniqueOrThrow: {
          args: Prisma.UserFindUniqueOrThrowArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$UserPayload>;
        };
        findFirst: {
          args: Prisma.UserFindFirstArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$UserPayload> | null;
        };
        findFirstOrThrow: {
          args: Prisma.UserFindFirstOrThrowArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$UserPayload>;
        };
        findMany: {
          args: Prisma.UserFindManyArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$UserPayload>[];
        };
        create: {
          args: Prisma.UserCreateArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$UserPayload>;
        };
        createMany: {
          args: Prisma.UserCreateManyArgs<ExtArgs>;
          result: BatchPayload;
        };
        createManyAndReturn: {
          args: Prisma.UserCreateManyAndReturnArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$UserPayload>[];
        };
        delete: {
          args: Prisma.UserDeleteArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$UserPayload>;
        };
        update: {
          args: Prisma.UserUpdateArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$UserPayload>;
        };
        deleteMany: {
          args: Prisma.UserDeleteManyArgs<ExtArgs>;
          result: BatchPayload;
        };
        updateMany: {
          args: Prisma.UserUpdateManyArgs<ExtArgs>;
          result: BatchPayload;
        };
        updateManyAndReturn: {
          args: Prisma.UserUpdateManyAndReturnArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$UserPayload>[];
        };
        upsert: {
          args: Prisma.UserUpsertArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$UserPayload>;
        };
        aggregate: {
          args: Prisma.UserAggregateArgs<ExtArgs>;
          result: runtime.Types.Utils.Optional<Prisma.AggregateUser>;
        };
        groupBy: {
          args: Prisma.UserGroupByArgs<ExtArgs>;
          result: runtime.Types.Utils.Optional<Prisma.UserGroupByOutputType>[];
        };
        count: {
          args: Prisma.UserCountArgs<ExtArgs>;
          result:
            | runtime.Types.Utils.Optional<Prisma.UserCountAggregateOutputType>
            | number;
        };
      };
    };
    Session: {
      payload: Prisma.$SessionPayload<ExtArgs>;
      fields: Prisma.SessionFieldRefs;
      operations: {
        findUnique: {
          args: Prisma.SessionFindUniqueArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$SessionPayload> | null;
        };
        findUniqueOrThrow: {
          args: Prisma.SessionFindUniqueOrThrowArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$SessionPayload>;
        };
        findFirst: {
          args: Prisma.SessionFindFirstArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$SessionPayload> | null;
        };
        findFirstOrThrow: {
          args: Prisma.SessionFindFirstOrThrowArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$SessionPayload>;
        };
        findMany: {
          args: Prisma.SessionFindManyArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$SessionPayload>[];
        };
        create: {
          args: Prisma.SessionCreateArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$SessionPayload>;
        };
        createMany: {
          args: Prisma.SessionCreateManyArgs<ExtArgs>;
          result: BatchPayload;
        };
        createManyAndReturn: {
          args: Prisma.SessionCreateManyAndReturnArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$SessionPayload>[];
        };
        delete: {
          args: Prisma.SessionDeleteArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$SessionPayload>;
        };
        update: {
          args: Prisma.SessionUpdateArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$SessionPayload>;
        };
        deleteMany: {
          args: Prisma.SessionDeleteManyArgs<ExtArgs>;
          result: BatchPayload;
        };
        updateMany: {
          args: Prisma.SessionUpdateManyArgs<ExtArgs>;
          result: BatchPayload;
        };
        updateManyAndReturn: {
          args: Prisma.SessionUpdateManyAndReturnArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$SessionPayload>[];
        };
        upsert: {
          args: Prisma.SessionUpsertArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$SessionPayload>;
        };
        aggregate: {
          args: Prisma.SessionAggregateArgs<ExtArgs>;
          result: runtime.Types.Utils.Optional<Prisma.AggregateSession>;
        };
        groupBy: {
          args: Prisma.SessionGroupByArgs<ExtArgs>;
          result: runtime.Types.Utils.Optional<Prisma.SessionGroupByOutputType>[];
        };
        count: {
          args: Prisma.SessionCountArgs<ExtArgs>;
          result:
            | runtime.Types.Utils.Optional<Prisma.SessionCountAggregateOutputType>
            | number;
        };
      };
    };
    Account: {
      payload: Prisma.$AccountPayload<ExtArgs>;
      fields: Prisma.AccountFieldRefs;
      operations: {
        findUnique: {
          args: Prisma.AccountFindUniqueArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AccountPayload> | null;
        };
        findUniqueOrThrow: {
          args: Prisma.AccountFindUniqueOrThrowArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AccountPayload>;
        };
        findFirst: {
          args: Prisma.AccountFindFirstArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AccountPayload> | null;
        };
        findFirstOrThrow: {
          args: Prisma.AccountFindFirstOrThrowArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AccountPayload>;
        };
        findMany: {
          args: Prisma.AccountFindManyArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AccountPayload>[];
        };
        create: {
          args: Prisma.AccountCreateArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AccountPayload>;
        };
        createMany: {
          args: Prisma.AccountCreateManyArgs<ExtArgs>;
          result: BatchPayload;
        };
        createManyAndReturn: {
          args: Prisma.AccountCreateManyAndReturnArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AccountPayload>[];
        };
        delete: {
          args: Prisma.AccountDeleteArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AccountPayload>;
        };
        update: {
          args: Prisma.AccountUpdateArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AccountPayload>;
        };
        deleteMany: {
          args: Prisma.AccountDeleteManyArgs<ExtArgs>;
          result: BatchPayload;
        };
        updateMany: {
          args: Prisma.AccountUpdateManyArgs<ExtArgs>;
          result: BatchPayload;
        };
        updateManyAndReturn: {
          args: Prisma.AccountUpdateManyAndReturnArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AccountPayload>[];
        };
        upsert: {
          args: Prisma.AccountUpsertArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AccountPayload>;
        };
        aggregate: {
          args: Prisma.AccountAggregateArgs<ExtArgs>;
          result: runtime.Types.Utils.Optional<Prisma.AggregateAccount>;
        };
        groupBy: {
          args: Prisma.AccountGroupByArgs<ExtArgs>;
          result: runtime.Types.Utils.Optional<Prisma.AccountGroupByOutputType>[];
        };
        count: {
          args: Prisma.AccountCountArgs<ExtArgs>;
          result:
            | runtime.Types.Utils.Optional<Prisma.AccountCountAggregateOutputType>
            | number;
        };
      };
    };
    Verification: {
      payload: Prisma.$VerificationPayload<ExtArgs>;
      fields: Prisma.VerificationFieldRefs;
      operations: {
        findUnique: {
          args: Prisma.VerificationFindUniqueArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$VerificationPayload> | null;
        };
        findUniqueOrThrow: {
          args: Prisma.VerificationFindUniqueOrThrowArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$VerificationPayload>;
        };
        findFirst: {
          args: Prisma.VerificationFindFirstArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$VerificationPayload> | null;
        };
        findFirstOrThrow: {
          args: Prisma.VerificationFindFirstOrThrowArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$VerificationPayload>;
        };
        findMany: {
          args: Prisma.VerificationFindManyArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$VerificationPayload>[];
        };
        create: {
          args: Prisma.VerificationCreateArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$VerificationPayload>;
        };
        createMany: {
          args: Prisma.VerificationCreateManyArgs<ExtArgs>;
          result: BatchPayload;
        };
        createManyAndReturn: {
          args: Prisma.VerificationCreateManyAndReturnArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$VerificationPayload>[];
        };
        delete: {
          args: Prisma.VerificationDeleteArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$VerificationPayload>;
        };
        update: {
          args: Prisma.VerificationUpdateArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$VerificationPayload>;
        };
        deleteMany: {
          args: Prisma.VerificationDeleteManyArgs<ExtArgs>;
          result: BatchPayload;
        };
        updateMany: {
          args: Prisma.VerificationUpdateManyArgs<ExtArgs>;
          result: BatchPayload;
        };
        updateManyAndReturn: {
          args: Prisma.VerificationUpdateManyAndReturnArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$VerificationPayload>[];
        };
        upsert: {
          args: Prisma.VerificationUpsertArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$VerificationPayload>;
        };
        aggregate: {
          args: Prisma.VerificationAggregateArgs<ExtArgs>;
          result: runtime.Types.Utils.Optional<Prisma.AggregateVerification>;
        };
        groupBy: {
          args: Prisma.VerificationGroupByArgs<ExtArgs>;
          result: runtime.Types.Utils.Optional<Prisma.VerificationGroupByOutputType>[];
        };
        count: {
          args: Prisma.VerificationCountArgs<ExtArgs>;
          result:
            | runtime.Types.Utils.Optional<Prisma.VerificationCountAggregateOutputType>
            | number;
        };
      };
    };
    ClinicMember: {
      payload: Prisma.$ClinicMemberPayload<ExtArgs>;
      fields: Prisma.ClinicMemberFieldRefs;
      operations: {
        findUnique: {
          args: Prisma.ClinicMemberFindUniqueArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ClinicMemberPayload> | null;
        };
        findUniqueOrThrow: {
          args: Prisma.ClinicMemberFindUniqueOrThrowArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ClinicMemberPayload>;
        };
        findFirst: {
          args: Prisma.ClinicMemberFindFirstArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ClinicMemberPayload> | null;
        };
        findFirstOrThrow: {
          args: Prisma.ClinicMemberFindFirstOrThrowArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ClinicMemberPayload>;
        };
        findMany: {
          args: Prisma.ClinicMemberFindManyArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ClinicMemberPayload>[];
        };
        create: {
          args: Prisma.ClinicMemberCreateArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ClinicMemberPayload>;
        };
        createMany: {
          args: Prisma.ClinicMemberCreateManyArgs<ExtArgs>;
          result: BatchPayload;
        };
        createManyAndReturn: {
          args: Prisma.ClinicMemberCreateManyAndReturnArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ClinicMemberPayload>[];
        };
        delete: {
          args: Prisma.ClinicMemberDeleteArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ClinicMemberPayload>;
        };
        update: {
          args: Prisma.ClinicMemberUpdateArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ClinicMemberPayload>;
        };
        deleteMany: {
          args: Prisma.ClinicMemberDeleteManyArgs<ExtArgs>;
          result: BatchPayload;
        };
        updateMany: {
          args: Prisma.ClinicMemberUpdateManyArgs<ExtArgs>;
          result: BatchPayload;
        };
        updateManyAndReturn: {
          args: Prisma.ClinicMemberUpdateManyAndReturnArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ClinicMemberPayload>[];
        };
        upsert: {
          args: Prisma.ClinicMemberUpsertArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ClinicMemberPayload>;
        };
        aggregate: {
          args: Prisma.ClinicMemberAggregateArgs<ExtArgs>;
          result: runtime.Types.Utils.Optional<Prisma.AggregateClinicMember>;
        };
        groupBy: {
          args: Prisma.ClinicMemberGroupByArgs<ExtArgs>;
          result: runtime.Types.Utils.Optional<Prisma.ClinicMemberGroupByOutputType>[];
        };
        count: {
          args: Prisma.ClinicMemberCountArgs<ExtArgs>;
          result:
            | runtime.Types.Utils.Optional<Prisma.ClinicMemberCountAggregateOutputType>
            | number;
        };
      };
    };
    Role: {
      payload: Prisma.$RolePayload<ExtArgs>;
      fields: Prisma.RoleFieldRefs;
      operations: {
        findUnique: {
          args: Prisma.RoleFindUniqueArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$RolePayload> | null;
        };
        findUniqueOrThrow: {
          args: Prisma.RoleFindUniqueOrThrowArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$RolePayload>;
        };
        findFirst: {
          args: Prisma.RoleFindFirstArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$RolePayload> | null;
        };
        findFirstOrThrow: {
          args: Prisma.RoleFindFirstOrThrowArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$RolePayload>;
        };
        findMany: {
          args: Prisma.RoleFindManyArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$RolePayload>[];
        };
        create: {
          args: Prisma.RoleCreateArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$RolePayload>;
        };
        createMany: {
          args: Prisma.RoleCreateManyArgs<ExtArgs>;
          result: BatchPayload;
        };
        createManyAndReturn: {
          args: Prisma.RoleCreateManyAndReturnArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$RolePayload>[];
        };
        delete: {
          args: Prisma.RoleDeleteArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$RolePayload>;
        };
        update: {
          args: Prisma.RoleUpdateArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$RolePayload>;
        };
        deleteMany: {
          args: Prisma.RoleDeleteManyArgs<ExtArgs>;
          result: BatchPayload;
        };
        updateMany: {
          args: Prisma.RoleUpdateManyArgs<ExtArgs>;
          result: BatchPayload;
        };
        updateManyAndReturn: {
          args: Prisma.RoleUpdateManyAndReturnArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$RolePayload>[];
        };
        upsert: {
          args: Prisma.RoleUpsertArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$RolePayload>;
        };
        aggregate: {
          args: Prisma.RoleAggregateArgs<ExtArgs>;
          result: runtime.Types.Utils.Optional<Prisma.AggregateRole>;
        };
        groupBy: {
          args: Prisma.RoleGroupByArgs<ExtArgs>;
          result: runtime.Types.Utils.Optional<Prisma.RoleGroupByOutputType>[];
        };
        count: {
          args: Prisma.RoleCountArgs<ExtArgs>;
          result:
            | runtime.Types.Utils.Optional<Prisma.RoleCountAggregateOutputType>
            | number;
        };
      };
    };
    clinicInvitation: {
      payload: Prisma.$clinicInvitationPayload<ExtArgs>;
      fields: Prisma.clinicInvitationFieldRefs;
      operations: {
        findUnique: {
          args: Prisma.clinicInvitationFindUniqueArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$clinicInvitationPayload> | null;
        };
        findUniqueOrThrow: {
          args: Prisma.clinicInvitationFindUniqueOrThrowArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$clinicInvitationPayload>;
        };
        findFirst: {
          args: Prisma.clinicInvitationFindFirstArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$clinicInvitationPayload> | null;
        };
        findFirstOrThrow: {
          args: Prisma.clinicInvitationFindFirstOrThrowArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$clinicInvitationPayload>;
        };
        findMany: {
          args: Prisma.clinicInvitationFindManyArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$clinicInvitationPayload>[];
        };
        create: {
          args: Prisma.clinicInvitationCreateArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$clinicInvitationPayload>;
        };
        createMany: {
          args: Prisma.clinicInvitationCreateManyArgs<ExtArgs>;
          result: BatchPayload;
        };
        createManyAndReturn: {
          args: Prisma.clinicInvitationCreateManyAndReturnArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$clinicInvitationPayload>[];
        };
        delete: {
          args: Prisma.clinicInvitationDeleteArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$clinicInvitationPayload>;
        };
        update: {
          args: Prisma.clinicInvitationUpdateArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$clinicInvitationPayload>;
        };
        deleteMany: {
          args: Prisma.clinicInvitationDeleteManyArgs<ExtArgs>;
          result: BatchPayload;
        };
        updateMany: {
          args: Prisma.clinicInvitationUpdateManyArgs<ExtArgs>;
          result: BatchPayload;
        };
        updateManyAndReturn: {
          args: Prisma.clinicInvitationUpdateManyAndReturnArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$clinicInvitationPayload>[];
        };
        upsert: {
          args: Prisma.clinicInvitationUpsertArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$clinicInvitationPayload>;
        };
        aggregate: {
          args: Prisma.ClinicInvitationAggregateArgs<ExtArgs>;
          result: runtime.Types.Utils.Optional<Prisma.AggregateClinicInvitation>;
        };
        groupBy: {
          args: Prisma.clinicInvitationGroupByArgs<ExtArgs>;
          result: runtime.Types.Utils.Optional<Prisma.ClinicInvitationGroupByOutputType>[];
        };
        count: {
          args: Prisma.clinicInvitationCountArgs<ExtArgs>;
          result:
            | runtime.Types.Utils.Optional<Prisma.ClinicInvitationCountAggregateOutputType>
            | number;
        };
      };
    };
    Notification: {
      payload: Prisma.$NotificationPayload<ExtArgs>;
      fields: Prisma.NotificationFieldRefs;
      operations: {
        findUnique: {
          args: Prisma.NotificationFindUniqueArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$NotificationPayload> | null;
        };
        findUniqueOrThrow: {
          args: Prisma.NotificationFindUniqueOrThrowArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$NotificationPayload>;
        };
        findFirst: {
          args: Prisma.NotificationFindFirstArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$NotificationPayload> | null;
        };
        findFirstOrThrow: {
          args: Prisma.NotificationFindFirstOrThrowArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$NotificationPayload>;
        };
        findMany: {
          args: Prisma.NotificationFindManyArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$NotificationPayload>[];
        };
        create: {
          args: Prisma.NotificationCreateArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$NotificationPayload>;
        };
        createMany: {
          args: Prisma.NotificationCreateManyArgs<ExtArgs>;
          result: BatchPayload;
        };
        createManyAndReturn: {
          args: Prisma.NotificationCreateManyAndReturnArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$NotificationPayload>[];
        };
        delete: {
          args: Prisma.NotificationDeleteArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$NotificationPayload>;
        };
        update: {
          args: Prisma.NotificationUpdateArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$NotificationPayload>;
        };
        deleteMany: {
          args: Prisma.NotificationDeleteManyArgs<ExtArgs>;
          result: BatchPayload;
        };
        updateMany: {
          args: Prisma.NotificationUpdateManyArgs<ExtArgs>;
          result: BatchPayload;
        };
        updateManyAndReturn: {
          args: Prisma.NotificationUpdateManyAndReturnArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$NotificationPayload>[];
        };
        upsert: {
          args: Prisma.NotificationUpsertArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$NotificationPayload>;
        };
        aggregate: {
          args: Prisma.NotificationAggregateArgs<ExtArgs>;
          result: runtime.Types.Utils.Optional<Prisma.AggregateNotification>;
        };
        groupBy: {
          args: Prisma.NotificationGroupByArgs<ExtArgs>;
          result: runtime.Types.Utils.Optional<Prisma.NotificationGroupByOutputType>[];
        };
        count: {
          args: Prisma.NotificationCountArgs<ExtArgs>;
          result:
            | runtime.Types.Utils.Optional<Prisma.NotificationCountAggregateOutputType>
            | number;
        };
      };
    };
    TwoFactorAuth: {
      payload: Prisma.$TwoFactorAuthPayload<ExtArgs>;
      fields: Prisma.TwoFactorAuthFieldRefs;
      operations: {
        findUnique: {
          args: Prisma.TwoFactorAuthFindUniqueArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TwoFactorAuthPayload> | null;
        };
        findUniqueOrThrow: {
          args: Prisma.TwoFactorAuthFindUniqueOrThrowArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TwoFactorAuthPayload>;
        };
        findFirst: {
          args: Prisma.TwoFactorAuthFindFirstArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TwoFactorAuthPayload> | null;
        };
        findFirstOrThrow: {
          args: Prisma.TwoFactorAuthFindFirstOrThrowArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TwoFactorAuthPayload>;
        };
        findMany: {
          args: Prisma.TwoFactorAuthFindManyArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TwoFactorAuthPayload>[];
        };
        create: {
          args: Prisma.TwoFactorAuthCreateArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TwoFactorAuthPayload>;
        };
        createMany: {
          args: Prisma.TwoFactorAuthCreateManyArgs<ExtArgs>;
          result: BatchPayload;
        };
        createManyAndReturn: {
          args: Prisma.TwoFactorAuthCreateManyAndReturnArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TwoFactorAuthPayload>[];
        };
        delete: {
          args: Prisma.TwoFactorAuthDeleteArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TwoFactorAuthPayload>;
        };
        update: {
          args: Prisma.TwoFactorAuthUpdateArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TwoFactorAuthPayload>;
        };
        deleteMany: {
          args: Prisma.TwoFactorAuthDeleteManyArgs<ExtArgs>;
          result: BatchPayload;
        };
        updateMany: {
          args: Prisma.TwoFactorAuthUpdateManyArgs<ExtArgs>;
          result: BatchPayload;
        };
        updateManyAndReturn: {
          args: Prisma.TwoFactorAuthUpdateManyAndReturnArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TwoFactorAuthPayload>[];
        };
        upsert: {
          args: Prisma.TwoFactorAuthUpsertArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TwoFactorAuthPayload>;
        };
        aggregate: {
          args: Prisma.TwoFactorAuthAggregateArgs<ExtArgs>;
          result: runtime.Types.Utils.Optional<Prisma.AggregateTwoFactorAuth>;
        };
        groupBy: {
          args: Prisma.TwoFactorAuthGroupByArgs<ExtArgs>;
          result: runtime.Types.Utils.Optional<Prisma.TwoFactorAuthGroupByOutputType>[];
        };
        count: {
          args: Prisma.TwoFactorAuthCountArgs<ExtArgs>;
          result:
            | runtime.Types.Utils.Optional<Prisma.TwoFactorAuthCountAggregateOutputType>
            | number;
        };
      };
    };
    Passkey: {
      payload: Prisma.$PasskeyPayload<ExtArgs>;
      fields: Prisma.PasskeyFieldRefs;
      operations: {
        findUnique: {
          args: Prisma.PasskeyFindUniqueArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PasskeyPayload> | null;
        };
        findUniqueOrThrow: {
          args: Prisma.PasskeyFindUniqueOrThrowArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PasskeyPayload>;
        };
        findFirst: {
          args: Prisma.PasskeyFindFirstArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PasskeyPayload> | null;
        };
        findFirstOrThrow: {
          args: Prisma.PasskeyFindFirstOrThrowArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PasskeyPayload>;
        };
        findMany: {
          args: Prisma.PasskeyFindManyArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PasskeyPayload>[];
        };
        create: {
          args: Prisma.PasskeyCreateArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PasskeyPayload>;
        };
        createMany: {
          args: Prisma.PasskeyCreateManyArgs<ExtArgs>;
          result: BatchPayload;
        };
        createManyAndReturn: {
          args: Prisma.PasskeyCreateManyAndReturnArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PasskeyPayload>[];
        };
        delete: {
          args: Prisma.PasskeyDeleteArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PasskeyPayload>;
        };
        update: {
          args: Prisma.PasskeyUpdateArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PasskeyPayload>;
        };
        deleteMany: {
          args: Prisma.PasskeyDeleteManyArgs<ExtArgs>;
          result: BatchPayload;
        };
        updateMany: {
          args: Prisma.PasskeyUpdateManyArgs<ExtArgs>;
          result: BatchPayload;
        };
        updateManyAndReturn: {
          args: Prisma.PasskeyUpdateManyAndReturnArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PasskeyPayload>[];
        };
        upsert: {
          args: Prisma.PasskeyUpsertArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PasskeyPayload>;
        };
        aggregate: {
          args: Prisma.PasskeyAggregateArgs<ExtArgs>;
          result: runtime.Types.Utils.Optional<Prisma.AggregatePasskey>;
        };
        groupBy: {
          args: Prisma.PasskeyGroupByArgs<ExtArgs>;
          result: runtime.Types.Utils.Optional<Prisma.PasskeyGroupByOutputType>[];
        };
        count: {
          args: Prisma.PasskeyCountArgs<ExtArgs>;
          result:
            | runtime.Types.Utils.Optional<Prisma.PasskeyCountAggregateOutputType>
            | number;
        };
      };
    };
    SystemSettings: {
      payload: Prisma.$SystemSettingsPayload<ExtArgs>;
      fields: Prisma.SystemSettingsFieldRefs;
      operations: {
        findUnique: {
          args: Prisma.SystemSettingsFindUniqueArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$SystemSettingsPayload> | null;
        };
        findUniqueOrThrow: {
          args: Prisma.SystemSettingsFindUniqueOrThrowArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$SystemSettingsPayload>;
        };
        findFirst: {
          args: Prisma.SystemSettingsFindFirstArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$SystemSettingsPayload> | null;
        };
        findFirstOrThrow: {
          args: Prisma.SystemSettingsFindFirstOrThrowArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$SystemSettingsPayload>;
        };
        findMany: {
          args: Prisma.SystemSettingsFindManyArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$SystemSettingsPayload>[];
        };
        create: {
          args: Prisma.SystemSettingsCreateArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$SystemSettingsPayload>;
        };
        createMany: {
          args: Prisma.SystemSettingsCreateManyArgs<ExtArgs>;
          result: BatchPayload;
        };
        createManyAndReturn: {
          args: Prisma.SystemSettingsCreateManyAndReturnArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$SystemSettingsPayload>[];
        };
        delete: {
          args: Prisma.SystemSettingsDeleteArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$SystemSettingsPayload>;
        };
        update: {
          args: Prisma.SystemSettingsUpdateArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$SystemSettingsPayload>;
        };
        deleteMany: {
          args: Prisma.SystemSettingsDeleteManyArgs<ExtArgs>;
          result: BatchPayload;
        };
        updateMany: {
          args: Prisma.SystemSettingsUpdateManyArgs<ExtArgs>;
          result: BatchPayload;
        };
        updateManyAndReturn: {
          args: Prisma.SystemSettingsUpdateManyAndReturnArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$SystemSettingsPayload>[];
        };
        upsert: {
          args: Prisma.SystemSettingsUpsertArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$SystemSettingsPayload>;
        };
        aggregate: {
          args: Prisma.SystemSettingsAggregateArgs<ExtArgs>;
          result: runtime.Types.Utils.Optional<Prisma.AggregateSystemSettings>;
        };
        groupBy: {
          args: Prisma.SystemSettingsGroupByArgs<ExtArgs>;
          result: runtime.Types.Utils.Optional<Prisma.SystemSettingsGroupByOutputType>[];
        };
        count: {
          args: Prisma.SystemSettingsCountArgs<ExtArgs>;
          result:
            | runtime.Types.Utils.Optional<Prisma.SystemSettingsCountAggregateOutputType>
            | number;
        };
      };
    };
    APIKey: {
      payload: Prisma.$APIKeyPayload<ExtArgs>;
      fields: Prisma.APIKeyFieldRefs;
      operations: {
        findUnique: {
          args: Prisma.APIKeyFindUniqueArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$APIKeyPayload> | null;
        };
        findUniqueOrThrow: {
          args: Prisma.APIKeyFindUniqueOrThrowArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$APIKeyPayload>;
        };
        findFirst: {
          args: Prisma.APIKeyFindFirstArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$APIKeyPayload> | null;
        };
        findFirstOrThrow: {
          args: Prisma.APIKeyFindFirstOrThrowArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$APIKeyPayload>;
        };
        findMany: {
          args: Prisma.APIKeyFindManyArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$APIKeyPayload>[];
        };
        create: {
          args: Prisma.APIKeyCreateArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$APIKeyPayload>;
        };
        createMany: {
          args: Prisma.APIKeyCreateManyArgs<ExtArgs>;
          result: BatchPayload;
        };
        createManyAndReturn: {
          args: Prisma.APIKeyCreateManyAndReturnArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$APIKeyPayload>[];
        };
        delete: {
          args: Prisma.APIKeyDeleteArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$APIKeyPayload>;
        };
        update: {
          args: Prisma.APIKeyUpdateArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$APIKeyPayload>;
        };
        deleteMany: {
          args: Prisma.APIKeyDeleteManyArgs<ExtArgs>;
          result: BatchPayload;
        };
        updateMany: {
          args: Prisma.APIKeyUpdateManyArgs<ExtArgs>;
          result: BatchPayload;
        };
        updateManyAndReturn: {
          args: Prisma.APIKeyUpdateManyAndReturnArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$APIKeyPayload>[];
        };
        upsert: {
          args: Prisma.APIKeyUpsertArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$APIKeyPayload>;
        };
        aggregate: {
          args: Prisma.APIKeyAggregateArgs<ExtArgs>;
          result: runtime.Types.Utils.Optional<Prisma.AggregateAPIKey>;
        };
        groupBy: {
          args: Prisma.APIKeyGroupByArgs<ExtArgs>;
          result: runtime.Types.Utils.Optional<Prisma.APIKeyGroupByOutputType>[];
        };
        count: {
          args: Prisma.APIKeyCountArgs<ExtArgs>;
          result:
            | runtime.Types.Utils.Optional<Prisma.APIKeyCountAggregateOutputType>
            | number;
        };
      };
    };
    Settings: {
      payload: Prisma.$SettingsPayload<ExtArgs>;
      fields: Prisma.SettingsFieldRefs;
      operations: {
        findUnique: {
          args: Prisma.SettingsFindUniqueArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$SettingsPayload> | null;
        };
        findUniqueOrThrow: {
          args: Prisma.SettingsFindUniqueOrThrowArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$SettingsPayload>;
        };
        findFirst: {
          args: Prisma.SettingsFindFirstArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$SettingsPayload> | null;
        };
        findFirstOrThrow: {
          args: Prisma.SettingsFindFirstOrThrowArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$SettingsPayload>;
        };
        findMany: {
          args: Prisma.SettingsFindManyArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$SettingsPayload>[];
        };
        create: {
          args: Prisma.SettingsCreateArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$SettingsPayload>;
        };
        createMany: {
          args: Prisma.SettingsCreateManyArgs<ExtArgs>;
          result: BatchPayload;
        };
        createManyAndReturn: {
          args: Prisma.SettingsCreateManyAndReturnArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$SettingsPayload>[];
        };
        delete: {
          args: Prisma.SettingsDeleteArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$SettingsPayload>;
        };
        update: {
          args: Prisma.SettingsUpdateArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$SettingsPayload>;
        };
        deleteMany: {
          args: Prisma.SettingsDeleteManyArgs<ExtArgs>;
          result: BatchPayload;
        };
        updateMany: {
          args: Prisma.SettingsUpdateManyArgs<ExtArgs>;
          result: BatchPayload;
        };
        updateManyAndReturn: {
          args: Prisma.SettingsUpdateManyAndReturnArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$SettingsPayload>[];
        };
        upsert: {
          args: Prisma.SettingsUpsertArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$SettingsPayload>;
        };
        aggregate: {
          args: Prisma.SettingsAggregateArgs<ExtArgs>;
          result: runtime.Types.Utils.Optional<Prisma.AggregateSettings>;
        };
        groupBy: {
          args: Prisma.SettingsGroupByArgs<ExtArgs>;
          result: runtime.Types.Utils.Optional<Prisma.SettingsGroupByOutputType>[];
        };
        count: {
          args: Prisma.SettingsCountArgs<ExtArgs>;
          result:
            | runtime.Types.Utils.Optional<Prisma.SettingsCountAggregateOutputType>
            | number;
        };
      };
    };
    AuditLog: {
      payload: Prisma.$AuditLogPayload<ExtArgs>;
      fields: Prisma.AuditLogFieldRefs;
      operations: {
        findUnique: {
          args: Prisma.AuditLogFindUniqueArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AuditLogPayload> | null;
        };
        findUniqueOrThrow: {
          args: Prisma.AuditLogFindUniqueOrThrowArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AuditLogPayload>;
        };
        findFirst: {
          args: Prisma.AuditLogFindFirstArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AuditLogPayload> | null;
        };
        findFirstOrThrow: {
          args: Prisma.AuditLogFindFirstOrThrowArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AuditLogPayload>;
        };
        findMany: {
          args: Prisma.AuditLogFindManyArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AuditLogPayload>[];
        };
        create: {
          args: Prisma.AuditLogCreateArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AuditLogPayload>;
        };
        createMany: {
          args: Prisma.AuditLogCreateManyArgs<ExtArgs>;
          result: BatchPayload;
        };
        createManyAndReturn: {
          args: Prisma.AuditLogCreateManyAndReturnArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AuditLogPayload>[];
        };
        delete: {
          args: Prisma.AuditLogDeleteArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AuditLogPayload>;
        };
        update: {
          args: Prisma.AuditLogUpdateArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AuditLogPayload>;
        };
        deleteMany: {
          args: Prisma.AuditLogDeleteManyArgs<ExtArgs>;
          result: BatchPayload;
        };
        updateMany: {
          args: Prisma.AuditLogUpdateManyArgs<ExtArgs>;
          result: BatchPayload;
        };
        updateManyAndReturn: {
          args: Prisma.AuditLogUpdateManyAndReturnArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AuditLogPayload>[];
        };
        upsert: {
          args: Prisma.AuditLogUpsertArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AuditLogPayload>;
        };
        aggregate: {
          args: Prisma.AuditLogAggregateArgs<ExtArgs>;
          result: runtime.Types.Utils.Optional<Prisma.AggregateAuditLog>;
        };
        groupBy: {
          args: Prisma.AuditLogGroupByArgs<ExtArgs>;
          result: runtime.Types.Utils.Optional<Prisma.AuditLogGroupByOutputType>[];
        };
        count: {
          args: Prisma.AuditLogCountArgs<ExtArgs>;
          result:
            | runtime.Types.Utils.Optional<Prisma.AuditLogCountAggregateOutputType>
            | number;
        };
      };
    };
    Todo: {
      payload: Prisma.$TodoPayload<ExtArgs>;
      fields: Prisma.TodoFieldRefs;
      operations: {
        findUnique: {
          args: Prisma.TodoFindUniqueArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TodoPayload> | null;
        };
        findUniqueOrThrow: {
          args: Prisma.TodoFindUniqueOrThrowArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TodoPayload>;
        };
        findFirst: {
          args: Prisma.TodoFindFirstArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TodoPayload> | null;
        };
        findFirstOrThrow: {
          args: Prisma.TodoFindFirstOrThrowArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TodoPayload>;
        };
        findMany: {
          args: Prisma.TodoFindManyArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TodoPayload>[];
        };
        create: {
          args: Prisma.TodoCreateArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TodoPayload>;
        };
        createMany: {
          args: Prisma.TodoCreateManyArgs<ExtArgs>;
          result: BatchPayload;
        };
        createManyAndReturn: {
          args: Prisma.TodoCreateManyAndReturnArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TodoPayload>[];
        };
        delete: {
          args: Prisma.TodoDeleteArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TodoPayload>;
        };
        update: {
          args: Prisma.TodoUpdateArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TodoPayload>;
        };
        deleteMany: {
          args: Prisma.TodoDeleteManyArgs<ExtArgs>;
          result: BatchPayload;
        };
        updateMany: {
          args: Prisma.TodoUpdateManyArgs<ExtArgs>;
          result: BatchPayload;
        };
        updateManyAndReturn: {
          args: Prisma.TodoUpdateManyAndReturnArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TodoPayload>[];
        };
        upsert: {
          args: Prisma.TodoUpsertArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TodoPayload>;
        };
        aggregate: {
          args: Prisma.TodoAggregateArgs<ExtArgs>;
          result: runtime.Types.Utils.Optional<Prisma.AggregateTodo>;
        };
        groupBy: {
          args: Prisma.TodoGroupByArgs<ExtArgs>;
          result: runtime.Types.Utils.Optional<Prisma.TodoGroupByOutputType>[];
        };
        count: {
          args: Prisma.TodoCountArgs<ExtArgs>;
          result:
            | runtime.Types.Utils.Optional<Prisma.TodoCountAggregateOutputType>
            | number;
        };
      };
    };
    Feature: {
      payload: Prisma.$FeaturePayload<ExtArgs>;
      fields: Prisma.FeatureFieldRefs;
      operations: {
        findUnique: {
          args: Prisma.FeatureFindUniqueArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$FeaturePayload> | null;
        };
        findUniqueOrThrow: {
          args: Prisma.FeatureFindUniqueOrThrowArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$FeaturePayload>;
        };
        findFirst: {
          args: Prisma.FeatureFindFirstArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$FeaturePayload> | null;
        };
        findFirstOrThrow: {
          args: Prisma.FeatureFindFirstOrThrowArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$FeaturePayload>;
        };
        findMany: {
          args: Prisma.FeatureFindManyArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$FeaturePayload>[];
        };
        create: {
          args: Prisma.FeatureCreateArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$FeaturePayload>;
        };
        createMany: {
          args: Prisma.FeatureCreateManyArgs<ExtArgs>;
          result: BatchPayload;
        };
        createManyAndReturn: {
          args: Prisma.FeatureCreateManyAndReturnArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$FeaturePayload>[];
        };
        delete: {
          args: Prisma.FeatureDeleteArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$FeaturePayload>;
        };
        update: {
          args: Prisma.FeatureUpdateArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$FeaturePayload>;
        };
        deleteMany: {
          args: Prisma.FeatureDeleteManyArgs<ExtArgs>;
          result: BatchPayload;
        };
        updateMany: {
          args: Prisma.FeatureUpdateManyArgs<ExtArgs>;
          result: BatchPayload;
        };
        updateManyAndReturn: {
          args: Prisma.FeatureUpdateManyAndReturnArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$FeaturePayload>[];
        };
        upsert: {
          args: Prisma.FeatureUpsertArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$FeaturePayload>;
        };
        aggregate: {
          args: Prisma.FeatureAggregateArgs<ExtArgs>;
          result: runtime.Types.Utils.Optional<Prisma.AggregateFeature>;
        };
        groupBy: {
          args: Prisma.FeatureGroupByArgs<ExtArgs>;
          result: runtime.Types.Utils.Optional<Prisma.FeatureGroupByOutputType>[];
        };
        count: {
          args: Prisma.FeatureCountArgs<ExtArgs>;
          result:
            | runtime.Types.Utils.Optional<Prisma.FeatureCountAggregateOutputType>
            | number;
        };
      };
    };
    File: {
      payload: Prisma.$FilePayload<ExtArgs>;
      fields: Prisma.FileFieldRefs;
      operations: {
        findUnique: {
          args: Prisma.FileFindUniqueArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$FilePayload> | null;
        };
        findUniqueOrThrow: {
          args: Prisma.FileFindUniqueOrThrowArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$FilePayload>;
        };
        findFirst: {
          args: Prisma.FileFindFirstArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$FilePayload> | null;
        };
        findFirstOrThrow: {
          args: Prisma.FileFindFirstOrThrowArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$FilePayload>;
        };
        findMany: {
          args: Prisma.FileFindManyArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$FilePayload>[];
        };
        create: {
          args: Prisma.FileCreateArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$FilePayload>;
        };
        createMany: {
          args: Prisma.FileCreateManyArgs<ExtArgs>;
          result: BatchPayload;
        };
        createManyAndReturn: {
          args: Prisma.FileCreateManyAndReturnArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$FilePayload>[];
        };
        delete: {
          args: Prisma.FileDeleteArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$FilePayload>;
        };
        update: {
          args: Prisma.FileUpdateArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$FilePayload>;
        };
        deleteMany: {
          args: Prisma.FileDeleteManyArgs<ExtArgs>;
          result: BatchPayload;
        };
        updateMany: {
          args: Prisma.FileUpdateManyArgs<ExtArgs>;
          result: BatchPayload;
        };
        updateManyAndReturn: {
          args: Prisma.FileUpdateManyAndReturnArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$FilePayload>[];
        };
        upsert: {
          args: Prisma.FileUpsertArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$FilePayload>;
        };
        aggregate: {
          args: Prisma.FileAggregateArgs<ExtArgs>;
          result: runtime.Types.Utils.Optional<Prisma.AggregateFile>;
        };
        groupBy: {
          args: Prisma.FileGroupByArgs<ExtArgs>;
          result: runtime.Types.Utils.Optional<Prisma.FileGroupByOutputType>[];
        };
        count: {
          args: Prisma.FileCountArgs<ExtArgs>;
          result:
            | runtime.Types.Utils.Optional<Prisma.FileCountAggregateOutputType>
            | number;
        };
      };
    };
    Folder: {
      payload: Prisma.$FolderPayload<ExtArgs>;
      fields: Prisma.FolderFieldRefs;
      operations: {
        findUnique: {
          args: Prisma.FolderFindUniqueArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$FolderPayload> | null;
        };
        findUniqueOrThrow: {
          args: Prisma.FolderFindUniqueOrThrowArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$FolderPayload>;
        };
        findFirst: {
          args: Prisma.FolderFindFirstArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$FolderPayload> | null;
        };
        findFirstOrThrow: {
          args: Prisma.FolderFindFirstOrThrowArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$FolderPayload>;
        };
        findMany: {
          args: Prisma.FolderFindManyArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$FolderPayload>[];
        };
        create: {
          args: Prisma.FolderCreateArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$FolderPayload>;
        };
        createMany: {
          args: Prisma.FolderCreateManyArgs<ExtArgs>;
          result: BatchPayload;
        };
        createManyAndReturn: {
          args: Prisma.FolderCreateManyAndReturnArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$FolderPayload>[];
        };
        delete: {
          args: Prisma.FolderDeleteArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$FolderPayload>;
        };
        update: {
          args: Prisma.FolderUpdateArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$FolderPayload>;
        };
        deleteMany: {
          args: Prisma.FolderDeleteManyArgs<ExtArgs>;
          result: BatchPayload;
        };
        updateMany: {
          args: Prisma.FolderUpdateManyArgs<ExtArgs>;
          result: BatchPayload;
        };
        updateManyAndReturn: {
          args: Prisma.FolderUpdateManyAndReturnArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$FolderPayload>[];
        };
        upsert: {
          args: Prisma.FolderUpsertArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$FolderPayload>;
        };
        aggregate: {
          args: Prisma.FolderAggregateArgs<ExtArgs>;
          result: runtime.Types.Utils.Optional<Prisma.AggregateFolder>;
        };
        groupBy: {
          args: Prisma.FolderGroupByArgs<ExtArgs>;
          result: runtime.Types.Utils.Optional<Prisma.FolderGroupByOutputType>[];
        };
        count: {
          args: Prisma.FolderCountArgs<ExtArgs>;
          result:
            | runtime.Types.Utils.Optional<Prisma.FolderCountAggregateOutputType>
            | number;
        };
      };
    };
    Clinic: {
      payload: Prisma.$ClinicPayload<ExtArgs>;
      fields: Prisma.ClinicFieldRefs;
      operations: {
        findUnique: {
          args: Prisma.ClinicFindUniqueArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ClinicPayload> | null;
        };
        findUniqueOrThrow: {
          args: Prisma.ClinicFindUniqueOrThrowArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ClinicPayload>;
        };
        findFirst: {
          args: Prisma.ClinicFindFirstArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ClinicPayload> | null;
        };
        findFirstOrThrow: {
          args: Prisma.ClinicFindFirstOrThrowArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ClinicPayload>;
        };
        findMany: {
          args: Prisma.ClinicFindManyArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ClinicPayload>[];
        };
        create: {
          args: Prisma.ClinicCreateArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ClinicPayload>;
        };
        createMany: {
          args: Prisma.ClinicCreateManyArgs<ExtArgs>;
          result: BatchPayload;
        };
        createManyAndReturn: {
          args: Prisma.ClinicCreateManyAndReturnArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ClinicPayload>[];
        };
        delete: {
          args: Prisma.ClinicDeleteArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ClinicPayload>;
        };
        update: {
          args: Prisma.ClinicUpdateArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ClinicPayload>;
        };
        deleteMany: {
          args: Prisma.ClinicDeleteManyArgs<ExtArgs>;
          result: BatchPayload;
        };
        updateMany: {
          args: Prisma.ClinicUpdateManyArgs<ExtArgs>;
          result: BatchPayload;
        };
        updateManyAndReturn: {
          args: Prisma.ClinicUpdateManyAndReturnArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ClinicPayload>[];
        };
        upsert: {
          args: Prisma.ClinicUpsertArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ClinicPayload>;
        };
        aggregate: {
          args: Prisma.ClinicAggregateArgs<ExtArgs>;
          result: runtime.Types.Utils.Optional<Prisma.AggregateClinic>;
        };
        groupBy: {
          args: Prisma.ClinicGroupByArgs<ExtArgs>;
          result: runtime.Types.Utils.Optional<Prisma.ClinicGroupByOutputType>[];
        };
        count: {
          args: Prisma.ClinicCountArgs<ExtArgs>;
          result:
            | runtime.Types.Utils.Optional<Prisma.ClinicCountAggregateOutputType>
            | number;
        };
      };
    };
    Doctor: {
      payload: Prisma.$DoctorPayload<ExtArgs>;
      fields: Prisma.DoctorFieldRefs;
      operations: {
        findUnique: {
          args: Prisma.DoctorFindUniqueArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$DoctorPayload> | null;
        };
        findUniqueOrThrow: {
          args: Prisma.DoctorFindUniqueOrThrowArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$DoctorPayload>;
        };
        findFirst: {
          args: Prisma.DoctorFindFirstArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$DoctorPayload> | null;
        };
        findFirstOrThrow: {
          args: Prisma.DoctorFindFirstOrThrowArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$DoctorPayload>;
        };
        findMany: {
          args: Prisma.DoctorFindManyArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$DoctorPayload>[];
        };
        create: {
          args: Prisma.DoctorCreateArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$DoctorPayload>;
        };
        createMany: {
          args: Prisma.DoctorCreateManyArgs<ExtArgs>;
          result: BatchPayload;
        };
        createManyAndReturn: {
          args: Prisma.DoctorCreateManyAndReturnArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$DoctorPayload>[];
        };
        delete: {
          args: Prisma.DoctorDeleteArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$DoctorPayload>;
        };
        update: {
          args: Prisma.DoctorUpdateArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$DoctorPayload>;
        };
        deleteMany: {
          args: Prisma.DoctorDeleteManyArgs<ExtArgs>;
          result: BatchPayload;
        };
        updateMany: {
          args: Prisma.DoctorUpdateManyArgs<ExtArgs>;
          result: BatchPayload;
        };
        updateManyAndReturn: {
          args: Prisma.DoctorUpdateManyAndReturnArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$DoctorPayload>[];
        };
        upsert: {
          args: Prisma.DoctorUpsertArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$DoctorPayload>;
        };
        aggregate: {
          args: Prisma.DoctorAggregateArgs<ExtArgs>;
          result: runtime.Types.Utils.Optional<Prisma.AggregateDoctor>;
        };
        groupBy: {
          args: Prisma.DoctorGroupByArgs<ExtArgs>;
          result: runtime.Types.Utils.Optional<Prisma.DoctorGroupByOutputType>[];
        };
        count: {
          args: Prisma.DoctorCountArgs<ExtArgs>;
          result:
            | runtime.Types.Utils.Optional<Prisma.DoctorCountAggregateOutputType>
            | number;
        };
      };
    };
    WorkingDays: {
      payload: Prisma.$WorkingDaysPayload<ExtArgs>;
      fields: Prisma.WorkingDaysFieldRefs;
      operations: {
        findUnique: {
          args: Prisma.WorkingDaysFindUniqueArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$WorkingDaysPayload> | null;
        };
        findUniqueOrThrow: {
          args: Prisma.WorkingDaysFindUniqueOrThrowArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$WorkingDaysPayload>;
        };
        findFirst: {
          args: Prisma.WorkingDaysFindFirstArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$WorkingDaysPayload> | null;
        };
        findFirstOrThrow: {
          args: Prisma.WorkingDaysFindFirstOrThrowArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$WorkingDaysPayload>;
        };
        findMany: {
          args: Prisma.WorkingDaysFindManyArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$WorkingDaysPayload>[];
        };
        create: {
          args: Prisma.WorkingDaysCreateArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$WorkingDaysPayload>;
        };
        createMany: {
          args: Prisma.WorkingDaysCreateManyArgs<ExtArgs>;
          result: BatchPayload;
        };
        createManyAndReturn: {
          args: Prisma.WorkingDaysCreateManyAndReturnArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$WorkingDaysPayload>[];
        };
        delete: {
          args: Prisma.WorkingDaysDeleteArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$WorkingDaysPayload>;
        };
        update: {
          args: Prisma.WorkingDaysUpdateArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$WorkingDaysPayload>;
        };
        deleteMany: {
          args: Prisma.WorkingDaysDeleteManyArgs<ExtArgs>;
          result: BatchPayload;
        };
        updateMany: {
          args: Prisma.WorkingDaysUpdateManyArgs<ExtArgs>;
          result: BatchPayload;
        };
        updateManyAndReturn: {
          args: Prisma.WorkingDaysUpdateManyAndReturnArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$WorkingDaysPayload>[];
        };
        upsert: {
          args: Prisma.WorkingDaysUpsertArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$WorkingDaysPayload>;
        };
        aggregate: {
          args: Prisma.WorkingDaysAggregateArgs<ExtArgs>;
          result: runtime.Types.Utils.Optional<Prisma.AggregateWorkingDays>;
        };
        groupBy: {
          args: Prisma.WorkingDaysGroupByArgs<ExtArgs>;
          result: runtime.Types.Utils.Optional<Prisma.WorkingDaysGroupByOutputType>[];
        };
        count: {
          args: Prisma.WorkingDaysCountArgs<ExtArgs>;
          result:
            | runtime.Types.Utils.Optional<Prisma.WorkingDaysCountAggregateOutputType>
            | number;
        };
      };
    };
    Staff: {
      payload: Prisma.$StaffPayload<ExtArgs>;
      fields: Prisma.StaffFieldRefs;
      operations: {
        findUnique: {
          args: Prisma.StaffFindUniqueArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$StaffPayload> | null;
        };
        findUniqueOrThrow: {
          args: Prisma.StaffFindUniqueOrThrowArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$StaffPayload>;
        };
        findFirst: {
          args: Prisma.StaffFindFirstArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$StaffPayload> | null;
        };
        findFirstOrThrow: {
          args: Prisma.StaffFindFirstOrThrowArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$StaffPayload>;
        };
        findMany: {
          args: Prisma.StaffFindManyArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$StaffPayload>[];
        };
        create: {
          args: Prisma.StaffCreateArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$StaffPayload>;
        };
        createMany: {
          args: Prisma.StaffCreateManyArgs<ExtArgs>;
          result: BatchPayload;
        };
        createManyAndReturn: {
          args: Prisma.StaffCreateManyAndReturnArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$StaffPayload>[];
        };
        delete: {
          args: Prisma.StaffDeleteArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$StaffPayload>;
        };
        update: {
          args: Prisma.StaffUpdateArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$StaffPayload>;
        };
        deleteMany: {
          args: Prisma.StaffDeleteManyArgs<ExtArgs>;
          result: BatchPayload;
        };
        updateMany: {
          args: Prisma.StaffUpdateManyArgs<ExtArgs>;
          result: BatchPayload;
        };
        updateManyAndReturn: {
          args: Prisma.StaffUpdateManyAndReturnArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$StaffPayload>[];
        };
        upsert: {
          args: Prisma.StaffUpsertArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$StaffPayload>;
        };
        aggregate: {
          args: Prisma.StaffAggregateArgs<ExtArgs>;
          result: runtime.Types.Utils.Optional<Prisma.AggregateStaff>;
        };
        groupBy: {
          args: Prisma.StaffGroupByArgs<ExtArgs>;
          result: runtime.Types.Utils.Optional<Prisma.StaffGroupByOutputType>[];
        };
        count: {
          args: Prisma.StaffCountArgs<ExtArgs>;
          result:
            | runtime.Types.Utils.Optional<Prisma.StaffCountAggregateOutputType>
            | number;
        };
      };
    };
    Payment: {
      payload: Prisma.$PaymentPayload<ExtArgs>;
      fields: Prisma.PaymentFieldRefs;
      operations: {
        findUnique: {
          args: Prisma.PaymentFindUniqueArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PaymentPayload> | null;
        };
        findUniqueOrThrow: {
          args: Prisma.PaymentFindUniqueOrThrowArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PaymentPayload>;
        };
        findFirst: {
          args: Prisma.PaymentFindFirstArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PaymentPayload> | null;
        };
        findFirstOrThrow: {
          args: Prisma.PaymentFindFirstOrThrowArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PaymentPayload>;
        };
        findMany: {
          args: Prisma.PaymentFindManyArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PaymentPayload>[];
        };
        create: {
          args: Prisma.PaymentCreateArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PaymentPayload>;
        };
        createMany: {
          args: Prisma.PaymentCreateManyArgs<ExtArgs>;
          result: BatchPayload;
        };
        createManyAndReturn: {
          args: Prisma.PaymentCreateManyAndReturnArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PaymentPayload>[];
        };
        delete: {
          args: Prisma.PaymentDeleteArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PaymentPayload>;
        };
        update: {
          args: Prisma.PaymentUpdateArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PaymentPayload>;
        };
        deleteMany: {
          args: Prisma.PaymentDeleteManyArgs<ExtArgs>;
          result: BatchPayload;
        };
        updateMany: {
          args: Prisma.PaymentUpdateManyArgs<ExtArgs>;
          result: BatchPayload;
        };
        updateManyAndReturn: {
          args: Prisma.PaymentUpdateManyAndReturnArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PaymentPayload>[];
        };
        upsert: {
          args: Prisma.PaymentUpsertArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PaymentPayload>;
        };
        aggregate: {
          args: Prisma.PaymentAggregateArgs<ExtArgs>;
          result: runtime.Types.Utils.Optional<Prisma.AggregatePayment>;
        };
        groupBy: {
          args: Prisma.PaymentGroupByArgs<ExtArgs>;
          result: runtime.Types.Utils.Optional<Prisma.PaymentGroupByOutputType>[];
        };
        count: {
          args: Prisma.PaymentCountArgs<ExtArgs>;
          result:
            | runtime.Types.Utils.Optional<Prisma.PaymentCountAggregateOutputType>
            | number;
        };
      };
    };
    Reminder: {
      payload: Prisma.$ReminderPayload<ExtArgs>;
      fields: Prisma.ReminderFieldRefs;
      operations: {
        findUnique: {
          args: Prisma.ReminderFindUniqueArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ReminderPayload> | null;
        };
        findUniqueOrThrow: {
          args: Prisma.ReminderFindUniqueOrThrowArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ReminderPayload>;
        };
        findFirst: {
          args: Prisma.ReminderFindFirstArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ReminderPayload> | null;
        };
        findFirstOrThrow: {
          args: Prisma.ReminderFindFirstOrThrowArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ReminderPayload>;
        };
        findMany: {
          args: Prisma.ReminderFindManyArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ReminderPayload>[];
        };
        create: {
          args: Prisma.ReminderCreateArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ReminderPayload>;
        };
        createMany: {
          args: Prisma.ReminderCreateManyArgs<ExtArgs>;
          result: BatchPayload;
        };
        createManyAndReturn: {
          args: Prisma.ReminderCreateManyAndReturnArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ReminderPayload>[];
        };
        delete: {
          args: Prisma.ReminderDeleteArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ReminderPayload>;
        };
        update: {
          args: Prisma.ReminderUpdateArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ReminderPayload>;
        };
        deleteMany: {
          args: Prisma.ReminderDeleteManyArgs<ExtArgs>;
          result: BatchPayload;
        };
        updateMany: {
          args: Prisma.ReminderUpdateManyArgs<ExtArgs>;
          result: BatchPayload;
        };
        updateManyAndReturn: {
          args: Prisma.ReminderUpdateManyAndReturnArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ReminderPayload>[];
        };
        upsert: {
          args: Prisma.ReminderUpsertArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ReminderPayload>;
        };
        aggregate: {
          args: Prisma.ReminderAggregateArgs<ExtArgs>;
          result: runtime.Types.Utils.Optional<Prisma.AggregateReminder>;
        };
        groupBy: {
          args: Prisma.ReminderGroupByArgs<ExtArgs>;
          result: runtime.Types.Utils.Optional<Prisma.ReminderGroupByOutputType>[];
        };
        count: {
          args: Prisma.ReminderCountArgs<ExtArgs>;
          result:
            | runtime.Types.Utils.Optional<Prisma.ReminderCountAggregateOutputType>
            | number;
        };
      };
    };
    PatientBill: {
      payload: Prisma.$PatientBillPayload<ExtArgs>;
      fields: Prisma.PatientBillFieldRefs;
      operations: {
        findUnique: {
          args: Prisma.PatientBillFindUniqueArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PatientBillPayload> | null;
        };
        findUniqueOrThrow: {
          args: Prisma.PatientBillFindUniqueOrThrowArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PatientBillPayload>;
        };
        findFirst: {
          args: Prisma.PatientBillFindFirstArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PatientBillPayload> | null;
        };
        findFirstOrThrow: {
          args: Prisma.PatientBillFindFirstOrThrowArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PatientBillPayload>;
        };
        findMany: {
          args: Prisma.PatientBillFindManyArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PatientBillPayload>[];
        };
        create: {
          args: Prisma.PatientBillCreateArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PatientBillPayload>;
        };
        createMany: {
          args: Prisma.PatientBillCreateManyArgs<ExtArgs>;
          result: BatchPayload;
        };
        createManyAndReturn: {
          args: Prisma.PatientBillCreateManyAndReturnArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PatientBillPayload>[];
        };
        delete: {
          args: Prisma.PatientBillDeleteArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PatientBillPayload>;
        };
        update: {
          args: Prisma.PatientBillUpdateArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PatientBillPayload>;
        };
        deleteMany: {
          args: Prisma.PatientBillDeleteManyArgs<ExtArgs>;
          result: BatchPayload;
        };
        updateMany: {
          args: Prisma.PatientBillUpdateManyArgs<ExtArgs>;
          result: BatchPayload;
        };
        updateManyAndReturn: {
          args: Prisma.PatientBillUpdateManyAndReturnArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PatientBillPayload>[];
        };
        upsert: {
          args: Prisma.PatientBillUpsertArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PatientBillPayload>;
        };
        aggregate: {
          args: Prisma.PatientBillAggregateArgs<ExtArgs>;
          result: runtime.Types.Utils.Optional<Prisma.AggregatePatientBill>;
        };
        groupBy: {
          args: Prisma.PatientBillGroupByArgs<ExtArgs>;
          result: runtime.Types.Utils.Optional<Prisma.PatientBillGroupByOutputType>[];
        };
        count: {
          args: Prisma.PatientBillCountArgs<ExtArgs>;
          result:
            | runtime.Types.Utils.Optional<Prisma.PatientBillCountAggregateOutputType>
            | number;
        };
      };
    };
    Service: {
      payload: Prisma.$ServicePayload<ExtArgs>;
      fields: Prisma.ServiceFieldRefs;
      operations: {
        findUnique: {
          args: Prisma.ServiceFindUniqueArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ServicePayload> | null;
        };
        findUniqueOrThrow: {
          args: Prisma.ServiceFindUniqueOrThrowArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ServicePayload>;
        };
        findFirst: {
          args: Prisma.ServiceFindFirstArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ServicePayload> | null;
        };
        findFirstOrThrow: {
          args: Prisma.ServiceFindFirstOrThrowArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ServicePayload>;
        };
        findMany: {
          args: Prisma.ServiceFindManyArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ServicePayload>[];
        };
        create: {
          args: Prisma.ServiceCreateArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ServicePayload>;
        };
        createMany: {
          args: Prisma.ServiceCreateManyArgs<ExtArgs>;
          result: BatchPayload;
        };
        createManyAndReturn: {
          args: Prisma.ServiceCreateManyAndReturnArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ServicePayload>[];
        };
        delete: {
          args: Prisma.ServiceDeleteArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ServicePayload>;
        };
        update: {
          args: Prisma.ServiceUpdateArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ServicePayload>;
        };
        deleteMany: {
          args: Prisma.ServiceDeleteManyArgs<ExtArgs>;
          result: BatchPayload;
        };
        updateMany: {
          args: Prisma.ServiceUpdateManyArgs<ExtArgs>;
          result: BatchPayload;
        };
        updateManyAndReturn: {
          args: Prisma.ServiceUpdateManyAndReturnArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ServicePayload>[];
        };
        upsert: {
          args: Prisma.ServiceUpsertArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ServicePayload>;
        };
        aggregate: {
          args: Prisma.ServiceAggregateArgs<ExtArgs>;
          result: runtime.Types.Utils.Optional<Prisma.AggregateService>;
        };
        groupBy: {
          args: Prisma.ServiceGroupByArgs<ExtArgs>;
          result: runtime.Types.Utils.Optional<Prisma.ServiceGroupByOutputType>[];
        };
        count: {
          args: Prisma.ServiceCountArgs<ExtArgs>;
          result:
            | runtime.Types.Utils.Optional<Prisma.ServiceCountAggregateOutputType>
            | number;
        };
      };
    };
    ClinicSetting: {
      payload: Prisma.$ClinicSettingPayload<ExtArgs>;
      fields: Prisma.ClinicSettingFieldRefs;
      operations: {
        findUnique: {
          args: Prisma.ClinicSettingFindUniqueArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ClinicSettingPayload> | null;
        };
        findUniqueOrThrow: {
          args: Prisma.ClinicSettingFindUniqueOrThrowArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ClinicSettingPayload>;
        };
        findFirst: {
          args: Prisma.ClinicSettingFindFirstArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ClinicSettingPayload> | null;
        };
        findFirstOrThrow: {
          args: Prisma.ClinicSettingFindFirstOrThrowArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ClinicSettingPayload>;
        };
        findMany: {
          args: Prisma.ClinicSettingFindManyArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ClinicSettingPayload>[];
        };
        create: {
          args: Prisma.ClinicSettingCreateArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ClinicSettingPayload>;
        };
        createMany: {
          args: Prisma.ClinicSettingCreateManyArgs<ExtArgs>;
          result: BatchPayload;
        };
        createManyAndReturn: {
          args: Prisma.ClinicSettingCreateManyAndReturnArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ClinicSettingPayload>[];
        };
        delete: {
          args: Prisma.ClinicSettingDeleteArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ClinicSettingPayload>;
        };
        update: {
          args: Prisma.ClinicSettingUpdateArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ClinicSettingPayload>;
        };
        deleteMany: {
          args: Prisma.ClinicSettingDeleteManyArgs<ExtArgs>;
          result: BatchPayload;
        };
        updateMany: {
          args: Prisma.ClinicSettingUpdateManyArgs<ExtArgs>;
          result: BatchPayload;
        };
        updateManyAndReturn: {
          args: Prisma.ClinicSettingUpdateManyAndReturnArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ClinicSettingPayload>[];
        };
        upsert: {
          args: Prisma.ClinicSettingUpsertArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ClinicSettingPayload>;
        };
        aggregate: {
          args: Prisma.ClinicSettingAggregateArgs<ExtArgs>;
          result: runtime.Types.Utils.Optional<Prisma.AggregateClinicSetting>;
        };
        groupBy: {
          args: Prisma.ClinicSettingGroupByArgs<ExtArgs>;
          result: runtime.Types.Utils.Optional<Prisma.ClinicSettingGroupByOutputType>[];
        };
        count: {
          args: Prisma.ClinicSettingCountArgs<ExtArgs>;
          result:
            | runtime.Types.Utils.Optional<Prisma.ClinicSettingCountAggregateOutputType>
            | number;
        };
      };
    };
    WHOGrowthStandard: {
      payload: Prisma.$WHOGrowthStandardPayload<ExtArgs>;
      fields: Prisma.WHOGrowthStandardFieldRefs;
      operations: {
        findUnique: {
          args: Prisma.WHOGrowthStandardFindUniqueArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$WHOGrowthStandardPayload> | null;
        };
        findUniqueOrThrow: {
          args: Prisma.WHOGrowthStandardFindUniqueOrThrowArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$WHOGrowthStandardPayload>;
        };
        findFirst: {
          args: Prisma.WHOGrowthStandardFindFirstArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$WHOGrowthStandardPayload> | null;
        };
        findFirstOrThrow: {
          args: Prisma.WHOGrowthStandardFindFirstOrThrowArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$WHOGrowthStandardPayload>;
        };
        findMany: {
          args: Prisma.WHOGrowthStandardFindManyArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$WHOGrowthStandardPayload>[];
        };
        create: {
          args: Prisma.WHOGrowthStandardCreateArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$WHOGrowthStandardPayload>;
        };
        createMany: {
          args: Prisma.WHOGrowthStandardCreateManyArgs<ExtArgs>;
          result: BatchPayload;
        };
        createManyAndReturn: {
          args: Prisma.WHOGrowthStandardCreateManyAndReturnArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$WHOGrowthStandardPayload>[];
        };
        delete: {
          args: Prisma.WHOGrowthStandardDeleteArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$WHOGrowthStandardPayload>;
        };
        update: {
          args: Prisma.WHOGrowthStandardUpdateArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$WHOGrowthStandardPayload>;
        };
        deleteMany: {
          args: Prisma.WHOGrowthStandardDeleteManyArgs<ExtArgs>;
          result: BatchPayload;
        };
        updateMany: {
          args: Prisma.WHOGrowthStandardUpdateManyArgs<ExtArgs>;
          result: BatchPayload;
        };
        updateManyAndReturn: {
          args: Prisma.WHOGrowthStandardUpdateManyAndReturnArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$WHOGrowthStandardPayload>[];
        };
        upsert: {
          args: Prisma.WHOGrowthStandardUpsertArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$WHOGrowthStandardPayload>;
        };
        aggregate: {
          args: Prisma.WHOGrowthStandardAggregateArgs<ExtArgs>;
          result: runtime.Types.Utils.Optional<Prisma.AggregateWHOGrowthStandard>;
        };
        groupBy: {
          args: Prisma.WHOGrowthStandardGroupByArgs<ExtArgs>;
          result: runtime.Types.Utils.Optional<Prisma.WHOGrowthStandardGroupByOutputType>[];
        };
        count: {
          args: Prisma.WHOGrowthStandardCountArgs<ExtArgs>;
          result:
            | runtime.Types.Utils.Optional<Prisma.WHOGrowthStandardCountAggregateOutputType>
            | number;
        };
      };
    };
    Rating: {
      payload: Prisma.$RatingPayload<ExtArgs>;
      fields: Prisma.RatingFieldRefs;
      operations: {
        findUnique: {
          args: Prisma.RatingFindUniqueArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$RatingPayload> | null;
        };
        findUniqueOrThrow: {
          args: Prisma.RatingFindUniqueOrThrowArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$RatingPayload>;
        };
        findFirst: {
          args: Prisma.RatingFindFirstArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$RatingPayload> | null;
        };
        findFirstOrThrow: {
          args: Prisma.RatingFindFirstOrThrowArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$RatingPayload>;
        };
        findMany: {
          args: Prisma.RatingFindManyArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$RatingPayload>[];
        };
        create: {
          args: Prisma.RatingCreateArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$RatingPayload>;
        };
        createMany: {
          args: Prisma.RatingCreateManyArgs<ExtArgs>;
          result: BatchPayload;
        };
        createManyAndReturn: {
          args: Prisma.RatingCreateManyAndReturnArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$RatingPayload>[];
        };
        delete: {
          args: Prisma.RatingDeleteArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$RatingPayload>;
        };
        update: {
          args: Prisma.RatingUpdateArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$RatingPayload>;
        };
        deleteMany: {
          args: Prisma.RatingDeleteManyArgs<ExtArgs>;
          result: BatchPayload;
        };
        updateMany: {
          args: Prisma.RatingUpdateManyArgs<ExtArgs>;
          result: BatchPayload;
        };
        updateManyAndReturn: {
          args: Prisma.RatingUpdateManyAndReturnArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$RatingPayload>[];
        };
        upsert: {
          args: Prisma.RatingUpsertArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$RatingPayload>;
        };
        aggregate: {
          args: Prisma.RatingAggregateArgs<ExtArgs>;
          result: runtime.Types.Utils.Optional<Prisma.AggregateRating>;
        };
        groupBy: {
          args: Prisma.RatingGroupByArgs<ExtArgs>;
          result: runtime.Types.Utils.Optional<Prisma.RatingGroupByOutputType>[];
        };
        count: {
          args: Prisma.RatingCountArgs<ExtArgs>;
          result:
            | runtime.Types.Utils.Optional<Prisma.RatingCountAggregateOutputType>
            | number;
        };
      };
    };
    Prescription: {
      payload: Prisma.$PrescriptionPayload<ExtArgs>;
      fields: Prisma.PrescriptionFieldRefs;
      operations: {
        findUnique: {
          args: Prisma.PrescriptionFindUniqueArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PrescriptionPayload> | null;
        };
        findUniqueOrThrow: {
          args: Prisma.PrescriptionFindUniqueOrThrowArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PrescriptionPayload>;
        };
        findFirst: {
          args: Prisma.PrescriptionFindFirstArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PrescriptionPayload> | null;
        };
        findFirstOrThrow: {
          args: Prisma.PrescriptionFindFirstOrThrowArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PrescriptionPayload>;
        };
        findMany: {
          args: Prisma.PrescriptionFindManyArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PrescriptionPayload>[];
        };
        create: {
          args: Prisma.PrescriptionCreateArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PrescriptionPayload>;
        };
        createMany: {
          args: Prisma.PrescriptionCreateManyArgs<ExtArgs>;
          result: BatchPayload;
        };
        createManyAndReturn: {
          args: Prisma.PrescriptionCreateManyAndReturnArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PrescriptionPayload>[];
        };
        delete: {
          args: Prisma.PrescriptionDeleteArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PrescriptionPayload>;
        };
        update: {
          args: Prisma.PrescriptionUpdateArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PrescriptionPayload>;
        };
        deleteMany: {
          args: Prisma.PrescriptionDeleteManyArgs<ExtArgs>;
          result: BatchPayload;
        };
        updateMany: {
          args: Prisma.PrescriptionUpdateManyArgs<ExtArgs>;
          result: BatchPayload;
        };
        updateManyAndReturn: {
          args: Prisma.PrescriptionUpdateManyAndReturnArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PrescriptionPayload>[];
        };
        upsert: {
          args: Prisma.PrescriptionUpsertArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PrescriptionPayload>;
        };
        aggregate: {
          args: Prisma.PrescriptionAggregateArgs<ExtArgs>;
          result: runtime.Types.Utils.Optional<Prisma.AggregatePrescription>;
        };
        groupBy: {
          args: Prisma.PrescriptionGroupByArgs<ExtArgs>;
          result: runtime.Types.Utils.Optional<Prisma.PrescriptionGroupByOutputType>[];
        };
        count: {
          args: Prisma.PrescriptionCountArgs<ExtArgs>;
          result:
            | runtime.Types.Utils.Optional<Prisma.PrescriptionCountAggregateOutputType>
            | number;
        };
      };
    };
    Drug: {
      payload: Prisma.$DrugPayload<ExtArgs>;
      fields: Prisma.DrugFieldRefs;
      operations: {
        findUnique: {
          args: Prisma.DrugFindUniqueArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$DrugPayload> | null;
        };
        findUniqueOrThrow: {
          args: Prisma.DrugFindUniqueOrThrowArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$DrugPayload>;
        };
        findFirst: {
          args: Prisma.DrugFindFirstArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$DrugPayload> | null;
        };
        findFirstOrThrow: {
          args: Prisma.DrugFindFirstOrThrowArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$DrugPayload>;
        };
        findMany: {
          args: Prisma.DrugFindManyArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$DrugPayload>[];
        };
        create: {
          args: Prisma.DrugCreateArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$DrugPayload>;
        };
        createMany: {
          args: Prisma.DrugCreateManyArgs<ExtArgs>;
          result: BatchPayload;
        };
        createManyAndReturn: {
          args: Prisma.DrugCreateManyAndReturnArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$DrugPayload>[];
        };
        delete: {
          args: Prisma.DrugDeleteArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$DrugPayload>;
        };
        update: {
          args: Prisma.DrugUpdateArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$DrugPayload>;
        };
        deleteMany: {
          args: Prisma.DrugDeleteManyArgs<ExtArgs>;
          result: BatchPayload;
        };
        updateMany: {
          args: Prisma.DrugUpdateManyArgs<ExtArgs>;
          result: BatchPayload;
        };
        updateManyAndReturn: {
          args: Prisma.DrugUpdateManyAndReturnArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$DrugPayload>[];
        };
        upsert: {
          args: Prisma.DrugUpsertArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$DrugPayload>;
        };
        aggregate: {
          args: Prisma.DrugAggregateArgs<ExtArgs>;
          result: runtime.Types.Utils.Optional<Prisma.AggregateDrug>;
        };
        groupBy: {
          args: Prisma.DrugGroupByArgs<ExtArgs>;
          result: runtime.Types.Utils.Optional<Prisma.DrugGroupByOutputType>[];
        };
        count: {
          args: Prisma.DrugCountArgs<ExtArgs>;
          result:
            | runtime.Types.Utils.Optional<Prisma.DrugCountAggregateOutputType>
            | number;
        };
      };
    };
    DoseGuideline: {
      payload: Prisma.$DoseGuidelinePayload<ExtArgs>;
      fields: Prisma.DoseGuidelineFieldRefs;
      operations: {
        findUnique: {
          args: Prisma.DoseGuidelineFindUniqueArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$DoseGuidelinePayload> | null;
        };
        findUniqueOrThrow: {
          args: Prisma.DoseGuidelineFindUniqueOrThrowArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$DoseGuidelinePayload>;
        };
        findFirst: {
          args: Prisma.DoseGuidelineFindFirstArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$DoseGuidelinePayload> | null;
        };
        findFirstOrThrow: {
          args: Prisma.DoseGuidelineFindFirstOrThrowArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$DoseGuidelinePayload>;
        };
        findMany: {
          args: Prisma.DoseGuidelineFindManyArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$DoseGuidelinePayload>[];
        };
        create: {
          args: Prisma.DoseGuidelineCreateArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$DoseGuidelinePayload>;
        };
        createMany: {
          args: Prisma.DoseGuidelineCreateManyArgs<ExtArgs>;
          result: BatchPayload;
        };
        createManyAndReturn: {
          args: Prisma.DoseGuidelineCreateManyAndReturnArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$DoseGuidelinePayload>[];
        };
        delete: {
          args: Prisma.DoseGuidelineDeleteArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$DoseGuidelinePayload>;
        };
        update: {
          args: Prisma.DoseGuidelineUpdateArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$DoseGuidelinePayload>;
        };
        deleteMany: {
          args: Prisma.DoseGuidelineDeleteManyArgs<ExtArgs>;
          result: BatchPayload;
        };
        updateMany: {
          args: Prisma.DoseGuidelineUpdateManyArgs<ExtArgs>;
          result: BatchPayload;
        };
        updateManyAndReturn: {
          args: Prisma.DoseGuidelineUpdateManyAndReturnArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$DoseGuidelinePayload>[];
        };
        upsert: {
          args: Prisma.DoseGuidelineUpsertArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$DoseGuidelinePayload>;
        };
        aggregate: {
          args: Prisma.DoseGuidelineAggregateArgs<ExtArgs>;
          result: runtime.Types.Utils.Optional<Prisma.AggregateDoseGuideline>;
        };
        groupBy: {
          args: Prisma.DoseGuidelineGroupByArgs<ExtArgs>;
          result: runtime.Types.Utils.Optional<Prisma.DoseGuidelineGroupByOutputType>[];
        };
        count: {
          args: Prisma.DoseGuidelineCountArgs<ExtArgs>;
          result:
            | runtime.Types.Utils.Optional<Prisma.DoseGuidelineCountAggregateOutputType>
            | number;
        };
      };
    };
    PrescribedItem: {
      payload: Prisma.$PrescribedItemPayload<ExtArgs>;
      fields: Prisma.PrescribedItemFieldRefs;
      operations: {
        findUnique: {
          args: Prisma.PrescribedItemFindUniqueArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PrescribedItemPayload> | null;
        };
        findUniqueOrThrow: {
          args: Prisma.PrescribedItemFindUniqueOrThrowArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PrescribedItemPayload>;
        };
        findFirst: {
          args: Prisma.PrescribedItemFindFirstArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PrescribedItemPayload> | null;
        };
        findFirstOrThrow: {
          args: Prisma.PrescribedItemFindFirstOrThrowArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PrescribedItemPayload>;
        };
        findMany: {
          args: Prisma.PrescribedItemFindManyArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PrescribedItemPayload>[];
        };
        create: {
          args: Prisma.PrescribedItemCreateArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PrescribedItemPayload>;
        };
        createMany: {
          args: Prisma.PrescribedItemCreateManyArgs<ExtArgs>;
          result: BatchPayload;
        };
        createManyAndReturn: {
          args: Prisma.PrescribedItemCreateManyAndReturnArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PrescribedItemPayload>[];
        };
        delete: {
          args: Prisma.PrescribedItemDeleteArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PrescribedItemPayload>;
        };
        update: {
          args: Prisma.PrescribedItemUpdateArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PrescribedItemPayload>;
        };
        deleteMany: {
          args: Prisma.PrescribedItemDeleteManyArgs<ExtArgs>;
          result: BatchPayload;
        };
        updateMany: {
          args: Prisma.PrescribedItemUpdateManyArgs<ExtArgs>;
          result: BatchPayload;
        };
        updateManyAndReturn: {
          args: Prisma.PrescribedItemUpdateManyAndReturnArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PrescribedItemPayload>[];
        };
        upsert: {
          args: Prisma.PrescribedItemUpsertArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PrescribedItemPayload>;
        };
        aggregate: {
          args: Prisma.PrescribedItemAggregateArgs<ExtArgs>;
          result: runtime.Types.Utils.Optional<Prisma.AggregatePrescribedItem>;
        };
        groupBy: {
          args: Prisma.PrescribedItemGroupByArgs<ExtArgs>;
          result: runtime.Types.Utils.Optional<Prisma.PrescribedItemGroupByOutputType>[];
        };
        count: {
          args: Prisma.PrescribedItemCountArgs<ExtArgs>;
          result:
            | runtime.Types.Utils.Optional<Prisma.PrescribedItemCountAggregateOutputType>
            | number;
        };
      };
    };
    Guardian: {
      payload: Prisma.$GuardianPayload<ExtArgs>;
      fields: Prisma.GuardianFieldRefs;
      operations: {
        findUnique: {
          args: Prisma.GuardianFindUniqueArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$GuardianPayload> | null;
        };
        findUniqueOrThrow: {
          args: Prisma.GuardianFindUniqueOrThrowArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$GuardianPayload>;
        };
        findFirst: {
          args: Prisma.GuardianFindFirstArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$GuardianPayload> | null;
        };
        findFirstOrThrow: {
          args: Prisma.GuardianFindFirstOrThrowArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$GuardianPayload>;
        };
        findMany: {
          args: Prisma.GuardianFindManyArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$GuardianPayload>[];
        };
        create: {
          args: Prisma.GuardianCreateArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$GuardianPayload>;
        };
        createMany: {
          args: Prisma.GuardianCreateManyArgs<ExtArgs>;
          result: BatchPayload;
        };
        createManyAndReturn: {
          args: Prisma.GuardianCreateManyAndReturnArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$GuardianPayload>[];
        };
        delete: {
          args: Prisma.GuardianDeleteArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$GuardianPayload>;
        };
        update: {
          args: Prisma.GuardianUpdateArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$GuardianPayload>;
        };
        deleteMany: {
          args: Prisma.GuardianDeleteManyArgs<ExtArgs>;
          result: BatchPayload;
        };
        updateMany: {
          args: Prisma.GuardianUpdateManyArgs<ExtArgs>;
          result: BatchPayload;
        };
        updateManyAndReturn: {
          args: Prisma.GuardianUpdateManyAndReturnArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$GuardianPayload>[];
        };
        upsert: {
          args: Prisma.GuardianUpsertArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$GuardianPayload>;
        };
        aggregate: {
          args: Prisma.GuardianAggregateArgs<ExtArgs>;
          result: runtime.Types.Utils.Optional<Prisma.AggregateGuardian>;
        };
        groupBy: {
          args: Prisma.GuardianGroupByArgs<ExtArgs>;
          result: runtime.Types.Utils.Optional<Prisma.GuardianGroupByOutputType>[];
        };
        count: {
          args: Prisma.GuardianCountArgs<ExtArgs>;
          result:
            | runtime.Types.Utils.Optional<Prisma.GuardianCountAggregateOutputType>
            | number;
        };
      };
    };
    Patient: {
      payload: Prisma.$PatientPayload<ExtArgs>;
      fields: Prisma.PatientFieldRefs;
      operations: {
        findUnique: {
          args: Prisma.PatientFindUniqueArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PatientPayload> | null;
        };
        findUniqueOrThrow: {
          args: Prisma.PatientFindUniqueOrThrowArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PatientPayload>;
        };
        findFirst: {
          args: Prisma.PatientFindFirstArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PatientPayload> | null;
        };
        findFirstOrThrow: {
          args: Prisma.PatientFindFirstOrThrowArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PatientPayload>;
        };
        findMany: {
          args: Prisma.PatientFindManyArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PatientPayload>[];
        };
        create: {
          args: Prisma.PatientCreateArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PatientPayload>;
        };
        createMany: {
          args: Prisma.PatientCreateManyArgs<ExtArgs>;
          result: BatchPayload;
        };
        createManyAndReturn: {
          args: Prisma.PatientCreateManyAndReturnArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PatientPayload>[];
        };
        delete: {
          args: Prisma.PatientDeleteArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PatientPayload>;
        };
        update: {
          args: Prisma.PatientUpdateArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PatientPayload>;
        };
        deleteMany: {
          args: Prisma.PatientDeleteManyArgs<ExtArgs>;
          result: BatchPayload;
        };
        updateMany: {
          args: Prisma.PatientUpdateManyArgs<ExtArgs>;
          result: BatchPayload;
        };
        updateManyAndReturn: {
          args: Prisma.PatientUpdateManyAndReturnArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PatientPayload>[];
        };
        upsert: {
          args: Prisma.PatientUpsertArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PatientPayload>;
        };
        aggregate: {
          args: Prisma.PatientAggregateArgs<ExtArgs>;
          result: runtime.Types.Utils.Optional<Prisma.AggregatePatient>;
        };
        groupBy: {
          args: Prisma.PatientGroupByArgs<ExtArgs>;
          result: runtime.Types.Utils.Optional<Prisma.PatientGroupByOutputType>[];
        };
        count: {
          args: Prisma.PatientCountArgs<ExtArgs>;
          result:
            | runtime.Types.Utils.Optional<Prisma.PatientCountAggregateOutputType>
            | number;
        };
      };
    };
    Appointment: {
      payload: Prisma.$AppointmentPayload<ExtArgs>;
      fields: Prisma.AppointmentFieldRefs;
      operations: {
        findUnique: {
          args: Prisma.AppointmentFindUniqueArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AppointmentPayload> | null;
        };
        findUniqueOrThrow: {
          args: Prisma.AppointmentFindUniqueOrThrowArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AppointmentPayload>;
        };
        findFirst: {
          args: Prisma.AppointmentFindFirstArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AppointmentPayload> | null;
        };
        findFirstOrThrow: {
          args: Prisma.AppointmentFindFirstOrThrowArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AppointmentPayload>;
        };
        findMany: {
          args: Prisma.AppointmentFindManyArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AppointmentPayload>[];
        };
        create: {
          args: Prisma.AppointmentCreateArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AppointmentPayload>;
        };
        createMany: {
          args: Prisma.AppointmentCreateManyArgs<ExtArgs>;
          result: BatchPayload;
        };
        createManyAndReturn: {
          args: Prisma.AppointmentCreateManyAndReturnArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AppointmentPayload>[];
        };
        delete: {
          args: Prisma.AppointmentDeleteArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AppointmentPayload>;
        };
        update: {
          args: Prisma.AppointmentUpdateArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AppointmentPayload>;
        };
        deleteMany: {
          args: Prisma.AppointmentDeleteManyArgs<ExtArgs>;
          result: BatchPayload;
        };
        updateMany: {
          args: Prisma.AppointmentUpdateManyArgs<ExtArgs>;
          result: BatchPayload;
        };
        updateManyAndReturn: {
          args: Prisma.AppointmentUpdateManyAndReturnArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AppointmentPayload>[];
        };
        upsert: {
          args: Prisma.AppointmentUpsertArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AppointmentPayload>;
        };
        aggregate: {
          args: Prisma.AppointmentAggregateArgs<ExtArgs>;
          result: runtime.Types.Utils.Optional<Prisma.AggregateAppointment>;
        };
        groupBy: {
          args: Prisma.AppointmentGroupByArgs<ExtArgs>;
          result: runtime.Types.Utils.Optional<Prisma.AppointmentGroupByOutputType>[];
        };
        count: {
          args: Prisma.AppointmentCountArgs<ExtArgs>;
          result:
            | runtime.Types.Utils.Optional<Prisma.AppointmentCountAggregateOutputType>
            | number;
        };
      };
    };
    MedicalRecords: {
      payload: Prisma.$MedicalRecordsPayload<ExtArgs>;
      fields: Prisma.MedicalRecordsFieldRefs;
      operations: {
        findUnique: {
          args: Prisma.MedicalRecordsFindUniqueArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$MedicalRecordsPayload> | null;
        };
        findUniqueOrThrow: {
          args: Prisma.MedicalRecordsFindUniqueOrThrowArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$MedicalRecordsPayload>;
        };
        findFirst: {
          args: Prisma.MedicalRecordsFindFirstArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$MedicalRecordsPayload> | null;
        };
        findFirstOrThrow: {
          args: Prisma.MedicalRecordsFindFirstOrThrowArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$MedicalRecordsPayload>;
        };
        findMany: {
          args: Prisma.MedicalRecordsFindManyArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$MedicalRecordsPayload>[];
        };
        create: {
          args: Prisma.MedicalRecordsCreateArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$MedicalRecordsPayload>;
        };
        createMany: {
          args: Prisma.MedicalRecordsCreateManyArgs<ExtArgs>;
          result: BatchPayload;
        };
        createManyAndReturn: {
          args: Prisma.MedicalRecordsCreateManyAndReturnArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$MedicalRecordsPayload>[];
        };
        delete: {
          args: Prisma.MedicalRecordsDeleteArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$MedicalRecordsPayload>;
        };
        update: {
          args: Prisma.MedicalRecordsUpdateArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$MedicalRecordsPayload>;
        };
        deleteMany: {
          args: Prisma.MedicalRecordsDeleteManyArgs<ExtArgs>;
          result: BatchPayload;
        };
        updateMany: {
          args: Prisma.MedicalRecordsUpdateManyArgs<ExtArgs>;
          result: BatchPayload;
        };
        updateManyAndReturn: {
          args: Prisma.MedicalRecordsUpdateManyAndReturnArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$MedicalRecordsPayload>[];
        };
        upsert: {
          args: Prisma.MedicalRecordsUpsertArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$MedicalRecordsPayload>;
        };
        aggregate: {
          args: Prisma.MedicalRecordsAggregateArgs<ExtArgs>;
          result: runtime.Types.Utils.Optional<Prisma.AggregateMedicalRecords>;
        };
        groupBy: {
          args: Prisma.MedicalRecordsGroupByArgs<ExtArgs>;
          result: runtime.Types.Utils.Optional<Prisma.MedicalRecordsGroupByOutputType>[];
        };
        count: {
          args: Prisma.MedicalRecordsCountArgs<ExtArgs>;
          result:
            | runtime.Types.Utils.Optional<Prisma.MedicalRecordsCountAggregateOutputType>
            | number;
        };
      };
    };
    MedicalRecordAccess: {
      payload: Prisma.$MedicalRecordAccessPayload<ExtArgs>;
      fields: Prisma.MedicalRecordAccessFieldRefs;
      operations: {
        findUnique: {
          args: Prisma.MedicalRecordAccessFindUniqueArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$MedicalRecordAccessPayload> | null;
        };
        findUniqueOrThrow: {
          args: Prisma.MedicalRecordAccessFindUniqueOrThrowArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$MedicalRecordAccessPayload>;
        };
        findFirst: {
          args: Prisma.MedicalRecordAccessFindFirstArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$MedicalRecordAccessPayload> | null;
        };
        findFirstOrThrow: {
          args: Prisma.MedicalRecordAccessFindFirstOrThrowArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$MedicalRecordAccessPayload>;
        };
        findMany: {
          args: Prisma.MedicalRecordAccessFindManyArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$MedicalRecordAccessPayload>[];
        };
        create: {
          args: Prisma.MedicalRecordAccessCreateArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$MedicalRecordAccessPayload>;
        };
        createMany: {
          args: Prisma.MedicalRecordAccessCreateManyArgs<ExtArgs>;
          result: BatchPayload;
        };
        createManyAndReturn: {
          args: Prisma.MedicalRecordAccessCreateManyAndReturnArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$MedicalRecordAccessPayload>[];
        };
        delete: {
          args: Prisma.MedicalRecordAccessDeleteArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$MedicalRecordAccessPayload>;
        };
        update: {
          args: Prisma.MedicalRecordAccessUpdateArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$MedicalRecordAccessPayload>;
        };
        deleteMany: {
          args: Prisma.MedicalRecordAccessDeleteManyArgs<ExtArgs>;
          result: BatchPayload;
        };
        updateMany: {
          args: Prisma.MedicalRecordAccessUpdateManyArgs<ExtArgs>;
          result: BatchPayload;
        };
        updateManyAndReturn: {
          args: Prisma.MedicalRecordAccessUpdateManyAndReturnArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$MedicalRecordAccessPayload>[];
        };
        upsert: {
          args: Prisma.MedicalRecordAccessUpsertArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$MedicalRecordAccessPayload>;
        };
        aggregate: {
          args: Prisma.MedicalRecordAccessAggregateArgs<ExtArgs>;
          result: runtime.Types.Utils.Optional<Prisma.AggregateMedicalRecordAccess>;
        };
        groupBy: {
          args: Prisma.MedicalRecordAccessGroupByArgs<ExtArgs>;
          result: runtime.Types.Utils.Optional<Prisma.MedicalRecordAccessGroupByOutputType>[];
        };
        count: {
          args: Prisma.MedicalRecordAccessCountArgs<ExtArgs>;
          result:
            | runtime.Types.Utils.Optional<Prisma.MedicalRecordAccessCountAggregateOutputType>
            | number;
        };
      };
    };
    Diagnosis: {
      payload: Prisma.$DiagnosisPayload<ExtArgs>;
      fields: Prisma.DiagnosisFieldRefs;
      operations: {
        findUnique: {
          args: Prisma.DiagnosisFindUniqueArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$DiagnosisPayload> | null;
        };
        findUniqueOrThrow: {
          args: Prisma.DiagnosisFindUniqueOrThrowArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$DiagnosisPayload>;
        };
        findFirst: {
          args: Prisma.DiagnosisFindFirstArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$DiagnosisPayload> | null;
        };
        findFirstOrThrow: {
          args: Prisma.DiagnosisFindFirstOrThrowArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$DiagnosisPayload>;
        };
        findMany: {
          args: Prisma.DiagnosisFindManyArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$DiagnosisPayload>[];
        };
        create: {
          args: Prisma.DiagnosisCreateArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$DiagnosisPayload>;
        };
        createMany: {
          args: Prisma.DiagnosisCreateManyArgs<ExtArgs>;
          result: BatchPayload;
        };
        createManyAndReturn: {
          args: Prisma.DiagnosisCreateManyAndReturnArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$DiagnosisPayload>[];
        };
        delete: {
          args: Prisma.DiagnosisDeleteArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$DiagnosisPayload>;
        };
        update: {
          args: Prisma.DiagnosisUpdateArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$DiagnosisPayload>;
        };
        deleteMany: {
          args: Prisma.DiagnosisDeleteManyArgs<ExtArgs>;
          result: BatchPayload;
        };
        updateMany: {
          args: Prisma.DiagnosisUpdateManyArgs<ExtArgs>;
          result: BatchPayload;
        };
        updateManyAndReturn: {
          args: Prisma.DiagnosisUpdateManyAndReturnArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$DiagnosisPayload>[];
        };
        upsert: {
          args: Prisma.DiagnosisUpsertArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$DiagnosisPayload>;
        };
        aggregate: {
          args: Prisma.DiagnosisAggregateArgs<ExtArgs>;
          result: runtime.Types.Utils.Optional<Prisma.AggregateDiagnosis>;
        };
        groupBy: {
          args: Prisma.DiagnosisGroupByArgs<ExtArgs>;
          result: runtime.Types.Utils.Optional<Prisma.DiagnosisGroupByOutputType>[];
        };
        count: {
          args: Prisma.DiagnosisCountArgs<ExtArgs>;
          result:
            | runtime.Types.Utils.Optional<Prisma.DiagnosisCountAggregateOutputType>
            | number;
        };
      };
    };
    VitalSigns: {
      payload: Prisma.$VitalSignsPayload<ExtArgs>;
      fields: Prisma.VitalSignsFieldRefs;
      operations: {
        findUnique: {
          args: Prisma.VitalSignsFindUniqueArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$VitalSignsPayload> | null;
        };
        findUniqueOrThrow: {
          args: Prisma.VitalSignsFindUniqueOrThrowArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$VitalSignsPayload>;
        };
        findFirst: {
          args: Prisma.VitalSignsFindFirstArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$VitalSignsPayload> | null;
        };
        findFirstOrThrow: {
          args: Prisma.VitalSignsFindFirstOrThrowArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$VitalSignsPayload>;
        };
        findMany: {
          args: Prisma.VitalSignsFindManyArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$VitalSignsPayload>[];
        };
        create: {
          args: Prisma.VitalSignsCreateArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$VitalSignsPayload>;
        };
        createMany: {
          args: Prisma.VitalSignsCreateManyArgs<ExtArgs>;
          result: BatchPayload;
        };
        createManyAndReturn: {
          args: Prisma.VitalSignsCreateManyAndReturnArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$VitalSignsPayload>[];
        };
        delete: {
          args: Prisma.VitalSignsDeleteArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$VitalSignsPayload>;
        };
        update: {
          args: Prisma.VitalSignsUpdateArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$VitalSignsPayload>;
        };
        deleteMany: {
          args: Prisma.VitalSignsDeleteManyArgs<ExtArgs>;
          result: BatchPayload;
        };
        updateMany: {
          args: Prisma.VitalSignsUpdateManyArgs<ExtArgs>;
          result: BatchPayload;
        };
        updateManyAndReturn: {
          args: Prisma.VitalSignsUpdateManyAndReturnArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$VitalSignsPayload>[];
        };
        upsert: {
          args: Prisma.VitalSignsUpsertArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$VitalSignsPayload>;
        };
        aggregate: {
          args: Prisma.VitalSignsAggregateArgs<ExtArgs>;
          result: runtime.Types.Utils.Optional<Prisma.AggregateVitalSigns>;
        };
        groupBy: {
          args: Prisma.VitalSignsGroupByArgs<ExtArgs>;
          result: runtime.Types.Utils.Optional<Prisma.VitalSignsGroupByOutputType>[];
        };
        count: {
          args: Prisma.VitalSignsCountArgs<ExtArgs>;
          result:
            | runtime.Types.Utils.Optional<Prisma.VitalSignsCountAggregateOutputType>
            | number;
        };
      };
    };
    GrowthRecord: {
      payload: Prisma.$GrowthRecordPayload<ExtArgs>;
      fields: Prisma.GrowthRecordFieldRefs;
      operations: {
        findUnique: {
          args: Prisma.GrowthRecordFindUniqueArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$GrowthRecordPayload> | null;
        };
        findUniqueOrThrow: {
          args: Prisma.GrowthRecordFindUniqueOrThrowArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$GrowthRecordPayload>;
        };
        findFirst: {
          args: Prisma.GrowthRecordFindFirstArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$GrowthRecordPayload> | null;
        };
        findFirstOrThrow: {
          args: Prisma.GrowthRecordFindFirstOrThrowArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$GrowthRecordPayload>;
        };
        findMany: {
          args: Prisma.GrowthRecordFindManyArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$GrowthRecordPayload>[];
        };
        create: {
          args: Prisma.GrowthRecordCreateArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$GrowthRecordPayload>;
        };
        createMany: {
          args: Prisma.GrowthRecordCreateManyArgs<ExtArgs>;
          result: BatchPayload;
        };
        createManyAndReturn: {
          args: Prisma.GrowthRecordCreateManyAndReturnArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$GrowthRecordPayload>[];
        };
        delete: {
          args: Prisma.GrowthRecordDeleteArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$GrowthRecordPayload>;
        };
        update: {
          args: Prisma.GrowthRecordUpdateArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$GrowthRecordPayload>;
        };
        deleteMany: {
          args: Prisma.GrowthRecordDeleteManyArgs<ExtArgs>;
          result: BatchPayload;
        };
        updateMany: {
          args: Prisma.GrowthRecordUpdateManyArgs<ExtArgs>;
          result: BatchPayload;
        };
        updateManyAndReturn: {
          args: Prisma.GrowthRecordUpdateManyAndReturnArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$GrowthRecordPayload>[];
        };
        upsert: {
          args: Prisma.GrowthRecordUpsertArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$GrowthRecordPayload>;
        };
        aggregate: {
          args: Prisma.GrowthRecordAggregateArgs<ExtArgs>;
          result: runtime.Types.Utils.Optional<Prisma.AggregateGrowthRecord>;
        };
        groupBy: {
          args: Prisma.GrowthRecordGroupByArgs<ExtArgs>;
          result: runtime.Types.Utils.Optional<Prisma.GrowthRecordGroupByOutputType>[];
        };
        count: {
          args: Prisma.GrowthRecordCountArgs<ExtArgs>;
          result:
            | runtime.Types.Utils.Optional<Prisma.GrowthRecordCountAggregateOutputType>
            | number;
        };
      };
    };
    Immunization: {
      payload: Prisma.$ImmunizationPayload<ExtArgs>;
      fields: Prisma.ImmunizationFieldRefs;
      operations: {
        findUnique: {
          args: Prisma.ImmunizationFindUniqueArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ImmunizationPayload> | null;
        };
        findUniqueOrThrow: {
          args: Prisma.ImmunizationFindUniqueOrThrowArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ImmunizationPayload>;
        };
        findFirst: {
          args: Prisma.ImmunizationFindFirstArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ImmunizationPayload> | null;
        };
        findFirstOrThrow: {
          args: Prisma.ImmunizationFindFirstOrThrowArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ImmunizationPayload>;
        };
        findMany: {
          args: Prisma.ImmunizationFindManyArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ImmunizationPayload>[];
        };
        create: {
          args: Prisma.ImmunizationCreateArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ImmunizationPayload>;
        };
        createMany: {
          args: Prisma.ImmunizationCreateManyArgs<ExtArgs>;
          result: BatchPayload;
        };
        createManyAndReturn: {
          args: Prisma.ImmunizationCreateManyAndReturnArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ImmunizationPayload>[];
        };
        delete: {
          args: Prisma.ImmunizationDeleteArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ImmunizationPayload>;
        };
        update: {
          args: Prisma.ImmunizationUpdateArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ImmunizationPayload>;
        };
        deleteMany: {
          args: Prisma.ImmunizationDeleteManyArgs<ExtArgs>;
          result: BatchPayload;
        };
        updateMany: {
          args: Prisma.ImmunizationUpdateManyArgs<ExtArgs>;
          result: BatchPayload;
        };
        updateManyAndReturn: {
          args: Prisma.ImmunizationUpdateManyAndReturnArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ImmunizationPayload>[];
        };
        upsert: {
          args: Prisma.ImmunizationUpsertArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ImmunizationPayload>;
        };
        aggregate: {
          args: Prisma.ImmunizationAggregateArgs<ExtArgs>;
          result: runtime.Types.Utils.Optional<Prisma.AggregateImmunization>;
        };
        groupBy: {
          args: Prisma.ImmunizationGroupByArgs<ExtArgs>;
          result: runtime.Types.Utils.Optional<Prisma.ImmunizationGroupByOutputType>[];
        };
        count: {
          args: Prisma.ImmunizationCountArgs<ExtArgs>;
          result:
            | runtime.Types.Utils.Optional<Prisma.ImmunizationCountAggregateOutputType>
            | number;
        };
      };
    };
    ConfigStore: {
      payload: Prisma.$ConfigStorePayload<ExtArgs>;
      fields: Prisma.ConfigStoreFieldRefs;
      operations: {
        findUnique: {
          args: Prisma.ConfigStoreFindUniqueArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ConfigStorePayload> | null;
        };
        findUniqueOrThrow: {
          args: Prisma.ConfigStoreFindUniqueOrThrowArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ConfigStorePayload>;
        };
        findFirst: {
          args: Prisma.ConfigStoreFindFirstArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ConfigStorePayload> | null;
        };
        findFirstOrThrow: {
          args: Prisma.ConfigStoreFindFirstOrThrowArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ConfigStorePayload>;
        };
        findMany: {
          args: Prisma.ConfigStoreFindManyArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ConfigStorePayload>[];
        };
        create: {
          args: Prisma.ConfigStoreCreateArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ConfigStorePayload>;
        };
        createMany: {
          args: Prisma.ConfigStoreCreateManyArgs<ExtArgs>;
          result: BatchPayload;
        };
        createManyAndReturn: {
          args: Prisma.ConfigStoreCreateManyAndReturnArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ConfigStorePayload>[];
        };
        delete: {
          args: Prisma.ConfigStoreDeleteArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ConfigStorePayload>;
        };
        update: {
          args: Prisma.ConfigStoreUpdateArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ConfigStorePayload>;
        };
        deleteMany: {
          args: Prisma.ConfigStoreDeleteManyArgs<ExtArgs>;
          result: BatchPayload;
        };
        updateMany: {
          args: Prisma.ConfigStoreUpdateManyArgs<ExtArgs>;
          result: BatchPayload;
        };
        updateManyAndReturn: {
          args: Prisma.ConfigStoreUpdateManyAndReturnArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ConfigStorePayload>[];
        };
        upsert: {
          args: Prisma.ConfigStoreUpsertArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ConfigStorePayload>;
        };
        aggregate: {
          args: Prisma.ConfigStoreAggregateArgs<ExtArgs>;
          result: runtime.Types.Utils.Optional<Prisma.AggregateConfigStore>;
        };
        groupBy: {
          args: Prisma.ConfigStoreGroupByArgs<ExtArgs>;
          result: runtime.Types.Utils.Optional<Prisma.ConfigStoreGroupByOutputType>[];
        };
        count: {
          args: Prisma.ConfigStoreCountArgs<ExtArgs>;
          result:
            | runtime.Types.Utils.Optional<Prisma.ConfigStoreCountAggregateOutputType>
            | number;
        };
      };
    };
    UserQuota: {
      payload: Prisma.$UserQuotaPayload<ExtArgs>;
      fields: Prisma.UserQuotaFieldRefs;
      operations: {
        findUnique: {
          args: Prisma.UserQuotaFindUniqueArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$UserQuotaPayload> | null;
        };
        findUniqueOrThrow: {
          args: Prisma.UserQuotaFindUniqueOrThrowArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$UserQuotaPayload>;
        };
        findFirst: {
          args: Prisma.UserQuotaFindFirstArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$UserQuotaPayload> | null;
        };
        findFirstOrThrow: {
          args: Prisma.UserQuotaFindFirstOrThrowArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$UserQuotaPayload>;
        };
        findMany: {
          args: Prisma.UserQuotaFindManyArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$UserQuotaPayload>[];
        };
        create: {
          args: Prisma.UserQuotaCreateArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$UserQuotaPayload>;
        };
        createMany: {
          args: Prisma.UserQuotaCreateManyArgs<ExtArgs>;
          result: BatchPayload;
        };
        createManyAndReturn: {
          args: Prisma.UserQuotaCreateManyAndReturnArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$UserQuotaPayload>[];
        };
        delete: {
          args: Prisma.UserQuotaDeleteArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$UserQuotaPayload>;
        };
        update: {
          args: Prisma.UserQuotaUpdateArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$UserQuotaPayload>;
        };
        deleteMany: {
          args: Prisma.UserQuotaDeleteManyArgs<ExtArgs>;
          result: BatchPayload;
        };
        updateMany: {
          args: Prisma.UserQuotaUpdateManyArgs<ExtArgs>;
          result: BatchPayload;
        };
        updateManyAndReturn: {
          args: Prisma.UserQuotaUpdateManyAndReturnArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$UserQuotaPayload>[];
        };
        upsert: {
          args: Prisma.UserQuotaUpsertArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$UserQuotaPayload>;
        };
        aggregate: {
          args: Prisma.UserQuotaAggregateArgs<ExtArgs>;
          result: runtime.Types.Utils.Optional<Prisma.AggregateUserQuota>;
        };
        groupBy: {
          args: Prisma.UserQuotaGroupByArgs<ExtArgs>;
          result: runtime.Types.Utils.Optional<Prisma.UserQuotaGroupByOutputType>[];
        };
        count: {
          args: Prisma.UserQuotaCountArgs<ExtArgs>;
          result:
            | runtime.Types.Utils.Optional<Prisma.UserQuotaCountAggregateOutputType>
            | number;
        };
      };
    };
    LabTest: {
      payload: Prisma.$LabTestPayload<ExtArgs>;
      fields: Prisma.LabTestFieldRefs;
      operations: {
        findUnique: {
          args: Prisma.LabTestFindUniqueArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$LabTestPayload> | null;
        };
        findUniqueOrThrow: {
          args: Prisma.LabTestFindUniqueOrThrowArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$LabTestPayload>;
        };
        findFirst: {
          args: Prisma.LabTestFindFirstArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$LabTestPayload> | null;
        };
        findFirstOrThrow: {
          args: Prisma.LabTestFindFirstOrThrowArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$LabTestPayload>;
        };
        findMany: {
          args: Prisma.LabTestFindManyArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$LabTestPayload>[];
        };
        create: {
          args: Prisma.LabTestCreateArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$LabTestPayload>;
        };
        createMany: {
          args: Prisma.LabTestCreateManyArgs<ExtArgs>;
          result: BatchPayload;
        };
        createManyAndReturn: {
          args: Prisma.LabTestCreateManyAndReturnArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$LabTestPayload>[];
        };
        delete: {
          args: Prisma.LabTestDeleteArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$LabTestPayload>;
        };
        update: {
          args: Prisma.LabTestUpdateArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$LabTestPayload>;
        };
        deleteMany: {
          args: Prisma.LabTestDeleteManyArgs<ExtArgs>;
          result: BatchPayload;
        };
        updateMany: {
          args: Prisma.LabTestUpdateManyArgs<ExtArgs>;
          result: BatchPayload;
        };
        updateManyAndReturn: {
          args: Prisma.LabTestUpdateManyAndReturnArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$LabTestPayload>[];
        };
        upsert: {
          args: Prisma.LabTestUpsertArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$LabTestPayload>;
        };
        aggregate: {
          args: Prisma.LabTestAggregateArgs<ExtArgs>;
          result: runtime.Types.Utils.Optional<Prisma.AggregateLabTest>;
        };
        groupBy: {
          args: Prisma.LabTestGroupByArgs<ExtArgs>;
          result: runtime.Types.Utils.Optional<Prisma.LabTestGroupByOutputType>[];
        };
        count: {
          args: Prisma.LabTestCountArgs<ExtArgs>;
          result:
            | runtime.Types.Utils.Optional<Prisma.LabTestCountAggregateOutputType>
            | number;
        };
      };
    };
    FeedingLog: {
      payload: Prisma.$FeedingLogPayload<ExtArgs>;
      fields: Prisma.FeedingLogFieldRefs;
      operations: {
        findUnique: {
          args: Prisma.FeedingLogFindUniqueArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$FeedingLogPayload> | null;
        };
        findUniqueOrThrow: {
          args: Prisma.FeedingLogFindUniqueOrThrowArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$FeedingLogPayload>;
        };
        findFirst: {
          args: Prisma.FeedingLogFindFirstArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$FeedingLogPayload> | null;
        };
        findFirstOrThrow: {
          args: Prisma.FeedingLogFindFirstOrThrowArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$FeedingLogPayload>;
        };
        findMany: {
          args: Prisma.FeedingLogFindManyArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$FeedingLogPayload>[];
        };
        create: {
          args: Prisma.FeedingLogCreateArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$FeedingLogPayload>;
        };
        createMany: {
          args: Prisma.FeedingLogCreateManyArgs<ExtArgs>;
          result: BatchPayload;
        };
        createManyAndReturn: {
          args: Prisma.FeedingLogCreateManyAndReturnArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$FeedingLogPayload>[];
        };
        delete: {
          args: Prisma.FeedingLogDeleteArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$FeedingLogPayload>;
        };
        update: {
          args: Prisma.FeedingLogUpdateArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$FeedingLogPayload>;
        };
        deleteMany: {
          args: Prisma.FeedingLogDeleteManyArgs<ExtArgs>;
          result: BatchPayload;
        };
        updateMany: {
          args: Prisma.FeedingLogUpdateManyArgs<ExtArgs>;
          result: BatchPayload;
        };
        updateManyAndReturn: {
          args: Prisma.FeedingLogUpdateManyAndReturnArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$FeedingLogPayload>[];
        };
        upsert: {
          args: Prisma.FeedingLogUpsertArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$FeedingLogPayload>;
        };
        aggregate: {
          args: Prisma.FeedingLogAggregateArgs<ExtArgs>;
          result: runtime.Types.Utils.Optional<Prisma.AggregateFeedingLog>;
        };
        groupBy: {
          args: Prisma.FeedingLogGroupByArgs<ExtArgs>;
          result: runtime.Types.Utils.Optional<Prisma.FeedingLogGroupByOutputType>[];
        };
        count: {
          args: Prisma.FeedingLogCountArgs<ExtArgs>;
          result:
            | runtime.Types.Utils.Optional<Prisma.FeedingLogCountAggregateOutputType>
            | number;
        };
      };
    };
    DevelopmentalMilestone: {
      payload: Prisma.$DevelopmentalMilestonePayload<ExtArgs>;
      fields: Prisma.DevelopmentalMilestoneFieldRefs;
      operations: {
        findUnique: {
          args: Prisma.DevelopmentalMilestoneFindUniqueArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$DevelopmentalMilestonePayload> | null;
        };
        findUniqueOrThrow: {
          args: Prisma.DevelopmentalMilestoneFindUniqueOrThrowArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$DevelopmentalMilestonePayload>;
        };
        findFirst: {
          args: Prisma.DevelopmentalMilestoneFindFirstArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$DevelopmentalMilestonePayload> | null;
        };
        findFirstOrThrow: {
          args: Prisma.DevelopmentalMilestoneFindFirstOrThrowArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$DevelopmentalMilestonePayload>;
        };
        findMany: {
          args: Prisma.DevelopmentalMilestoneFindManyArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$DevelopmentalMilestonePayload>[];
        };
        create: {
          args: Prisma.DevelopmentalMilestoneCreateArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$DevelopmentalMilestonePayload>;
        };
        createMany: {
          args: Prisma.DevelopmentalMilestoneCreateManyArgs<ExtArgs>;
          result: BatchPayload;
        };
        createManyAndReturn: {
          args: Prisma.DevelopmentalMilestoneCreateManyAndReturnArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$DevelopmentalMilestonePayload>[];
        };
        delete: {
          args: Prisma.DevelopmentalMilestoneDeleteArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$DevelopmentalMilestonePayload>;
        };
        update: {
          args: Prisma.DevelopmentalMilestoneUpdateArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$DevelopmentalMilestonePayload>;
        };
        deleteMany: {
          args: Prisma.DevelopmentalMilestoneDeleteManyArgs<ExtArgs>;
          result: BatchPayload;
        };
        updateMany: {
          args: Prisma.DevelopmentalMilestoneUpdateManyArgs<ExtArgs>;
          result: BatchPayload;
        };
        updateManyAndReturn: {
          args: Prisma.DevelopmentalMilestoneUpdateManyAndReturnArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$DevelopmentalMilestonePayload>[];
        };
        upsert: {
          args: Prisma.DevelopmentalMilestoneUpsertArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$DevelopmentalMilestonePayload>;
        };
        aggregate: {
          args: Prisma.DevelopmentalMilestoneAggregateArgs<ExtArgs>;
          result: runtime.Types.Utils.Optional<Prisma.AggregateDevelopmentalMilestone>;
        };
        groupBy: {
          args: Prisma.DevelopmentalMilestoneGroupByArgs<ExtArgs>;
          result: runtime.Types.Utils.Optional<Prisma.DevelopmentalMilestoneGroupByOutputType>[];
        };
        count: {
          args: Prisma.DevelopmentalMilestoneCountArgs<ExtArgs>;
          result:
            | runtime.Types.Utils.Optional<Prisma.DevelopmentalMilestoneCountAggregateOutputType>
            | number;
        };
      };
    };
    DevelopmentalCheck: {
      payload: Prisma.$DevelopmentalCheckPayload<ExtArgs>;
      fields: Prisma.DevelopmentalCheckFieldRefs;
      operations: {
        findUnique: {
          args: Prisma.DevelopmentalCheckFindUniqueArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$DevelopmentalCheckPayload> | null;
        };
        findUniqueOrThrow: {
          args: Prisma.DevelopmentalCheckFindUniqueOrThrowArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$DevelopmentalCheckPayload>;
        };
        findFirst: {
          args: Prisma.DevelopmentalCheckFindFirstArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$DevelopmentalCheckPayload> | null;
        };
        findFirstOrThrow: {
          args: Prisma.DevelopmentalCheckFindFirstOrThrowArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$DevelopmentalCheckPayload>;
        };
        findMany: {
          args: Prisma.DevelopmentalCheckFindManyArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$DevelopmentalCheckPayload>[];
        };
        create: {
          args: Prisma.DevelopmentalCheckCreateArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$DevelopmentalCheckPayload>;
        };
        createMany: {
          args: Prisma.DevelopmentalCheckCreateManyArgs<ExtArgs>;
          result: BatchPayload;
        };
        createManyAndReturn: {
          args: Prisma.DevelopmentalCheckCreateManyAndReturnArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$DevelopmentalCheckPayload>[];
        };
        delete: {
          args: Prisma.DevelopmentalCheckDeleteArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$DevelopmentalCheckPayload>;
        };
        update: {
          args: Prisma.DevelopmentalCheckUpdateArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$DevelopmentalCheckPayload>;
        };
        deleteMany: {
          args: Prisma.DevelopmentalCheckDeleteManyArgs<ExtArgs>;
          result: BatchPayload;
        };
        updateMany: {
          args: Prisma.DevelopmentalCheckUpdateManyArgs<ExtArgs>;
          result: BatchPayload;
        };
        updateManyAndReturn: {
          args: Prisma.DevelopmentalCheckUpdateManyAndReturnArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$DevelopmentalCheckPayload>[];
        };
        upsert: {
          args: Prisma.DevelopmentalCheckUpsertArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$DevelopmentalCheckPayload>;
        };
        aggregate: {
          args: Prisma.DevelopmentalCheckAggregateArgs<ExtArgs>;
          result: runtime.Types.Utils.Optional<Prisma.AggregateDevelopmentalCheck>;
        };
        groupBy: {
          args: Prisma.DevelopmentalCheckGroupByArgs<ExtArgs>;
          result: runtime.Types.Utils.Optional<Prisma.DevelopmentalCheckGroupByOutputType>[];
        };
        count: {
          args: Prisma.DevelopmentalCheckCountArgs<ExtArgs>;
          result:
            | runtime.Types.Utils.Optional<Prisma.DevelopmentalCheckCountAggregateOutputType>
            | number;
        };
      };
    };
    VaccineSchedule: {
      payload: Prisma.$VaccineSchedulePayload<ExtArgs>;
      fields: Prisma.VaccineScheduleFieldRefs;
      operations: {
        findUnique: {
          args: Prisma.VaccineScheduleFindUniqueArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$VaccineSchedulePayload> | null;
        };
        findUniqueOrThrow: {
          args: Prisma.VaccineScheduleFindUniqueOrThrowArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$VaccineSchedulePayload>;
        };
        findFirst: {
          args: Prisma.VaccineScheduleFindFirstArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$VaccineSchedulePayload> | null;
        };
        findFirstOrThrow: {
          args: Prisma.VaccineScheduleFindFirstOrThrowArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$VaccineSchedulePayload>;
        };
        findMany: {
          args: Prisma.VaccineScheduleFindManyArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$VaccineSchedulePayload>[];
        };
        create: {
          args: Prisma.VaccineScheduleCreateArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$VaccineSchedulePayload>;
        };
        createMany: {
          args: Prisma.VaccineScheduleCreateManyArgs<ExtArgs>;
          result: BatchPayload;
        };
        createManyAndReturn: {
          args: Prisma.VaccineScheduleCreateManyAndReturnArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$VaccineSchedulePayload>[];
        };
        delete: {
          args: Prisma.VaccineScheduleDeleteArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$VaccineSchedulePayload>;
        };
        update: {
          args: Prisma.VaccineScheduleUpdateArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$VaccineSchedulePayload>;
        };
        deleteMany: {
          args: Prisma.VaccineScheduleDeleteManyArgs<ExtArgs>;
          result: BatchPayload;
        };
        updateMany: {
          args: Prisma.VaccineScheduleUpdateManyArgs<ExtArgs>;
          result: BatchPayload;
        };
        updateManyAndReturn: {
          args: Prisma.VaccineScheduleUpdateManyAndReturnArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$VaccineSchedulePayload>[];
        };
        upsert: {
          args: Prisma.VaccineScheduleUpsertArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$VaccineSchedulePayload>;
        };
        aggregate: {
          args: Prisma.VaccineScheduleAggregateArgs<ExtArgs>;
          result: runtime.Types.Utils.Optional<Prisma.AggregateVaccineSchedule>;
        };
        groupBy: {
          args: Prisma.VaccineScheduleGroupByArgs<ExtArgs>;
          result: runtime.Types.Utils.Optional<Prisma.VaccineScheduleGroupByOutputType>[];
        };
        count: {
          args: Prisma.VaccineScheduleCountArgs<ExtArgs>;
          result:
            | runtime.Types.Utils.Optional<Prisma.VaccineScheduleCountAggregateOutputType>
            | number;
        };
      };
    };
    Expense: {
      payload: Prisma.$ExpensePayload<ExtArgs>;
      fields: Prisma.ExpenseFieldRefs;
      operations: {
        findUnique: {
          args: Prisma.ExpenseFindUniqueArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ExpensePayload> | null;
        };
        findUniqueOrThrow: {
          args: Prisma.ExpenseFindUniqueOrThrowArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ExpensePayload>;
        };
        findFirst: {
          args: Prisma.ExpenseFindFirstArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ExpensePayload> | null;
        };
        findFirstOrThrow: {
          args: Prisma.ExpenseFindFirstOrThrowArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ExpensePayload>;
        };
        findMany: {
          args: Prisma.ExpenseFindManyArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ExpensePayload>[];
        };
        create: {
          args: Prisma.ExpenseCreateArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ExpensePayload>;
        };
        createMany: {
          args: Prisma.ExpenseCreateManyArgs<ExtArgs>;
          result: BatchPayload;
        };
        createManyAndReturn: {
          args: Prisma.ExpenseCreateManyAndReturnArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ExpensePayload>[];
        };
        delete: {
          args: Prisma.ExpenseDeleteArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ExpensePayload>;
        };
        update: {
          args: Prisma.ExpenseUpdateArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ExpensePayload>;
        };
        deleteMany: {
          args: Prisma.ExpenseDeleteManyArgs<ExtArgs>;
          result: BatchPayload;
        };
        updateMany: {
          args: Prisma.ExpenseUpdateManyArgs<ExtArgs>;
          result: BatchPayload;
        };
        updateManyAndReturn: {
          args: Prisma.ExpenseUpdateManyAndReturnArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ExpensePayload>[];
        };
        upsert: {
          args: Prisma.ExpenseUpsertArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ExpensePayload>;
        };
        aggregate: {
          args: Prisma.ExpenseAggregateArgs<ExtArgs>;
          result: runtime.Types.Utils.Optional<Prisma.AggregateExpense>;
        };
        groupBy: {
          args: Prisma.ExpenseGroupByArgs<ExtArgs>;
          result: runtime.Types.Utils.Optional<Prisma.ExpenseGroupByOutputType>[];
        };
        count: {
          args: Prisma.ExpenseCountArgs<ExtArgs>;
          result:
            | runtime.Types.Utils.Optional<Prisma.ExpenseCountAggregateOutputType>
            | number;
        };
      };
    };
    ExpenseCategory: {
      payload: Prisma.$ExpenseCategoryPayload<ExtArgs>;
      fields: Prisma.ExpenseCategoryFieldRefs;
      operations: {
        findUnique: {
          args: Prisma.ExpenseCategoryFindUniqueArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ExpenseCategoryPayload> | null;
        };
        findUniqueOrThrow: {
          args: Prisma.ExpenseCategoryFindUniqueOrThrowArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ExpenseCategoryPayload>;
        };
        findFirst: {
          args: Prisma.ExpenseCategoryFindFirstArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ExpenseCategoryPayload> | null;
        };
        findFirstOrThrow: {
          args: Prisma.ExpenseCategoryFindFirstOrThrowArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ExpenseCategoryPayload>;
        };
        findMany: {
          args: Prisma.ExpenseCategoryFindManyArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ExpenseCategoryPayload>[];
        };
        create: {
          args: Prisma.ExpenseCategoryCreateArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ExpenseCategoryPayload>;
        };
        createMany: {
          args: Prisma.ExpenseCategoryCreateManyArgs<ExtArgs>;
          result: BatchPayload;
        };
        createManyAndReturn: {
          args: Prisma.ExpenseCategoryCreateManyAndReturnArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ExpenseCategoryPayload>[];
        };
        delete: {
          args: Prisma.ExpenseCategoryDeleteArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ExpenseCategoryPayload>;
        };
        update: {
          args: Prisma.ExpenseCategoryUpdateArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ExpenseCategoryPayload>;
        };
        deleteMany: {
          args: Prisma.ExpenseCategoryDeleteManyArgs<ExtArgs>;
          result: BatchPayload;
        };
        updateMany: {
          args: Prisma.ExpenseCategoryUpdateManyArgs<ExtArgs>;
          result: BatchPayload;
        };
        updateManyAndReturn: {
          args: Prisma.ExpenseCategoryUpdateManyAndReturnArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ExpenseCategoryPayload>[];
        };
        upsert: {
          args: Prisma.ExpenseCategoryUpsertArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ExpenseCategoryPayload>;
        };
        aggregate: {
          args: Prisma.ExpenseCategoryAggregateArgs<ExtArgs>;
          result: runtime.Types.Utils.Optional<Prisma.AggregateExpenseCategory>;
        };
        groupBy: {
          args: Prisma.ExpenseCategoryGroupByArgs<ExtArgs>;
          result: runtime.Types.Utils.Optional<Prisma.ExpenseCategoryGroupByOutputType>[];
        };
        count: {
          args: Prisma.ExpenseCategoryCountArgs<ExtArgs>;
          result:
            | runtime.Types.Utils.Optional<Prisma.ExpenseCategoryCountAggregateOutputType>
            | number;
        };
      };
    };
    ExpenseSubCategory: {
      payload: Prisma.$ExpenseSubCategoryPayload<ExtArgs>;
      fields: Prisma.ExpenseSubCategoryFieldRefs;
      operations: {
        findUnique: {
          args: Prisma.ExpenseSubCategoryFindUniqueArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ExpenseSubCategoryPayload> | null;
        };
        findUniqueOrThrow: {
          args: Prisma.ExpenseSubCategoryFindUniqueOrThrowArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ExpenseSubCategoryPayload>;
        };
        findFirst: {
          args: Prisma.ExpenseSubCategoryFindFirstArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ExpenseSubCategoryPayload> | null;
        };
        findFirstOrThrow: {
          args: Prisma.ExpenseSubCategoryFindFirstOrThrowArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ExpenseSubCategoryPayload>;
        };
        findMany: {
          args: Prisma.ExpenseSubCategoryFindManyArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ExpenseSubCategoryPayload>[];
        };
        create: {
          args: Prisma.ExpenseSubCategoryCreateArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ExpenseSubCategoryPayload>;
        };
        createMany: {
          args: Prisma.ExpenseSubCategoryCreateManyArgs<ExtArgs>;
          result: BatchPayload;
        };
        createManyAndReturn: {
          args: Prisma.ExpenseSubCategoryCreateManyAndReturnArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ExpenseSubCategoryPayload>[];
        };
        delete: {
          args: Prisma.ExpenseSubCategoryDeleteArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ExpenseSubCategoryPayload>;
        };
        update: {
          args: Prisma.ExpenseSubCategoryUpdateArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ExpenseSubCategoryPayload>;
        };
        deleteMany: {
          args: Prisma.ExpenseSubCategoryDeleteManyArgs<ExtArgs>;
          result: BatchPayload;
        };
        updateMany: {
          args: Prisma.ExpenseSubCategoryUpdateManyArgs<ExtArgs>;
          result: BatchPayload;
        };
        updateManyAndReturn: {
          args: Prisma.ExpenseSubCategoryUpdateManyAndReturnArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ExpenseSubCategoryPayload>[];
        };
        upsert: {
          args: Prisma.ExpenseSubCategoryUpsertArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ExpenseSubCategoryPayload>;
        };
        aggregate: {
          args: Prisma.ExpenseSubCategoryAggregateArgs<ExtArgs>;
          result: runtime.Types.Utils.Optional<Prisma.AggregateExpenseSubCategory>;
        };
        groupBy: {
          args: Prisma.ExpenseSubCategoryGroupByArgs<ExtArgs>;
          result: runtime.Types.Utils.Optional<Prisma.ExpenseSubCategoryGroupByOutputType>[];
        };
        count: {
          args: Prisma.ExpenseSubCategoryCountArgs<ExtArgs>;
          result:
            | runtime.Types.Utils.Optional<Prisma.ExpenseSubCategoryCountAggregateOutputType>
            | number;
        };
      };
    };
    FileStorage: {
      payload: Prisma.$FileStoragePayload<ExtArgs>;
      fields: Prisma.FileStorageFieldRefs;
      operations: {
        findUnique: {
          args: Prisma.FileStorageFindUniqueArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$FileStoragePayload> | null;
        };
        findUniqueOrThrow: {
          args: Prisma.FileStorageFindUniqueOrThrowArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$FileStoragePayload>;
        };
        findFirst: {
          args: Prisma.FileStorageFindFirstArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$FileStoragePayload> | null;
        };
        findFirstOrThrow: {
          args: Prisma.FileStorageFindFirstOrThrowArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$FileStoragePayload>;
        };
        findMany: {
          args: Prisma.FileStorageFindManyArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$FileStoragePayload>[];
        };
        create: {
          args: Prisma.FileStorageCreateArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$FileStoragePayload>;
        };
        createMany: {
          args: Prisma.FileStorageCreateManyArgs<ExtArgs>;
          result: BatchPayload;
        };
        createManyAndReturn: {
          args: Prisma.FileStorageCreateManyAndReturnArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$FileStoragePayload>[];
        };
        delete: {
          args: Prisma.FileStorageDeleteArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$FileStoragePayload>;
        };
        update: {
          args: Prisma.FileStorageUpdateArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$FileStoragePayload>;
        };
        deleteMany: {
          args: Prisma.FileStorageDeleteManyArgs<ExtArgs>;
          result: BatchPayload;
        };
        updateMany: {
          args: Prisma.FileStorageUpdateManyArgs<ExtArgs>;
          result: BatchPayload;
        };
        updateManyAndReturn: {
          args: Prisma.FileStorageUpdateManyAndReturnArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$FileStoragePayload>[];
        };
        upsert: {
          args: Prisma.FileStorageUpsertArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$FileStoragePayload>;
        };
        aggregate: {
          args: Prisma.FileStorageAggregateArgs<ExtArgs>;
          result: runtime.Types.Utils.Optional<Prisma.AggregateFileStorage>;
        };
        groupBy: {
          args: Prisma.FileStorageGroupByArgs<ExtArgs>;
          result: runtime.Types.Utils.Optional<Prisma.FileStorageGroupByOutputType>[];
        };
        count: {
          args: Prisma.FileStorageCountArgs<ExtArgs>;
          result:
            | runtime.Types.Utils.Optional<Prisma.FileStorageCountAggregateOutputType>
            | number;
        };
      };
    };
    TrainingFile: {
      payload: Prisma.$TrainingFilePayload<ExtArgs>;
      fields: Prisma.TrainingFileFieldRefs;
      operations: {
        findUnique: {
          args: Prisma.TrainingFileFindUniqueArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TrainingFilePayload> | null;
        };
        findUniqueOrThrow: {
          args: Prisma.TrainingFileFindUniqueOrThrowArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TrainingFilePayload>;
        };
        findFirst: {
          args: Prisma.TrainingFileFindFirstArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TrainingFilePayload> | null;
        };
        findFirstOrThrow: {
          args: Prisma.TrainingFileFindFirstOrThrowArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TrainingFilePayload>;
        };
        findMany: {
          args: Prisma.TrainingFileFindManyArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TrainingFilePayload>[];
        };
        create: {
          args: Prisma.TrainingFileCreateArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TrainingFilePayload>;
        };
        createMany: {
          args: Prisma.TrainingFileCreateManyArgs<ExtArgs>;
          result: BatchPayload;
        };
        createManyAndReturn: {
          args: Prisma.TrainingFileCreateManyAndReturnArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TrainingFilePayload>[];
        };
        delete: {
          args: Prisma.TrainingFileDeleteArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TrainingFilePayload>;
        };
        update: {
          args: Prisma.TrainingFileUpdateArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TrainingFilePayload>;
        };
        deleteMany: {
          args: Prisma.TrainingFileDeleteManyArgs<ExtArgs>;
          result: BatchPayload;
        };
        updateMany: {
          args: Prisma.TrainingFileUpdateManyArgs<ExtArgs>;
          result: BatchPayload;
        };
        updateManyAndReturn: {
          args: Prisma.TrainingFileUpdateManyAndReturnArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TrainingFilePayload>[];
        };
        upsert: {
          args: Prisma.TrainingFileUpsertArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TrainingFilePayload>;
        };
        aggregate: {
          args: Prisma.TrainingFileAggregateArgs<ExtArgs>;
          result: runtime.Types.Utils.Optional<Prisma.AggregateTrainingFile>;
        };
        groupBy: {
          args: Prisma.TrainingFileGroupByArgs<ExtArgs>;
          result: runtime.Types.Utils.Optional<Prisma.TrainingFileGroupByOutputType>[];
        };
        count: {
          args: Prisma.TrainingFileCountArgs<ExtArgs>;
          result:
            | runtime.Types.Utils.Optional<Prisma.TrainingFileCountAggregateOutputType>
            | number;
        };
      };
    };
    KnowledgeBase: {
      payload: Prisma.$KnowledgeBasePayload<ExtArgs>;
      fields: Prisma.KnowledgeBaseFieldRefs;
      operations: {
        findUnique: {
          args: Prisma.KnowledgeBaseFindUniqueArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$KnowledgeBasePayload> | null;
        };
        findUniqueOrThrow: {
          args: Prisma.KnowledgeBaseFindUniqueOrThrowArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$KnowledgeBasePayload>;
        };
        findFirst: {
          args: Prisma.KnowledgeBaseFindFirstArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$KnowledgeBasePayload> | null;
        };
        findFirstOrThrow: {
          args: Prisma.KnowledgeBaseFindFirstOrThrowArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$KnowledgeBasePayload>;
        };
        findMany: {
          args: Prisma.KnowledgeBaseFindManyArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$KnowledgeBasePayload>[];
        };
        create: {
          args: Prisma.KnowledgeBaseCreateArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$KnowledgeBasePayload>;
        };
        createMany: {
          args: Prisma.KnowledgeBaseCreateManyArgs<ExtArgs>;
          result: BatchPayload;
        };
        createManyAndReturn: {
          args: Prisma.KnowledgeBaseCreateManyAndReturnArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$KnowledgeBasePayload>[];
        };
        delete: {
          args: Prisma.KnowledgeBaseDeleteArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$KnowledgeBasePayload>;
        };
        update: {
          args: Prisma.KnowledgeBaseUpdateArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$KnowledgeBasePayload>;
        };
        deleteMany: {
          args: Prisma.KnowledgeBaseDeleteManyArgs<ExtArgs>;
          result: BatchPayload;
        };
        updateMany: {
          args: Prisma.KnowledgeBaseUpdateManyArgs<ExtArgs>;
          result: BatchPayload;
        };
        updateManyAndReturn: {
          args: Prisma.KnowledgeBaseUpdateManyAndReturnArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$KnowledgeBasePayload>[];
        };
        upsert: {
          args: Prisma.KnowledgeBaseUpsertArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$KnowledgeBasePayload>;
        };
        aggregate: {
          args: Prisma.KnowledgeBaseAggregateArgs<ExtArgs>;
          result: runtime.Types.Utils.Optional<Prisma.AggregateKnowledgeBase>;
        };
        groupBy: {
          args: Prisma.KnowledgeBaseGroupByArgs<ExtArgs>;
          result: runtime.Types.Utils.Optional<Prisma.KnowledgeBaseGroupByOutputType>[];
        };
        count: {
          args: Prisma.KnowledgeBaseCountArgs<ExtArgs>;
          result:
            | runtime.Types.Utils.Optional<Prisma.KnowledgeBaseCountAggregateOutputType>
            | number;
        };
      };
    };
    TrainingWebsite: {
      payload: Prisma.$TrainingWebsitePayload<ExtArgs>;
      fields: Prisma.TrainingWebsiteFieldRefs;
      operations: {
        findUnique: {
          args: Prisma.TrainingWebsiteFindUniqueArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TrainingWebsitePayload> | null;
        };
        findUniqueOrThrow: {
          args: Prisma.TrainingWebsiteFindUniqueOrThrowArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TrainingWebsitePayload>;
        };
        findFirst: {
          args: Prisma.TrainingWebsiteFindFirstArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TrainingWebsitePayload> | null;
        };
        findFirstOrThrow: {
          args: Prisma.TrainingWebsiteFindFirstOrThrowArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TrainingWebsitePayload>;
        };
        findMany: {
          args: Prisma.TrainingWebsiteFindManyArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TrainingWebsitePayload>[];
        };
        create: {
          args: Prisma.TrainingWebsiteCreateArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TrainingWebsitePayload>;
        };
        createMany: {
          args: Prisma.TrainingWebsiteCreateManyArgs<ExtArgs>;
          result: BatchPayload;
        };
        createManyAndReturn: {
          args: Prisma.TrainingWebsiteCreateManyAndReturnArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TrainingWebsitePayload>[];
        };
        delete: {
          args: Prisma.TrainingWebsiteDeleteArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TrainingWebsitePayload>;
        };
        update: {
          args: Prisma.TrainingWebsiteUpdateArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TrainingWebsitePayload>;
        };
        deleteMany: {
          args: Prisma.TrainingWebsiteDeleteManyArgs<ExtArgs>;
          result: BatchPayload;
        };
        updateMany: {
          args: Prisma.TrainingWebsiteUpdateManyArgs<ExtArgs>;
          result: BatchPayload;
        };
        updateManyAndReturn: {
          args: Prisma.TrainingWebsiteUpdateManyAndReturnArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TrainingWebsitePayload>[];
        };
        upsert: {
          args: Prisma.TrainingWebsiteUpsertArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TrainingWebsitePayload>;
        };
        aggregate: {
          args: Prisma.TrainingWebsiteAggregateArgs<ExtArgs>;
          result: runtime.Types.Utils.Optional<Prisma.AggregateTrainingWebsite>;
        };
        groupBy: {
          args: Prisma.TrainingWebsiteGroupByArgs<ExtArgs>;
          result: runtime.Types.Utils.Optional<Prisma.TrainingWebsiteGroupByOutputType>[];
        };
        count: {
          args: Prisma.TrainingWebsiteCountArgs<ExtArgs>;
          result:
            | runtime.Types.Utils.Optional<Prisma.TrainingWebsiteCountAggregateOutputType>
            | number;
        };
      };
    };
    Agent: {
      payload: Prisma.$AgentPayload<ExtArgs>;
      fields: Prisma.AgentFieldRefs;
      operations: {
        findUnique: {
          args: Prisma.AgentFindUniqueArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AgentPayload> | null;
        };
        findUniqueOrThrow: {
          args: Prisma.AgentFindUniqueOrThrowArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AgentPayload>;
        };
        findFirst: {
          args: Prisma.AgentFindFirstArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AgentPayload> | null;
        };
        findFirstOrThrow: {
          args: Prisma.AgentFindFirstOrThrowArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AgentPayload>;
        };
        findMany: {
          args: Prisma.AgentFindManyArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AgentPayload>[];
        };
        create: {
          args: Prisma.AgentCreateArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AgentPayload>;
        };
        createMany: {
          args: Prisma.AgentCreateManyArgs<ExtArgs>;
          result: BatchPayload;
        };
        createManyAndReturn: {
          args: Prisma.AgentCreateManyAndReturnArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AgentPayload>[];
        };
        delete: {
          args: Prisma.AgentDeleteArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AgentPayload>;
        };
        update: {
          args: Prisma.AgentUpdateArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AgentPayload>;
        };
        deleteMany: {
          args: Prisma.AgentDeleteManyArgs<ExtArgs>;
          result: BatchPayload;
        };
        updateMany: {
          args: Prisma.AgentUpdateManyArgs<ExtArgs>;
          result: BatchPayload;
        };
        updateManyAndReturn: {
          args: Prisma.AgentUpdateManyAndReturnArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AgentPayload>[];
        };
        upsert: {
          args: Prisma.AgentUpsertArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AgentPayload>;
        };
        aggregate: {
          args: Prisma.AgentAggregateArgs<ExtArgs>;
          result: runtime.Types.Utils.Optional<Prisma.AggregateAgent>;
        };
        groupBy: {
          args: Prisma.AgentGroupByArgs<ExtArgs>;
          result: runtime.Types.Utils.Optional<Prisma.AgentGroupByOutputType>[];
        };
        count: {
          args: Prisma.AgentCountArgs<ExtArgs>;
          result:
            | runtime.Types.Utils.Optional<Prisma.AgentCountAggregateOutputType>
            | number;
        };
      };
    };
    ClinicDashboardMV: {
      payload: Prisma.$ClinicDashboardMVPayload<ExtArgs>;
      fields: Prisma.ClinicDashboardMVFieldRefs;
      operations: {
        findFirst: {
          args: Prisma.ClinicDashboardMVFindFirstArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ClinicDashboardMVPayload> | null;
        };
        findFirstOrThrow: {
          args: Prisma.ClinicDashboardMVFindFirstOrThrowArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ClinicDashboardMVPayload>;
        };
        findMany: {
          args: Prisma.ClinicDashboardMVFindManyArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ClinicDashboardMVPayload>[];
        };
        aggregate: {
          args: Prisma.ClinicDashboardMVAggregateArgs<ExtArgs>;
          result: runtime.Types.Utils.Optional<Prisma.AggregateClinicDashboardMV>;
        };
        groupBy: {
          args: Prisma.ClinicDashboardMVGroupByArgs<ExtArgs>;
          result: runtime.Types.Utils.Optional<Prisma.ClinicDashboardMVGroupByOutputType>[];
        };
        count: {
          args: Prisma.ClinicDashboardMVCountArgs<ExtArgs>;
          result:
            | runtime.Types.Utils.Optional<Prisma.ClinicDashboardMVCountAggregateOutputType>
            | number;
        };
      };
    };
    PatientOverviewMV: {
      payload: Prisma.$PatientOverviewMVPayload<ExtArgs>;
      fields: Prisma.PatientOverviewMVFieldRefs;
      operations: {
        findFirst: {
          args: Prisma.PatientOverviewMVFindFirstArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PatientOverviewMVPayload> | null;
        };
        findFirstOrThrow: {
          args: Prisma.PatientOverviewMVFindFirstOrThrowArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PatientOverviewMVPayload>;
        };
        findMany: {
          args: Prisma.PatientOverviewMVFindManyArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PatientOverviewMVPayload>[];
        };
        aggregate: {
          args: Prisma.PatientOverviewMVAggregateArgs<ExtArgs>;
          result: runtime.Types.Utils.Optional<Prisma.AggregatePatientOverviewMV>;
        };
        groupBy: {
          args: Prisma.PatientOverviewMVGroupByArgs<ExtArgs>;
          result: runtime.Types.Utils.Optional<Prisma.PatientOverviewMVGroupByOutputType>[];
        };
        count: {
          args: Prisma.PatientOverviewMVCountArgs<ExtArgs>;
          result:
            | runtime.Types.Utils.Optional<Prisma.PatientOverviewMVCountAggregateOutputType>
            | number;
        };
      };
    };
    DoctorPerformanceMV: {
      payload: Prisma.$DoctorPerformanceMVPayload<ExtArgs>;
      fields: Prisma.DoctorPerformanceMVFieldRefs;
      operations: {
        findFirst: {
          args: Prisma.DoctorPerformanceMVFindFirstArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$DoctorPerformanceMVPayload> | null;
        };
        findFirstOrThrow: {
          args: Prisma.DoctorPerformanceMVFindFirstOrThrowArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$DoctorPerformanceMVPayload>;
        };
        findMany: {
          args: Prisma.DoctorPerformanceMVFindManyArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$DoctorPerformanceMVPayload>[];
        };
        aggregate: {
          args: Prisma.DoctorPerformanceMVAggregateArgs<ExtArgs>;
          result: runtime.Types.Utils.Optional<Prisma.AggregateDoctorPerformanceMV>;
        };
        groupBy: {
          args: Prisma.DoctorPerformanceMVGroupByArgs<ExtArgs>;
          result: runtime.Types.Utils.Optional<Prisma.DoctorPerformanceMVGroupByOutputType>[];
        };
        count: {
          args: Prisma.DoctorPerformanceMVCountArgs<ExtArgs>;
          result:
            | runtime.Types.Utils.Optional<Prisma.DoctorPerformanceMVCountAggregateOutputType>
            | number;
        };
      };
    };
    FinancialOverviewMV: {
      payload: Prisma.$FinancialOverviewMVPayload<ExtArgs>;
      fields: Prisma.FinancialOverviewMVFieldRefs;
      operations: {
        findFirst: {
          args: Prisma.FinancialOverviewMVFindFirstArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$FinancialOverviewMVPayload> | null;
        };
        findFirstOrThrow: {
          args: Prisma.FinancialOverviewMVFindFirstOrThrowArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$FinancialOverviewMVPayload>;
        };
        findMany: {
          args: Prisma.FinancialOverviewMVFindManyArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$FinancialOverviewMVPayload>[];
        };
        aggregate: {
          args: Prisma.FinancialOverviewMVAggregateArgs<ExtArgs>;
          result: runtime.Types.Utils.Optional<Prisma.AggregateFinancialOverviewMV>;
        };
        groupBy: {
          args: Prisma.FinancialOverviewMVGroupByArgs<ExtArgs>;
          result: runtime.Types.Utils.Optional<Prisma.FinancialOverviewMVGroupByOutputType>[];
        };
        count: {
          args: Prisma.FinancialOverviewMVCountArgs<ExtArgs>;
          result:
            | runtime.Types.Utils.Optional<Prisma.FinancialOverviewMVCountAggregateOutputType>
            | number;
        };
      };
    };
    AppointmentScheduleMV: {
      payload: Prisma.$AppointmentScheduleMVPayload<ExtArgs>;
      fields: Prisma.AppointmentScheduleMVFieldRefs;
      operations: {
        findFirst: {
          args: Prisma.AppointmentScheduleMVFindFirstArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AppointmentScheduleMVPayload> | null;
        };
        findFirstOrThrow: {
          args: Prisma.AppointmentScheduleMVFindFirstOrThrowArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AppointmentScheduleMVPayload>;
        };
        findMany: {
          args: Prisma.AppointmentScheduleMVFindManyArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AppointmentScheduleMVPayload>[];
        };
        aggregate: {
          args: Prisma.AppointmentScheduleMVAggregateArgs<ExtArgs>;
          result: runtime.Types.Utils.Optional<Prisma.AggregateAppointmentScheduleMV>;
        };
        groupBy: {
          args: Prisma.AppointmentScheduleMVGroupByArgs<ExtArgs>;
          result: runtime.Types.Utils.Optional<Prisma.AppointmentScheduleMVGroupByOutputType>[];
        };
        count: {
          args: Prisma.AppointmentScheduleMVCountArgs<ExtArgs>;
          result:
            | runtime.Types.Utils.Optional<Prisma.AppointmentScheduleMVCountAggregateOutputType>
            | number;
        };
      };
    };
    PatientGrowthChartMV: {
      payload: Prisma.$PatientGrowthChartMVPayload<ExtArgs>;
      fields: Prisma.PatientGrowthChartMVFieldRefs;
      operations: {
        findFirst: {
          args: Prisma.PatientGrowthChartMVFindFirstArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PatientGrowthChartMVPayload> | null;
        };
        findFirstOrThrow: {
          args: Prisma.PatientGrowthChartMVFindFirstOrThrowArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PatientGrowthChartMVPayload>;
        };
        findMany: {
          args: Prisma.PatientGrowthChartMVFindManyArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PatientGrowthChartMVPayload>[];
        };
        aggregate: {
          args: Prisma.PatientGrowthChartMVAggregateArgs<ExtArgs>;
          result: runtime.Types.Utils.Optional<Prisma.AggregatePatientGrowthChartMV>;
        };
        groupBy: {
          args: Prisma.PatientGrowthChartMVGroupByArgs<ExtArgs>;
          result: runtime.Types.Utils.Optional<Prisma.PatientGrowthChartMVGroupByOutputType>[];
        };
        count: {
          args: Prisma.PatientGrowthChartMVCountArgs<ExtArgs>;
          result:
            | runtime.Types.Utils.Optional<Prisma.PatientGrowthChartMVCountAggregateOutputType>
            | number;
        };
      };
    };
    ImmunizationScheduleMV: {
      payload: Prisma.$ImmunizationScheduleMVPayload<ExtArgs>;
      fields: Prisma.ImmunizationScheduleMVFieldRefs;
      operations: {
        findFirst: {
          args: Prisma.ImmunizationScheduleMVFindFirstArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ImmunizationScheduleMVPayload> | null;
        };
        findFirstOrThrow: {
          args: Prisma.ImmunizationScheduleMVFindFirstOrThrowArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ImmunizationScheduleMVPayload>;
        };
        findMany: {
          args: Prisma.ImmunizationScheduleMVFindManyArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ImmunizationScheduleMVPayload>[];
        };
        aggregate: {
          args: Prisma.ImmunizationScheduleMVAggregateArgs<ExtArgs>;
          result: runtime.Types.Utils.Optional<Prisma.AggregateImmunizationScheduleMV>;
        };
        groupBy: {
          args: Prisma.ImmunizationScheduleMVGroupByArgs<ExtArgs>;
          result: runtime.Types.Utils.Optional<Prisma.ImmunizationScheduleMVGroupByOutputType>[];
        };
        count: {
          args: Prisma.ImmunizationScheduleMVCountArgs<ExtArgs>;
          result:
            | runtime.Types.Utils.Optional<Prisma.ImmunizationScheduleMVCountAggregateOutputType>
            | number;
        };
      };
    };
    MedicalRecordsMV: {
      payload: Prisma.$MedicalRecordsMVPayload<ExtArgs>;
      fields: Prisma.MedicalRecordsMVFieldRefs;
      operations: {
        findFirst: {
          args: Prisma.MedicalRecordsMVFindFirstArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$MedicalRecordsMVPayload> | null;
        };
        findFirstOrThrow: {
          args: Prisma.MedicalRecordsMVFindFirstOrThrowArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$MedicalRecordsMVPayload>;
        };
        findMany: {
          args: Prisma.MedicalRecordsMVFindManyArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$MedicalRecordsMVPayload>[];
        };
        aggregate: {
          args: Prisma.MedicalRecordsMVAggregateArgs<ExtArgs>;
          result: runtime.Types.Utils.Optional<Prisma.AggregateMedicalRecordsMV>;
        };
        groupBy: {
          args: Prisma.MedicalRecordsMVGroupByArgs<ExtArgs>;
          result: runtime.Types.Utils.Optional<Prisma.MedicalRecordsMVGroupByOutputType>[];
        };
        count: {
          args: Prisma.MedicalRecordsMVCountArgs<ExtArgs>;
          result:
            | runtime.Types.Utils.Optional<Prisma.MedicalRecordsMVCountAggregateOutputType>
            | number;
        };
      };
    };
    NotificationsMV: {
      payload: Prisma.$NotificationsMVPayload<ExtArgs>;
      fields: Prisma.NotificationsMVFieldRefs;
      operations: {
        findFirst: {
          args: Prisma.NotificationsMVFindFirstArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$NotificationsMVPayload> | null;
        };
        findFirstOrThrow: {
          args: Prisma.NotificationsMVFindFirstOrThrowArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$NotificationsMVPayload>;
        };
        findMany: {
          args: Prisma.NotificationsMVFindManyArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$NotificationsMVPayload>[];
        };
        aggregate: {
          args: Prisma.NotificationsMVAggregateArgs<ExtArgs>;
          result: runtime.Types.Utils.Optional<Prisma.AggregateNotificationsMV>;
        };
        groupBy: {
          args: Prisma.NotificationsMVGroupByArgs<ExtArgs>;
          result: runtime.Types.Utils.Optional<Prisma.NotificationsMVGroupByOutputType>[];
        };
        count: {
          args: Prisma.NotificationsMVCountArgs<ExtArgs>;
          result:
            | runtime.Types.Utils.Optional<Prisma.NotificationsMVCountAggregateOutputType>
            | number;
        };
      };
    };
    ExpenseAnalysisMV: {
      payload: Prisma.$ExpenseAnalysisMVPayload<ExtArgs>;
      fields: Prisma.ExpenseAnalysisMVFieldRefs;
      operations: {
        findFirst: {
          args: Prisma.ExpenseAnalysisMVFindFirstArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ExpenseAnalysisMVPayload> | null;
        };
        findFirstOrThrow: {
          args: Prisma.ExpenseAnalysisMVFindFirstOrThrowArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ExpenseAnalysisMVPayload>;
        };
        findMany: {
          args: Prisma.ExpenseAnalysisMVFindManyArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ExpenseAnalysisMVPayload>[];
        };
        aggregate: {
          args: Prisma.ExpenseAnalysisMVAggregateArgs<ExtArgs>;
          result: runtime.Types.Utils.Optional<Prisma.AggregateExpenseAnalysisMV>;
        };
        groupBy: {
          args: Prisma.ExpenseAnalysisMVGroupByArgs<ExtArgs>;
          result: runtime.Types.Utils.Optional<Prisma.ExpenseAnalysisMVGroupByOutputType>[];
        };
        count: {
          args: Prisma.ExpenseAnalysisMVCountArgs<ExtArgs>;
          result:
            | runtime.Types.Utils.Optional<Prisma.ExpenseAnalysisMVCountAggregateOutputType>
            | number;
        };
      };
    };
  };
} & {
  other: {
    payload: any;
    operations: {
      $executeRaw: {
        args: [query: TemplateStringsArray | Sql, ...values: any[]];
        result: any;
      };
      $executeRawUnsafe: {
        args: [query: string, ...values: any[]];
        result: any;
      };
      $queryRaw: {
        args: [query: TemplateStringsArray | Sql, ...values: any[]];
        result: any;
      };
      $queryRawUnsafe: {
        args: [query: string, ...values: any[]];
        result: any;
      };
    };
  };
};

/**
 * Enums
 */

export const TransactionIsolationLevel = runtime.makeStrictEnum({
  ReadUncommitted: "ReadUncommitted",
  ReadCommitted: "ReadCommitted",
  RepeatableRead: "RepeatableRead",
  Serializable: "Serializable",
} as const);

export type TransactionIsolationLevel =
  (typeof TransactionIsolationLevel)[keyof typeof TransactionIsolationLevel];

export const TwoFactorScalarFieldEnum = {
  id: "id",
  secret: "secret",
  backupCodes: "backupCodes",
  userId: "userId",
} as const;

export type TwoFactorScalarFieldEnum =
  (typeof TwoFactorScalarFieldEnum)[keyof typeof TwoFactorScalarFieldEnum];

export const RelationLoadStrategy = {
  query: "query",
  join: "join",
} as const;

export type RelationLoadStrategy =
  (typeof RelationLoadStrategy)[keyof typeof RelationLoadStrategy];

export const UserScalarFieldEnum = {
  id: "id",
  email: "email",
  name: "name",
  emailVerified: "emailVerified",
  image: "image",
  bio: "bio",
  timezone: "timezone",
  language: "language",
  createdAt: "createdAt",
  updatedAt: "updatedAt",
  isAdmin: "isAdmin",
  banned: "banned",
  betterAuthId: "betterAuthId",
  clinicId: "clinicId",
  role: "role",
} as const;

export type UserScalarFieldEnum =
  (typeof UserScalarFieldEnum)[keyof typeof UserScalarFieldEnum];

export const SessionScalarFieldEnum = {
  id: "id",
  userId: "userId",
  token: "token",
  expiresAt: "expiresAt",
  ipAddress: "ipAddress",
  userAgent: "userAgent",
  deviceName: "deviceName",
  createdAt: "createdAt",
  updatedAt: "updatedAt",
  lastActiveAt: "lastActiveAt",
} as const;

export type SessionScalarFieldEnum =
  (typeof SessionScalarFieldEnum)[keyof typeof SessionScalarFieldEnum];

export const AccountScalarFieldEnum = {
  id: "id",
  userId: "userId",
  accountId: "accountId",
  providerId: "providerId",
  accessToken: "accessToken",
  refreshToken: "refreshToken",
  idToken: "idToken",
  expiresAt: "expiresAt",
  password: "password",
  createdAt: "createdAt",
  updatedAt: "updatedAt",
} as const;

export type AccountScalarFieldEnum =
  (typeof AccountScalarFieldEnum)[keyof typeof AccountScalarFieldEnum];

export const VerificationScalarFieldEnum = {
  id: "id",
  identifier: "identifier",
  value: "value",
  expiresAt: "expiresAt",
  createdAt: "createdAt",
  updatedAt: "updatedAt",
} as const;

export type VerificationScalarFieldEnum =
  (typeof VerificationScalarFieldEnum)[keyof typeof VerificationScalarFieldEnum];

export const ClinicMemberScalarFieldEnum = {
  id: "id",
  clinicId: "clinicId",
  userId: "userId",
  roleId: "roleId",
  joinedAt: "joinedAt",
} as const;

export type ClinicMemberScalarFieldEnum =
  (typeof ClinicMemberScalarFieldEnum)[keyof typeof ClinicMemberScalarFieldEnum];

export const RoleScalarFieldEnum = {
  id: "id",
  clinicId: "clinicId",
  name: "name",
  description: "description",
  permissions: "permissions",
  isSystem: "isSystem",
  createdAt: "createdAt",
  updatedAt: "updatedAt",
} as const;

export type RoleScalarFieldEnum =
  (typeof RoleScalarFieldEnum)[keyof typeof RoleScalarFieldEnum];

export const ClinicInvitationScalarFieldEnum = {
  id: "id",
  clinicId: "clinicId",
  email: "email",
  invitedById: "invitedById",
  roleId: "roleId",
  token: "token",
  type: "type",
  maxUses: "maxUses",
  usedCount: "usedCount",
  status: "status",
  expiresAt: "expiresAt",
  acceptedAt: "acceptedAt",
  createdAt: "createdAt",
} as const;

export type ClinicInvitationScalarFieldEnum =
  (typeof ClinicInvitationScalarFieldEnum)[keyof typeof ClinicInvitationScalarFieldEnum];

export const NotificationScalarFieldEnum = {
  id: "id",
  userId: "userId",
  title: "title",
  message: "message",
  type: "type",
  read: "read",
  readAt: "readAt",
  createdAt: "createdAt",
} as const;

export type NotificationScalarFieldEnum =
  (typeof NotificationScalarFieldEnum)[keyof typeof NotificationScalarFieldEnum];

export const TwoFactorAuthScalarFieldEnum = {
  id: "id",
  userId: "userId",
  secret: "secret",
  enabled: "enabled",
  backupCodes: "backupCodes",
  createdAt: "createdAt",
  updatedAt: "updatedAt",
} as const;

export type TwoFactorAuthScalarFieldEnum =
  (typeof TwoFactorAuthScalarFieldEnum)[keyof typeof TwoFactorAuthScalarFieldEnum];

export const PasskeyScalarFieldEnum = {
  id: "id",
  userId: "userId",
  credentialId: "credentialId",
  publicKey: "publicKey",
  counter: "counter",
  deviceName: "deviceName",
  lastUsedAt: "lastUsedAt",
  createdAt: "createdAt",
} as const;

export type PasskeyScalarFieldEnum =
  (typeof PasskeyScalarFieldEnum)[keyof typeof PasskeyScalarFieldEnum];

export const SystemSettingsScalarFieldEnum = {
  id: "id",
  clinicId: "clinicId",
  theme: "theme",
  maintenanceMode: "maintenanceMode",
  maintenanceMessage: "maintenanceMessage",
  maintenanceStartedAt: "maintenanceStartedAt",
  maintenanceEndTime: "maintenanceEndTime",
  updatedAt: "updatedAt",
  updatedBy: "updatedBy",
} as const;

export type SystemSettingsScalarFieldEnum =
  (typeof SystemSettingsScalarFieldEnum)[keyof typeof SystemSettingsScalarFieldEnum];

export const APIKeyScalarFieldEnum = {
  id: "id",
  clinicId: "clinicId",
  name: "name",
  key: "key",
  hashedKey: "hashedKey",
  lastUsedAt: "lastUsedAt",
  expiresAt: "expiresAt",
  createdById: "createdById",
  createdAt: "createdAt",
} as const;

export type APIKeyScalarFieldEnum =
  (typeof APIKeyScalarFieldEnum)[keyof typeof APIKeyScalarFieldEnum];

export const SettingsScalarFieldEnum = {
  id: "id",
  key: "key",
  value: "value",
  createdAt: "createdAt",
  updatedAt: "updatedAt",
} as const;

export type SettingsScalarFieldEnum =
  (typeof SettingsScalarFieldEnum)[keyof typeof SettingsScalarFieldEnum];

export const AuditLogScalarFieldEnum = {
  id: "id",
  userId: "userId",
  action: "action",
  level: "level",
  details: "details",
  resource: "resource",
  resourceId: "resourceId",
  metadata: "metadata",
  ipAddress: "ipAddress",
  userAgent: "userAgent",
  createdAt: "createdAt",
  recordId: "recordId",
  model: "model",
  message: "message",
  timestamp: "timestamp",
  clinicId: "clinicId",
  updatedAt: "updatedAt",
} as const;

export type AuditLogScalarFieldEnum =
  (typeof AuditLogScalarFieldEnum)[keyof typeof AuditLogScalarFieldEnum];

export const TodoScalarFieldEnum = {
  id: "id",
  text: "text",
  completed: "completed",
} as const;

export type TodoScalarFieldEnum =
  (typeof TodoScalarFieldEnum)[keyof typeof TodoScalarFieldEnum];

export const FeatureScalarFieldEnum = {
  id: "id",
  clinicId: "clinicId",
  title: "title",
  description: "description",
  icon: "icon",
  color: "color",
  order: "order",
  isActive: "isActive",
} as const;

export type FeatureScalarFieldEnum =
  (typeof FeatureScalarFieldEnum)[keyof typeof FeatureScalarFieldEnum];

export const FileScalarFieldEnum = {
  id: "id",
  slug: "slug",
  userId: "userId",
  folderId: "folderId",
  filename: "filename",
  searchText: "searchText",
  size: "size",
  mimeType: "mimeType",
  createdAt: "createdAt",
  updatedAt: "updatedAt",
} as const;

export type FileScalarFieldEnum =
  (typeof FileScalarFieldEnum)[keyof typeof FileScalarFieldEnum];

export const FolderScalarFieldEnum = {
  id: "id",
  userId: "userId",
  name: "name",
  parentId: "parentId",
  createdAt: "createdAt",
  updatedAt: "updatedAt",
} as const;

export type FolderScalarFieldEnum =
  (typeof FolderScalarFieldEnum)[keyof typeof FolderScalarFieldEnum];

export const ClinicScalarFieldEnum = {
  id: "id",
  name: "name",
  email: "email",
  slug: "slug",
  description: "description",
  archived: "archived",
  archivedAt: "archivedAt",
  archivedBy: "archivedBy",
  createdAt: "createdAt",
  updatedAt: "updatedAt",
  timezone: "timezone",
  address: "address",
  phone: "phone",
  logo: "logo",
  deletedAt: "deletedAt",
  isDeleted: "isDeleted",
} as const;

export type ClinicScalarFieldEnum =
  (typeof ClinicScalarFieldEnum)[keyof typeof ClinicScalarFieldEnum];

export const DoctorScalarFieldEnum = {
  id: "id",
  email: "email",
  name: "name",
  userId: "userId",
  clinicId: "clinicId",
  specialty: "specialty",
  licenseNumber: "licenseNumber",
  phone: "phone",
  address: "address",
  department: "department",
  img: "img",
  colorCode: "colorCode",
  availabilityStatus: "availabilityStatus",
  availableFromWeekDay: "availableFromWeekDay",
  availableToWeekDay: "availableToWeekDay",
  isActive: "isActive",
  status: "status",
  availableFromTime: "availableFromTime",
  availableToTime: "availableToTime",
  type: "type",
  createdAt: "createdAt",
  updatedAt: "updatedAt",
  appointmentPrice: "appointmentPrice",
  role: "role",
  deletedAt: "deletedAt",
  isDeleted: "isDeleted",
} as const;

export type DoctorScalarFieldEnum =
  (typeof DoctorScalarFieldEnum)[keyof typeof DoctorScalarFieldEnum];

export const WorkingDaysScalarFieldEnum = {
  id: "id",
  doctorId: "doctorId",
  clinicId: "clinicId",
  day: "day",
  startTime: "startTime",
  closeTime: "closeTime",
  createdAt: "createdAt",
  updatedAt: "updatedAt",
} as const;

export type WorkingDaysScalarFieldEnum =
  (typeof WorkingDaysScalarFieldEnum)[keyof typeof WorkingDaysScalarFieldEnum];

export const StaffScalarFieldEnum = {
  id: "id",
  email: "email",
  name: "name",
  phone: "phone",
  userId: "userId",
  clinicId: "clinicId",
  address: "address",
  department: "department",
  img: "img",
  licenseNumber: "licenseNumber",
  colorCode: "colorCode",
  hireDate: "hireDate",
  salary: "salary",
  role: "role",
  status: "status",
  createdAt: "createdAt",
  updatedAt: "updatedAt",
  deletedAt: "deletedAt",
  isActive: "isActive",
} as const;

export type StaffScalarFieldEnum =
  (typeof StaffScalarFieldEnum)[keyof typeof StaffScalarFieldEnum];

export const PaymentScalarFieldEnum = {
  id: "id",
  clinicId: "clinicId",
  billId: "billId",
  patientId: "patientId",
  appointmentId: "appointmentId",
  billDate: "billDate",
  paymentDate: "paymentDate",
  discount: "discount",
  totalAmount: "totalAmount",
  amountPaid: "amountPaid",
  amount: "amount",
  status: "status",
  insurance: "insurance",
  insuranceId: "insuranceId",
  serviceDate: "serviceDate",
  dueDate: "dueDate",
  paidDate: "paidDate",
  notes: "notes",
  deletedAt: "deletedAt",
  isDeleted: "isDeleted",
  paymentMethod: "paymentMethod",
  receiptNumber: "receiptNumber",
  createdAt: "createdAt",
  updatedAt: "updatedAt",
} as const;

export type PaymentScalarFieldEnum =
  (typeof PaymentScalarFieldEnum)[keyof typeof PaymentScalarFieldEnum];

export const ReminderScalarFieldEnum = {
  id: "id",
  appointmentId: "appointmentId",
  method: "method",
  sentAt: "sentAt",
  status: "status",
} as const;

export type ReminderScalarFieldEnum =
  (typeof ReminderScalarFieldEnum)[keyof typeof ReminderScalarFieldEnum];

export const PatientBillScalarFieldEnum = {
  id: "id",
  billId: "billId",
  serviceId: "serviceId",
  serviceDate: "serviceDate",
  quantity: "quantity",
  unitCost: "unitCost",
  totalCost: "totalCost",
  createdAt: "createdAt",
  updatedAt: "updatedAt",
} as const;

export type PatientBillScalarFieldEnum =
  (typeof PatientBillScalarFieldEnum)[keyof typeof PatientBillScalarFieldEnum];

export const ServiceScalarFieldEnum = {
  id: "id",
  serviceName: "serviceName",
  description: "description",
  price: "price",
  category: "category",
  duration: "duration",
  isAvailable: "isAvailable",
  clinicId: "clinicId",
  status: "status",
  icon: "icon",
  color: "color",
  createdAt: "createdAt",
  updatedAt: "updatedAt",
  deletedAt: "deletedAt",
  isDeleted: "isDeleted",
} as const;

export type ServiceScalarFieldEnum =
  (typeof ServiceScalarFieldEnum)[keyof typeof ServiceScalarFieldEnum];

export const ClinicSettingScalarFieldEnum = {
  id: "id",
  clinicId: "clinicId",
  openingTime: "openingTime",
  closingTime: "closingTime",
  workingDays: "workingDays",
  defaultAppointmentDuration: "defaultAppointmentDuration",
  requireEmergencyContact: "requireEmergencyContact",
  createdAt: "createdAt",
  updatedAt: "updatedAt",
} as const;

export type ClinicSettingScalarFieldEnum =
  (typeof ClinicSettingScalarFieldEnum)[keyof typeof ClinicSettingScalarFieldEnum];

export const WHOGrowthStandardScalarFieldEnum = {
  id: "id",
  ageInMonths: "ageInMonths",
  ageDays: "ageDays",
  gender: "gender",
  chartType: "chartType",
  measurementType: "measurementType",
  lValue: "lValue",
  mValue: "mValue",
  sValue: "sValue",
  sd0: "sd0",
  sd1neg: "sd1neg",
  sd1pos: "sd1pos",
  sd2neg: "sd2neg",
  sd2pos: "sd2pos",
  sd3neg: "sd3neg",
  sd3pos: "sd3pos",
  sd4neg: "sd4neg",
  sd4pos: "sd4pos",
  createdAt: "createdAt",
  updatedAt: "updatedAt",
} as const;

export type WHOGrowthStandardScalarFieldEnum =
  (typeof WHOGrowthStandardScalarFieldEnum)[keyof typeof WHOGrowthStandardScalarFieldEnum];

export const RatingScalarFieldEnum = {
  id: "id",
  clinicId: "clinicId",
  staffId: "staffId",
  patientId: "patientId",
  rating: "rating",
  comment: "comment",
  createdAt: "createdAt",
  updatedAt: "updatedAt",
} as const;

export type RatingScalarFieldEnum =
  (typeof RatingScalarFieldEnum)[keyof typeof RatingScalarFieldEnum];

export const PrescriptionScalarFieldEnum = {
  id: "id",
  medicalRecordId: "medicalRecordId",
  doctorId: "doctorId",
  patientId: "patientId",
  encounterId: "encounterId",
  medicationName: "medicationName",
  instructions: "instructions",
  issuedDate: "issuedDate",
  endDate: "endDate",
  status: "status",
  clinicId: "clinicId",
  createdAt: "createdAt",
  updatedAt: "updatedAt",
} as const;

export type PrescriptionScalarFieldEnum =
  (typeof PrescriptionScalarFieldEnum)[keyof typeof PrescriptionScalarFieldEnum];

export const DrugScalarFieldEnum = {
  id: "id",
  name: "name",
  createdAt: "createdAt",
  updatedAt: "updatedAt",
} as const;

export type DrugScalarFieldEnum =
  (typeof DrugScalarFieldEnum)[keyof typeof DrugScalarFieldEnum];

export const DoseGuidelineScalarFieldEnum = {
  id: "id",
  drugId: "drugId",
  route: "route",
  clinicalIndication: "clinicalIndication",
  minDosePerKg: "minDosePerKg",
  maxDosePerKg: "maxDosePerKg",
  doseUnit: "doseUnit",
  frequencyDays: "frequencyDays",
  gestationalAgeWeeksMin: "gestationalAgeWeeksMin",
  gestationalAgeWeeksMax: "gestationalAgeWeeksMax",
  postNatalAgeDaysMin: "postNatalAgeDaysMin",
  postNatalAgeDaysMax: "postNatalAgeDaysMax",
  maxDosePer24h: "maxDosePer24h",
  stockConcentrationMgMl: "stockConcentrationMgMl",
  finalConcentrationMgMl: "finalConcentrationMgMl",
  minInfusionTimeMin: "minInfusionTimeMin",
  compatibilityDiluent: "compatibilityDiluent",
  createdAt: "createdAt",
  updatedAt: "updatedAt",
} as const;

export type DoseGuidelineScalarFieldEnum =
  (typeof DoseGuidelineScalarFieldEnum)[keyof typeof DoseGuidelineScalarFieldEnum];

export const PrescribedItemScalarFieldEnum = {
  id: "id",
  prescriptionId: "prescriptionId",
  drugId: "drugId",
  dosageValue: "dosageValue",
  dosageUnit: "dosageUnit",
  frequency: "frequency",
  duration: "duration",
  instructions: "instructions",
  drugRoute: "drugRoute",
  createdAt: "createdAt",
  updatedAt: "updatedAt",
} as const;

export type PrescribedItemScalarFieldEnum =
  (typeof PrescribedItemScalarFieldEnum)[keyof typeof PrescribedItemScalarFieldEnum];

export const GuardianScalarFieldEnum = {
  id: "id",
  patientId: "patientId",
  userId: "userId",
  relation: "relation",
  isPrimary: "isPrimary",
  phone: "phone",
  email: "email",
} as const;

export type GuardianScalarFieldEnum =
  (typeof GuardianScalarFieldEnum)[keyof typeof GuardianScalarFieldEnum];

export const PatientScalarFieldEnum = {
  id: "id",
  clinicId: "clinicId",
  userId: "userId",
  email: "email",
  phone: "phone",
  emergencyContactNumber: "emergencyContactNumber",
  firstName: "firstName",
  lastName: "lastName",
  dateOfBirth: "dateOfBirth",
  ageMonths: "ageMonths",
  ageDays: "ageDays",
  gender: "gender",
  maritalStatus: "maritalStatus",
  nutritionalStatus: "nutritionalStatus",
  address: "address",
  emergencyContactName: "emergencyContactName",
  relation: "relation",
  allergies: "allergies",
  medicalConditions: "medicalConditions",
  medicalHistory: "medicalHistory",
  image: "image",
  colorCode: "colorCode",
  role: "role",
  status: "status",
  isActive: "isActive",
  deletedAt: "deletedAt",
  isDeleted: "isDeleted",
  createdById: "createdById",
  updatedById: "updatedById",
  bloodGroup: "bloodGroup",
  createdAt: "createdAt",
  updatedAt: "updatedAt",
  doctorId: "doctorId",
} as const;

export type PatientScalarFieldEnum =
  (typeof PatientScalarFieldEnum)[keyof typeof PatientScalarFieldEnum];

export const AppointmentScalarFieldEnum = {
  id: "id",
  patientId: "patientId",
  doctorId: "doctorId",
  serviceId: "serviceId",
  doctorSpecialty: "doctorSpecialty",
  clinicId: "clinicId",
  appointmentDate: "appointmentDate",
  time: "time",
  appointmentPrice: "appointmentPrice",
  status: "status",
  type: "type",
  note: "note",
  reason: "reason",
  deletedAt: "deletedAt",
  isDeleted: "isDeleted",
  createdAt: "createdAt",
  updatedAt: "updatedAt",
  duration: "duration",
} as const;

export type AppointmentScalarFieldEnum =
  (typeof AppointmentScalarFieldEnum)[keyof typeof AppointmentScalarFieldEnum];

export const MedicalRecordsScalarFieldEnum = {
  id: "id",
  patientId: "patientId",
  appointmentId: "appointmentId",
  doctorId: "doctorId",
  clinicId: "clinicId",
  diagnosis: "diagnosis",
  symptoms: "symptoms",
  treatmentPlan: "treatmentPlan",
  labRequest: "labRequest",
  notes: "notes",
  attachments: "attachments",
  followUpDate: "followUpDate",
  deletedAt: "deletedAt",
  isDeleted: "isDeleted",
  createdAt: "createdAt",
  updatedAt: "updatedAt",
  subjective: "subjective",
  objective: "objective",
  assessment: "assessment",
  plan: "plan",
  isConfidential: "isConfidential",
  accessLevel: "accessLevel",
  lastAccessedAt: "lastAccessedAt",
  lastAccessedBy: "lastAccessedBy",
} as const;

export type MedicalRecordsScalarFieldEnum =
  (typeof MedicalRecordsScalarFieldEnum)[keyof typeof MedicalRecordsScalarFieldEnum];

export const MedicalRecordAccessScalarFieldEnum = {
  id: "id",
  recordId: "recordId",
  userId: "userId",
  accessType: "accessType",
  purpose: "purpose",
  ipAddress: "ipAddress",
  userAgent: "userAgent",
  accessedAt: "accessedAt",
} as const;

export type MedicalRecordAccessScalarFieldEnum =
  (typeof MedicalRecordAccessScalarFieldEnum)[keyof typeof MedicalRecordAccessScalarFieldEnum];

export const DiagnosisScalarFieldEnum = {
  id: "id",
  patientId: "patientId",
  doctorId: "doctorId",
  clinicId: "clinicId",
  appointmentId: "appointmentId",
  medicalId: "medicalId",
  date: "date",
  type: "type",
  diagnosis: "diagnosis",
  treatment: "treatment",
  notes: "notes",
  symptoms: "symptoms",
  prescribedMedications: "prescribedMedications",
  followUpPlan: "followUpPlan",
  deletedAt: "deletedAt",
  isDeleted: "isDeleted",
  createdAt: "createdAt",
  updatedAt: "updatedAt",
  status: "status",
  typeOfEncounter: "typeOfEncounter",
} as const;

export type DiagnosisScalarFieldEnum =
  (typeof DiagnosisScalarFieldEnum)[keyof typeof DiagnosisScalarFieldEnum];

export const VitalSignsScalarFieldEnum = {
  id: "id",
  patientId: "patientId",
  medicalId: "medicalId",
  encounterId: "encounterId",
  recordedAt: "recordedAt",
  bodyTemperature: "bodyTemperature",
  systolic: "systolic",
  diastolic: "diastolic",
  heartRate: "heartRate",
  respiratoryRate: "respiratoryRate",
  oxygenSaturation: "oxygenSaturation",
  height: "height",
  weight: "weight",
  bmi: "bmi",
  gender: "gender",
  notes: "notes",
  createdAt: "createdAt",
  updatedAt: "updatedAt",
  ageDays: "ageDays",
  ageMonths: "ageMonths",
} as const;

export type VitalSignsScalarFieldEnum =
  (typeof VitalSignsScalarFieldEnum)[keyof typeof VitalSignsScalarFieldEnum];

export const GrowthRecordScalarFieldEnum = {
  id: "id",
  patientId: "patientId",
  clinicId: "clinicId",
  gender: "gender",
  medicalId: "medicalId",
  vitalSignsId: "vitalSignsId",
  ageDays: "ageDays",
  ageMonths: "ageMonths",
  ageYears: "ageYears",
  percentile: "percentile",
  zScore: "zScore",
  headCircumference: "headCircumference",
  bmi: "bmi",
  weightForAgeZ: "weightForAgeZ",
  heightForAgeZ: "heightForAgeZ",
  bmiForAgeZ: "bmiForAgeZ",
  hcForAgeZ: "hcForAgeZ",
  weight: "weight",
  height: "height",
  notes: "notes",
  growthStatus: "growthStatus",
  date: "date",
  recordedAt: "recordedAt",
  createdAt: "createdAt",
  updatedAt: "updatedAt",
  classification: "classification",
  deletedAt: "deletedAt",
  measurementType: "measurementType",
} as const;

export type GrowthRecordScalarFieldEnum =
  (typeof GrowthRecordScalarFieldEnum)[keyof typeof GrowthRecordScalarFieldEnum];

export const ImmunizationScalarFieldEnum = {
  id: "id",
  patientId: "patientId",
  vaccine: "vaccine",
  date: "date",
  dose: "dose",
  lotNumber: "lotNumber",
  administeredByStaffId: "administeredByStaffId",
  notes: "notes",
  createdAt: "createdAt",
  deletedAt: "deletedAt",
  isDeleted: "isDeleted",
  status: "status",
  updatedAt: "updatedAt",
  isOverDue: "isOverDue",
  daysOverDue: "daysOverDue",
} as const;

export type ImmunizationScalarFieldEnum =
  (typeof ImmunizationScalarFieldEnum)[keyof typeof ImmunizationScalarFieldEnum];

export const ConfigStoreScalarFieldEnum = {
  key: "key",
  value: "value",
} as const;

export type ConfigStoreScalarFieldEnum =
  (typeof ConfigStoreScalarFieldEnum)[keyof typeof ConfigStoreScalarFieldEnum];

export const UserQuotaScalarFieldEnum = {
  userId: "userId",
  quota: "quota",
  usedQuota: "usedQuota",
  fileCount: "fileCount",
  fileCountQuota: "fileCountQuota",
  inviteCount: "inviteCount",
  inviteQuota: "inviteQuota",
  updatedAt: "updatedAt",
} as const;

export type UserQuotaScalarFieldEnum =
  (typeof UserQuotaScalarFieldEnum)[keyof typeof UserQuotaScalarFieldEnum];

export const LabTestScalarFieldEnum = {
  id: "id",
  recordId: "recordId",
  serviceId: "serviceId",
  testDate: "testDate",
  result: "result",
  status: "status",
  notes: "notes",
  createdAt: "createdAt",
  updatedAt: "updatedAt",
} as const;

export type LabTestScalarFieldEnum =
  (typeof LabTestScalarFieldEnum)[keyof typeof LabTestScalarFieldEnum];

export const FeedingLogScalarFieldEnum = {
  id: "id",
  patientId: "patientId",
  date: "date",
  type: "type",
  duration: "duration",
  amount: "amount",
  breast: "breast",
  notes: "notes",
} as const;

export type FeedingLogScalarFieldEnum =
  (typeof FeedingLogScalarFieldEnum)[keyof typeof FeedingLogScalarFieldEnum];

export const DevelopmentalMilestoneScalarFieldEnum = {
  id: "id",
  patientId: "patientId",
  milestone: "milestone",
  ageAchieved: "ageAchieved",
  dateRecorded: "dateRecorded",
  notes: "notes",
  createdBy: "createdBy",
  updatedBy: "updatedBy",
  createdAt: "createdAt",
  updatedAt: "updatedAt",
} as const;

export type DevelopmentalMilestoneScalarFieldEnum =
  (typeof DevelopmentalMilestoneScalarFieldEnum)[keyof typeof DevelopmentalMilestoneScalarFieldEnum];

export const DevelopmentalCheckScalarFieldEnum = {
  id: "id",
  patientId: "patientId",
  checkDate: "checkDate",
  ageMonths: "ageMonths",
  motorSkills: "motorSkills",
  languageSkills: "languageSkills",
  socialSkills: "socialSkills",
  cognitiveSkills: "cognitiveSkills",
  milestonesMet: "milestonesMet",
  milestonesPending: "milestonesPending",
  concerns: "concerns",
  recommendations: "recommendations",
  createdAt: "createdAt",
  updatedAt: "updatedAt",
} as const;

export type DevelopmentalCheckScalarFieldEnum =
  (typeof DevelopmentalCheckScalarFieldEnum)[keyof typeof DevelopmentalCheckScalarFieldEnum];

export const VaccineScheduleScalarFieldEnum = {
  id: "id",
  vaccineName: "vaccineName",
  recommendedAge: "recommendedAge",
  dosesRequired: "dosesRequired",
  minimumInterval: "minimumInterval",
  isMandatory: "isMandatory",
  description: "description",
  createdAt: "createdAt",
  updatedAt: "updatedAt",
  ageInDaysMin: "ageInDaysMin",
  ageInDaysMax: "ageInDaysMax",
} as const;

export type VaccineScheduleScalarFieldEnum =
  (typeof VaccineScheduleScalarFieldEnum)[keyof typeof VaccineScheduleScalarFieldEnum];

export const ExpenseScalarFieldEnum = {
  id: "id",
  clinicId: "clinicId",
  subCategoryId: "subCategoryId",
  amount: "amount",
  date: "date",
  description: "description",
  createdAt: "createdAt",
  updatedAt: "updatedAt",
} as const;

export type ExpenseScalarFieldEnum =
  (typeof ExpenseScalarFieldEnum)[keyof typeof ExpenseScalarFieldEnum];

export const ExpenseCategoryScalarFieldEnum = {
  id: "id",
  name: "name",
  color: "color",
} as const;

export type ExpenseCategoryScalarFieldEnum =
  (typeof ExpenseCategoryScalarFieldEnum)[keyof typeof ExpenseCategoryScalarFieldEnum];

export const ExpenseSubCategoryScalarFieldEnum = {
  id: "id",
  name: "name",
  color: "color",
  categoryId: "categoryId",
} as const;

export type ExpenseSubCategoryScalarFieldEnum =
  (typeof ExpenseSubCategoryScalarFieldEnum)[keyof typeof ExpenseSubCategoryScalarFieldEnum];

export const FileStorageScalarFieldEnum = {
  id: "id",
  fileName: "fileName",
  filePath: "filePath",
  fileType: "fileType",
  fileSize: "fileSize",
  mimeType: "mimeType",
  isSecure: "isSecure",
  accessToken: "accessToken",
  tokenExpiry: "tokenExpiry",
  description: "description",
  metadata: "metadata",
  clinicId: "clinicId",
  userId: "userId",
  createdAt: "createdAt",
  updatedAt: "updatedAt",
  status: "status",
  uploadExpiresAt: "uploadExpiresAt",
  doctorId: "doctorId",
  patientId: "patientId",
} as const;

export type FileStorageScalarFieldEnum =
  (typeof FileStorageScalarFieldEnum)[keyof typeof FileStorageScalarFieldEnum];

export const TrainingFileScalarFieldEnum = {
  id: "id",
  knowledgeBaseId: "knowledgeBaseId",
  fileStorageId: "fileStorageId",
  status: "status",
  errorMessage: "errorMessage",
  processedAt: "processedAt",
  createdAt: "createdAt",
  updatedAt: "updatedAt",
} as const;

export type TrainingFileScalarFieldEnum =
  (typeof TrainingFileScalarFieldEnum)[keyof typeof TrainingFileScalarFieldEnum];

export const KnowledgeBaseScalarFieldEnum = {
  id: "id",
  clinicId: "clinicId",
  name: "name",
  description: "description",
  vectorStoreId: "vectorStoreId",
  status: "status",
  createdAt: "createdAt",
  updatedAt: "updatedAt",
} as const;

export type KnowledgeBaseScalarFieldEnum =
  (typeof KnowledgeBaseScalarFieldEnum)[keyof typeof KnowledgeBaseScalarFieldEnum];

export const TrainingWebsiteScalarFieldEnum = {
  id: "id",
  knowledgeBaseId: "knowledgeBaseId",
  url: "url",
  status: "status",
  errorMessage: "errorMessage",
  processedAt: "processedAt",
  createdAt: "createdAt",
  updatedAt: "updatedAt",
} as const;

export type TrainingWebsiteScalarFieldEnum =
  (typeof TrainingWebsiteScalarFieldEnum)[keyof typeof TrainingWebsiteScalarFieldEnum];

export const AgentScalarFieldEnum = {
  id: "id",
  clinicId: "clinicId",
  knowledgeBaseId: "knowledgeBaseId",
  name: "name",
  description: "description",
  systemPrompt: "systemPrompt",
  model: "model",
  temperature: "temperature",
  maxTokens: "maxTokens",
  isActive: "isActive",
  createdAt: "createdAt",
  updatedAt: "updatedAt",
} as const;

export type AgentScalarFieldEnum =
  (typeof AgentScalarFieldEnum)[keyof typeof AgentScalarFieldEnum];

export const ClinicDashboardMVScalarFieldEnum = {
  clinicId: "clinicId",
  clinicName: "clinicName",
  totalAppointments: "totalAppointments",
  todayAppointments: "todayAppointments",
  upcomingAppointments: "upcomingAppointments",
  completedAppointments: "completedAppointments",
  totalPatients: "totalPatients",
  activePatients: "activePatients",
  newPatientsThisMonth: "newPatientsThisMonth",
  monthlyRevenue: "monthlyRevenue",
  pendingPayments: "pendingPayments",
  totalRevenue: "totalRevenue",
  activeDoctors: "activeDoctors",
  averageDoctorRating: "averageDoctorRating",
  immunizationsDue: "immunizationsDue",
  growthChecksPending: "growthChecksPending",
  totalStaff: "totalStaff",
  updatedAt: "updatedAt",
} as const;

export type ClinicDashboardMVScalarFieldEnum =
  (typeof ClinicDashboardMVScalarFieldEnum)[keyof typeof ClinicDashboardMVScalarFieldEnum];

export const PatientOverviewMVScalarFieldEnum = {
  patientId: "patientId",
  patientPublicId: "patientPublicId",
  fullName: "fullName",
  dateOfBirth: "dateOfBirth",
  ageMonths: "ageMonths",
  gender: "gender",
  bloodGroup: "bloodGroup",
  medicalRecordNumber: "medicalRecordNumber",
  phone: "phone",
  email: "email",
  address: "address",
  allergies: "allergies",
  medicalConditions: "medicalConditions",
  primaryCarePhysician: "primaryCarePhysician",
  totalAppointments: "totalAppointments",
  lastAppointmentDate: "lastAppointmentDate",
  upcomingAppointments: "upcomingAppointments",
  totalDiagnosis: "totalDiagnosis",
  totalPrescriptions: "totalPrescriptions",
  activePrescriptions: "activePrescriptions",
  totalImmunizations: "totalImmunizations",
  pendingImmunizations: "pendingImmunizations",
  lastWeight: "lastWeight",
  lastHeight: "lastHeight",
  lastGrowthCheck: "lastGrowthCheck",
  primaryGuardian: "primaryGuardian",
  guardianPhone: "guardianPhone",
  clinicId: "clinicId",
  updatedAt: "updatedAt",
} as const;

export type PatientOverviewMVScalarFieldEnum =
  (typeof PatientOverviewMVScalarFieldEnum)[keyof typeof PatientOverviewMVScalarFieldEnum];

export const DoctorPerformanceMVScalarFieldEnum = {
  doctorId: "doctorId",
  doctorPublicId: "doctorPublicId",
  name: "name",
  specialty: "specialty",
  email: "email",
  phone: "phone",
  rating: "rating",
  yearsOfExperience: "yearsOfExperience",
  totalAppointments: "totalAppointments",
  appointmentsThisMonth: "appointmentsThisMonth",
  completedAppointments: "completedAppointments",
  cancellationRate: "cancellationRate",
  totalPatients: "totalPatients",
  newPatientsThisMonth: "newPatientsThisMonth",
  totalRevenue: "totalRevenue",
  monthlyRevenue: "monthlyRevenue",
  totalPrescriptions: "totalPrescriptions",
  activePrescriptions: "activePrescriptions",
  averagePatientRating: "averagePatientRating",
  totalRatings: "totalRatings",
  averagePatientsPerDay: "averagePatientsPerDay",
  utilizationRate: "utilizationRate",
  clinicId: "clinicId",
  updatedAt: "updatedAt",
} as const;

export type DoctorPerformanceMVScalarFieldEnum =
  (typeof DoctorPerformanceMVScalarFieldEnum)[keyof typeof DoctorPerformanceMVScalarFieldEnum];

export const FinancialOverviewMVScalarFieldEnum = {
  clinicId: "clinicId",
  clinicName: "clinicName",
  currentMonthRevenue: "currentMonthRevenue",
  previousMonthRevenue: "previousMonthRevenue",
  consultationRevenue: "consultationRevenue",
  procedureRevenue: "procedureRevenue",
  labRevenue: "labRevenue",
  vaccinationRevenue: "vaccinationRevenue",
  totalRevenue: "totalRevenue",
  paidAmount: "paidAmount",
  pendingAmount: "pendingAmount",
  totalExpenses: "totalExpenses",
  payrollExpenses: "payrollExpenses",
  medicalSupplyExpenses: "medicalSupplyExpenses",
  facilityExpenses: "facilityExpenses",
  netProfit: "netProfit",
  profitMargin: "profitMargin",
  topService: "topService",
  topDoctor: "topDoctor",
  updatedAt: "updatedAt",
} as const;

export type FinancialOverviewMVScalarFieldEnum =
  (typeof FinancialOverviewMVScalarFieldEnum)[keyof typeof FinancialOverviewMVScalarFieldEnum];

export const AppointmentScheduleMVScalarFieldEnum = {
  appointmentId: "appointmentId",
  appointmentPublicId: "appointmentPublicId",
  date: "date",
  startTime: "startTime",
  durationMinutes: "durationMinutes",
  status: "status",
  type: "type",
  reason: "reason",
  patientId: "patientId",
  patientPublicId: "patientPublicId",
  patientName: "patientName",
  patientAgeMonths: "patientAgeMonths",
  patientGender: "patientGender",
  patientPhone: "patientPhone",
  doctorId: "doctorId",
  doctorPublicId: "doctorPublicId",
  doctorName: "doctorName",
  doctorSpecialty: "doctorSpecialty",
  doctorColorCode: "doctorColorCode",
  serviceId: "serviceId",
  serviceName: "serviceName",
  serviceCategory: "serviceCategory",
  servicePrice: "servicePrice",
  paymentStatus: "paymentStatus",
  totalAmount: "totalAmount",
  amountPaid: "amountPaid",
  clinicId: "clinicId",
  updatedAt: "updatedAt",
} as const;

export type AppointmentScheduleMVScalarFieldEnum =
  (typeof AppointmentScheduleMVScalarFieldEnum)[keyof typeof AppointmentScheduleMVScalarFieldEnum];

export const PatientGrowthChartMVScalarFieldEnum = {
  patientId: "patientId",
  patientPublicId: "patientPublicId",
  fullName: "fullName",
  gender: "gender",
  dateOfBirth: "dateOfBirth",
  ageDays: "ageDays",
  ageMonths: "ageMonths",
  weight: "weight",
  height: "height",
  headCircumference: "headCircumference",
  bmi: "bmi",
  weightForAgeZ: "weightForAgeZ",
  heightForAgeZ: "heightForAgeZ",
  hcForAgeZ: "hcForAgeZ",
  weightPercentile: "weightPercentile",
  heightPercentile: "heightPercentile",
  growthStatus: "growthStatus",
  recordedBy: "recordedBy",
  notes: "notes",
  recordedAt: "recordedAt",
  clinicId: "clinicId",
  updatedAt: "updatedAt",
} as const;

export type PatientGrowthChartMVScalarFieldEnum =
  (typeof PatientGrowthChartMVScalarFieldEnum)[keyof typeof PatientGrowthChartMVScalarFieldEnum];

export const ImmunizationScheduleMVScalarFieldEnum = {
  patientId: "patientId",
  patientPublicId: "patientPublicId",
  fullName: "fullName",
  dateOfBirth: "dateOfBirth",
  ageMonths: "ageMonths",
  immunizationId: "immunizationId",
  vaccineName: "vaccineName",
  doseNumber: "doseNumber",
  totalDoses: "totalDoses",
  administrationDate: "administrationDate",
  nextDueDate: "nextDueDate",
  status: "status",
  recommendedAgeDays: "recommendedAgeDays",
  isMandatory: "isMandatory",
  description: "description",
  daysOverdue: "daysOverdue",
  daysUntilDue: "daysUntilDue",
  isOverdue: "isOverdue",
  administeringDoctor: "administeringDoctor",
  manufacturer: "manufacturer",
  batchNumber: "batchNumber",
  notes: "notes",
  clinicId: "clinicId",
  updatedAt: "updatedAt",
} as const;

export type ImmunizationScheduleMVScalarFieldEnum =
  (typeof ImmunizationScheduleMVScalarFieldEnum)[keyof typeof ImmunizationScheduleMVScalarFieldEnum];

export const MedicalRecordsMVScalarFieldEnum = {
  medicalRecordId: "medicalRecordId",
  medicalRecordPublicId: "medicalRecordPublicId",
  patientId: "patientId",
  patientPublicId: "patientPublicId",
  patientName: "patientName",
  patientAgeAtDiagnosis: "patientAgeAtDiagnosis",
  doctorId: "doctorId",
  doctorPublicId: "doctorPublicId",
  doctorName: "doctorName",
  doctorSpecialty: "doctorSpecialty",
  encounterId: "encounterId",
  encounterDate: "encounterDate",
  encounterType: "encounterType",
  diagnosis: "diagnosis",
  treatment: "treatment",
  appointmentId: "appointmentId",
  appointmentDate: "appointmentDate",
  appointmentReason: "appointmentReason",
  subjective: "subjective",
  objective: "objective",
  assessment: "assessment",
  plan: "plan",
  symptoms: "symptoms",
  medications: "medications",
  followUpDate: "followUpDate",
  isConfidential: "isConfidential",
  temperature: "temperature",
  heartRate: "heartRate",
  systolic: "systolic",
  diastolic: "diastolic",
  respiratoryRate: "respiratoryRate",
  oxygenSaturation: "oxygenSaturation",
  weight: "weight",
  height: "height",
  prescriptionCount: "prescriptionCount",
  labTestCount: "labTestCount",
  clinicId: "clinicId",
  updatedAt: "updatedAt",
} as const;

export type MedicalRecordsMVScalarFieldEnum =
  (typeof MedicalRecordsMVScalarFieldEnum)[keyof typeof MedicalRecordsMVScalarFieldEnum];

export const NotificationsMVScalarFieldEnum = {
  notificationId: "notificationId",
  notificationPublicId: "notificationPublicId",
  userId: "userId",
  type: "type",
  title: "title",
  message: "message",
  data: "data",
  isRead: "isRead",
  priority: "priority",
  actionUrl: "actionUrl",
  createdAt: "createdAt",
  expiresAt: "expiresAt",
  clinicId: "clinicId",
  clinicName: "clinicName",
  daysSinceCreated: "daysSinceCreated",
  isExpired: "isExpired",
  relatedPatientId: "relatedPatientId",
  relatedAppointmentId: "relatedAppointmentId",
  relatedDoctorId: "relatedDoctorId",
  updatedAt: "updatedAt",
} as const;

export type NotificationsMVScalarFieldEnum =
  (typeof NotificationsMVScalarFieldEnum)[keyof typeof NotificationsMVScalarFieldEnum];

export const ExpenseAnalysisMVScalarFieldEnum = {
  clinicId: "clinicId",
  clinicName: "clinicName",
  expenseCategoryId: "expenseCategoryId",
  expenseCategoryName: "expenseCategoryName",
  expenseCategoryColor: "expenseCategoryColor",
  expenseSubcategoryId: "expenseSubcategoryId",
  expenseSubcategoryName: "expenseSubcategoryName",
  expenseSubcategoryColor: "expenseSubcategoryColor",
  expenseId: "expenseId",
  expensePublicId: "expensePublicId",
  amount: "amount",
  date: "date",
  description: "description",
  year: "year",
  month: "month",
  monthName: "monthName",
  quarter: "quarter",
  monthlyAverage: "monthlyAverage",
  categoryPercentage: "categoryPercentage",
  previousMonthAmount: "previousMonthAmount",
  monthOverMonthChange: "monthOverMonthChange",
  updatedAt: "updatedAt",
} as const;

export type ExpenseAnalysisMVScalarFieldEnum =
  (typeof ExpenseAnalysisMVScalarFieldEnum)[keyof typeof ExpenseAnalysisMVScalarFieldEnum];

export const SortOrder = {
  asc: "asc",
  desc: "desc",
} as const;

export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder];

export const JsonNullValueInput = {
  JsonNull: JsonNull,
} as const;

export type JsonNullValueInput =
  (typeof JsonNullValueInput)[keyof typeof JsonNullValueInput];

export const NullableJsonNullValueInput = {
  DbNull: DbNull,
  JsonNull: JsonNull,
} as const;

export type NullableJsonNullValueInput =
  (typeof NullableJsonNullValueInput)[keyof typeof NullableJsonNullValueInput];

export const QueryMode = {
  default: "default",
  insensitive: "insensitive",
} as const;

export type QueryMode = (typeof QueryMode)[keyof typeof QueryMode];

export const NullsOrder = {
  first: "first",
  last: "last",
} as const;

export type NullsOrder = (typeof NullsOrder)[keyof typeof NullsOrder];

export const JsonNullValueFilter = {
  DbNull: DbNull,
  JsonNull: JsonNull,
  AnyNull: AnyNull,
} as const;

export type JsonNullValueFilter =
  (typeof JsonNullValueFilter)[keyof typeof JsonNullValueFilter];

/**
 * Field references
 */

/**
 * Reference to a field of type 'String'
 */
export type StringFieldRefInput<$PrismaModel> = FieldRefInputType<
  $PrismaModel,
  "String"
>;

/**
 * Reference to a field of type 'String[]'
 */
export type ListStringFieldRefInput<$PrismaModel> = FieldRefInputType<
  $PrismaModel,
  "String[]"
>;

/**
 * Reference to a field of type 'Boolean'
 */
export type BooleanFieldRefInput<$PrismaModel> = FieldRefInputType<
  $PrismaModel,
  "Boolean"
>;

/**
 * Reference to a field of type 'DateTime'
 */
export type DateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<
  $PrismaModel,
  "DateTime"
>;

/**
 * Reference to a field of type 'DateTime[]'
 */
export type ListDateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<
  $PrismaModel,
  "DateTime[]"
>;

/**
 * Reference to a field of type 'UserRole'
 */
export type EnumUserRoleFieldRefInput<$PrismaModel> = FieldRefInputType<
  $PrismaModel,
  "UserRole"
>;

/**
 * Reference to a field of type 'UserRole[]'
 */
export type ListEnumUserRoleFieldRefInput<$PrismaModel> = FieldRefInputType<
  $PrismaModel,
  "UserRole[]"
>;

/**
 * Reference to a field of type 'Json'
 */
export type JsonFieldRefInput<$PrismaModel> = FieldRefInputType<
  $PrismaModel,
  "Json"
>;

/**
 * Reference to a field of type 'QueryMode'
 */
export type EnumQueryModeFieldRefInput<$PrismaModel> = FieldRefInputType<
  $PrismaModel,
  "QueryMode"
>;

/**
 * Reference to a field of type 'Int'
 */
export type IntFieldRefInput<$PrismaModel> = FieldRefInputType<
  $PrismaModel,
  "Int"
>;

/**
 * Reference to a field of type 'Int[]'
 */
export type ListIntFieldRefInput<$PrismaModel> = FieldRefInputType<
  $PrismaModel,
  "Int[]"
>;

/**
 * Reference to a field of type 'AvailabilityStatus'
 */
export type EnumAvailabilityStatusFieldRefInput<$PrismaModel> =
  FieldRefInputType<$PrismaModel, "AvailabilityStatus">;

/**
 * Reference to a field of type 'AvailabilityStatus[]'
 */
export type ListEnumAvailabilityStatusFieldRefInput<$PrismaModel> =
  FieldRefInputType<$PrismaModel, "AvailabilityStatus[]">;

/**
 * Reference to a field of type 'Status'
 */
export type EnumStatusFieldRefInput<$PrismaModel> = FieldRefInputType<
  $PrismaModel,
  "Status"
>;

/**
 * Reference to a field of type 'Status[]'
 */
export type ListEnumStatusFieldRefInput<$PrismaModel> = FieldRefInputType<
  $PrismaModel,
  "Status[]"
>;

/**
 * Reference to a field of type 'JOBTYPE'
 */
export type EnumJOBTYPEFieldRefInput<$PrismaModel> = FieldRefInputType<
  $PrismaModel,
  "JOBTYPE"
>;

/**
 * Reference to a field of type 'JOBTYPE[]'
 */
export type ListEnumJOBTYPEFieldRefInput<$PrismaModel> = FieldRefInputType<
  $PrismaModel,
  "JOBTYPE[]"
>;

/**
 * Reference to a field of type 'Decimal'
 */
export type DecimalFieldRefInput<$PrismaModel> = FieldRefInputType<
  $PrismaModel,
  "Decimal"
>;

/**
 * Reference to a field of type 'Decimal[]'
 */
export type ListDecimalFieldRefInput<$PrismaModel> = FieldRefInputType<
  $PrismaModel,
  "Decimal[]"
>;

/**
 * Reference to a field of type 'Float'
 */
export type FloatFieldRefInput<$PrismaModel> = FieldRefInputType<
  $PrismaModel,
  "Float"
>;

/**
 * Reference to a field of type 'Float[]'
 */
export type ListFloatFieldRefInput<$PrismaModel> = FieldRefInputType<
  $PrismaModel,
  "Float[]"
>;

/**
 * Reference to a field of type 'PaymentStatus'
 */
export type EnumPaymentStatusFieldRefInput<$PrismaModel> = FieldRefInputType<
  $PrismaModel,
  "PaymentStatus"
>;

/**
 * Reference to a field of type 'PaymentStatus[]'
 */
export type ListEnumPaymentStatusFieldRefInput<$PrismaModel> =
  FieldRefInputType<$PrismaModel, "PaymentStatus[]">;

/**
 * Reference to a field of type 'PaymentMethod'
 */
export type EnumPaymentMethodFieldRefInput<$PrismaModel> = FieldRefInputType<
  $PrismaModel,
  "PaymentMethod"
>;

/**
 * Reference to a field of type 'PaymentMethod[]'
 */
export type ListEnumPaymentMethodFieldRefInput<$PrismaModel> =
  FieldRefInputType<$PrismaModel, "PaymentMethod[]">;

/**
 * Reference to a field of type 'ReminderMethod'
 */
export type EnumReminderMethodFieldRefInput<$PrismaModel> = FieldRefInputType<
  $PrismaModel,
  "ReminderMethod"
>;

/**
 * Reference to a field of type 'ReminderMethod[]'
 */
export type ListEnumReminderMethodFieldRefInput<$PrismaModel> =
  FieldRefInputType<$PrismaModel, "ReminderMethod[]">;

/**
 * Reference to a field of type 'ReminderStatus'
 */
export type EnumReminderStatusFieldRefInput<$PrismaModel> = FieldRefInputType<
  $PrismaModel,
  "ReminderStatus"
>;

/**
 * Reference to a field of type 'ReminderStatus[]'
 */
export type ListEnumReminderStatusFieldRefInput<$PrismaModel> =
  FieldRefInputType<$PrismaModel, "ReminderStatus[]">;

/**
 * Reference to a field of type 'ServiceCategory'
 */
export type EnumServiceCategoryFieldRefInput<$PrismaModel> = FieldRefInputType<
  $PrismaModel,
  "ServiceCategory"
>;

/**
 * Reference to a field of type 'ServiceCategory[]'
 */
export type ListEnumServiceCategoryFieldRefInput<$PrismaModel> =
  FieldRefInputType<$PrismaModel, "ServiceCategory[]">;

/**
 * Reference to a field of type 'Gender'
 */
export type EnumGenderFieldRefInput<$PrismaModel> = FieldRefInputType<
  $PrismaModel,
  "Gender"
>;

/**
 * Reference to a field of type 'Gender[]'
 */
export type ListEnumGenderFieldRefInput<$PrismaModel> = FieldRefInputType<
  $PrismaModel,
  "Gender[]"
>;

/**
 * Reference to a field of type 'ChartType'
 */
export type EnumChartTypeFieldRefInput<$PrismaModel> = FieldRefInputType<
  $PrismaModel,
  "ChartType"
>;

/**
 * Reference to a field of type 'ChartType[]'
 */
export type ListEnumChartTypeFieldRefInput<$PrismaModel> = FieldRefInputType<
  $PrismaModel,
  "ChartType[]"
>;

/**
 * Reference to a field of type 'MeasurementType'
 */
export type EnumMeasurementTypeFieldRefInput<$PrismaModel> = FieldRefInputType<
  $PrismaModel,
  "MeasurementType"
>;

/**
 * Reference to a field of type 'MeasurementType[]'
 */
export type ListEnumMeasurementTypeFieldRefInput<$PrismaModel> =
  FieldRefInputType<$PrismaModel, "MeasurementType[]">;

/**
 * Reference to a field of type 'DosageUnit'
 */
export type EnumDosageUnitFieldRefInput<$PrismaModel> = FieldRefInputType<
  $PrismaModel,
  "DosageUnit"
>;

/**
 * Reference to a field of type 'DosageUnit[]'
 */
export type ListEnumDosageUnitFieldRefInput<$PrismaModel> = FieldRefInputType<
  $PrismaModel,
  "DosageUnit[]"
>;

/**
 * Reference to a field of type 'DrugRoute'
 */
export type EnumDrugRouteFieldRefInput<$PrismaModel> = FieldRefInputType<
  $PrismaModel,
  "DrugRoute"
>;

/**
 * Reference to a field of type 'DrugRoute[]'
 */
export type ListEnumDrugRouteFieldRefInput<$PrismaModel> = FieldRefInputType<
  $PrismaModel,
  "DrugRoute[]"
>;

/**
 * Reference to a field of type 'AppointmentStatus'
 */
export type EnumAppointmentStatusFieldRefInput<$PrismaModel> =
  FieldRefInputType<$PrismaModel, "AppointmentStatus">;

/**
 * Reference to a field of type 'AppointmentStatus[]'
 */
export type ListEnumAppointmentStatusFieldRefInput<$PrismaModel> =
  FieldRefInputType<$PrismaModel, "AppointmentStatus[]">;

/**
 * Reference to a field of type 'AppointmentType'
 */
export type EnumAppointmentTypeFieldRefInput<$PrismaModel> = FieldRefInputType<
  $PrismaModel,
  "AppointmentType"
>;

/**
 * Reference to a field of type 'AppointmentType[]'
 */
export type ListEnumAppointmentTypeFieldRefInput<$PrismaModel> =
  FieldRefInputType<$PrismaModel, "AppointmentType[]">;

/**
 * Reference to a field of type 'AccessLevel'
 */
export type EnumAccessLevelFieldRefInput<$PrismaModel> = FieldRefInputType<
  $PrismaModel,
  "AccessLevel"
>;

/**
 * Reference to a field of type 'AccessLevel[]'
 */
export type ListEnumAccessLevelFieldRefInput<$PrismaModel> = FieldRefInputType<
  $PrismaModel,
  "AccessLevel[]"
>;

/**
 * Reference to a field of type 'AccessType'
 */
export type EnumAccessTypeFieldRefInput<$PrismaModel> = FieldRefInputType<
  $PrismaModel,
  "AccessType"
>;

/**
 * Reference to a field of type 'AccessType[]'
 */
export type ListEnumAccessTypeFieldRefInput<$PrismaModel> = FieldRefInputType<
  $PrismaModel,
  "AccessType[]"
>;

/**
 * Reference to a field of type 'EncounterStatus'
 */
export type EnumEncounterStatusFieldRefInput<$PrismaModel> = FieldRefInputType<
  $PrismaModel,
  "EncounterStatus"
>;

/**
 * Reference to a field of type 'EncounterStatus[]'
 */
export type ListEnumEncounterStatusFieldRefInput<$PrismaModel> =
  FieldRefInputType<$PrismaModel, "EncounterStatus[]">;

/**
 * Reference to a field of type 'EncounterType'
 */
export type EnumEncounterTypeFieldRefInput<$PrismaModel> = FieldRefInputType<
  $PrismaModel,
  "EncounterType"
>;

/**
 * Reference to a field of type 'EncounterType[]'
 */
export type ListEnumEncounterTypeFieldRefInput<$PrismaModel> =
  FieldRefInputType<$PrismaModel, "EncounterType[]">;

/**
 * Reference to a field of type 'GrowthStatus'
 */
export type EnumGrowthStatusFieldRefInput<$PrismaModel> = FieldRefInputType<
  $PrismaModel,
  "GrowthStatus"
>;

/**
 * Reference to a field of type 'GrowthStatus[]'
 */
export type ListEnumGrowthStatusFieldRefInput<$PrismaModel> = FieldRefInputType<
  $PrismaModel,
  "GrowthStatus[]"
>;

/**
 * Reference to a field of type 'ImmunizationStatus'
 */
export type EnumImmunizationStatusFieldRefInput<$PrismaModel> =
  FieldRefInputType<$PrismaModel, "ImmunizationStatus">;

/**
 * Reference to a field of type 'ImmunizationStatus[]'
 */
export type ListEnumImmunizationStatusFieldRefInput<$PrismaModel> =
  FieldRefInputType<$PrismaModel, "ImmunizationStatus[]">;

/**
 * Reference to a field of type 'LabStatus'
 */
export type EnumLabStatusFieldRefInput<$PrismaModel> = FieldRefInputType<
  $PrismaModel,
  "LabStatus"
>;

/**
 * Reference to a field of type 'LabStatus[]'
 */
export type ListEnumLabStatusFieldRefInput<$PrismaModel> = FieldRefInputType<
  $PrismaModel,
  "LabStatus[]"
>;

/**
 * Reference to a field of type 'FeedingType'
 */
export type EnumFeedingTypeFieldRefInput<$PrismaModel> = FieldRefInputType<
  $PrismaModel,
  "FeedingType"
>;

/**
 * Reference to a field of type 'FeedingType[]'
 */
export type ListEnumFeedingTypeFieldRefInput<$PrismaModel> = FieldRefInputType<
  $PrismaModel,
  "FeedingType[]"
>;

/**
 * Reference to a field of type 'DevelopmentStatus'
 */
export type EnumDevelopmentStatusFieldRefInput<$PrismaModel> =
  FieldRefInputType<$PrismaModel, "DevelopmentStatus">;

/**
 * Reference to a field of type 'DevelopmentStatus[]'
 */
export type ListEnumDevelopmentStatusFieldRefInput<$PrismaModel> =
  FieldRefInputType<$PrismaModel, "DevelopmentStatus[]">;

/**
 * Reference to a field of type 'TrainingFileStatus'
 */
export type EnumTrainingFileStatusFieldRefInput<$PrismaModel> =
  FieldRefInputType<$PrismaModel, "TrainingFileStatus">;

/**
 * Reference to a field of type 'TrainingFileStatus[]'
 */
export type ListEnumTrainingFileStatusFieldRefInput<$PrismaModel> =
  FieldRefInputType<$PrismaModel, "TrainingFileStatus[]">;

/**
 * Reference to a field of type 'KnowledgeBaseStatus'
 */
export type EnumKnowledgeBaseStatusFieldRefInput<$PrismaModel> =
  FieldRefInputType<$PrismaModel, "KnowledgeBaseStatus">;

/**
 * Reference to a field of type 'KnowledgeBaseStatus[]'
 */
export type ListEnumKnowledgeBaseStatusFieldRefInput<$PrismaModel> =
  FieldRefInputType<$PrismaModel, "KnowledgeBaseStatus[]">;

/**
 * Reference to a field of type 'TrainingWebsiteStatus'
 */
export type EnumTrainingWebsiteStatusFieldRefInput<$PrismaModel> =
  FieldRefInputType<$PrismaModel, "TrainingWebsiteStatus">;

/**
 * Reference to a field of type 'TrainingWebsiteStatus[]'
 */
export type ListEnumTrainingWebsiteStatusFieldRefInput<$PrismaModel> =
  FieldRefInputType<$PrismaModel, "TrainingWebsiteStatus[]">;

/**
 * Batch Payload for updateMany & deleteMany & createMany
 */
export type BatchPayload = {
  count: number;
};

export const defineExtension = runtime.Extensions
  .defineExtension as unknown as runtime.Types.Extensions.ExtendsHook<
  "define",
  TypeMapCb,
  runtime.Types.Extensions.DefaultArgs
>;
export type DefaultPrismaClient = PrismaClient;
export type ErrorFormat = "pretty" | "colorless" | "minimal";
export type PrismaClientOptions = (
  | {
      /**
       * Instance of a Driver Adapter, e.g., like one provided by `@prisma/adapter-pg`.
       */
      adapter: runtime.SqlDriverAdapterFactory;
      accelerateUrl?: never;
    }
  | {
      /**
       * Prisma Accelerate URL allowing the client to connect through Accelerate instead of a direct database.
       */
      accelerateUrl: string;
      adapter?: never;
    }
) & {
  /**
   * @default "colorless"
   */
  errorFormat?: ErrorFormat;
  /**
   * @example
   * ```
   * // Shorthand for `emit: 'stdout'`
   * log: ['query', 'info', 'warn', 'error']
   *
   * // Emit as events only
   * log: [
   *   { emit: 'event', level: 'query' },
   *   { emit: 'event', level: 'info' },
   *   { emit: 'event', level: 'warn' }
   *   { emit: 'event', level: 'error' }
   * ]
   *
   * / Emit as events and log to stdout
   * og: [
   *  { emit: 'stdout', level: 'query' },
   *  { emit: 'stdout', level: 'info' },
   *  { emit: 'stdout', level: 'warn' }
   *  { emit: 'stdout', level: 'error' }
   *
   * ```
   * Read more in our [docs](https://pris.ly/d/logging).
   */
  log?: (LogLevel | LogDefinition)[];
  /**
   * The default values for transactionOptions
   * maxWait ?= 2000
   * timeout ?= 5000
   */
  transactionOptions?: {
    maxWait?: number;
    timeout?: number;
    isolationLevel?: TransactionIsolationLevel;
  };
  /**
   * Global configuration for omitting model fields by default.
   *
   * @example
   * ```
   * const prisma = new PrismaClient({
   *   omit: {
   *     user: {
   *       password: true
   *     }
   *   }
   * })
   * ```
   */
  omit?: GlobalOmitConfig;
  /**
   * SQL commenter plugins that add metadata to SQL queries as comments.
   * Comments follow the sqlcommenter format: https://google.github.io/sqlcommenter/
   *
   * @example
   * ```
   * const prisma = new PrismaClient({
   *   adapter,
   *   comments: [
   *     traceContext(),
   *     queryInsights(),
   *   ],
   * })
   * ```
   */
  comments?: runtime.SqlCommenterPlugin[];
};
export type GlobalOmitConfig = {
  twoFactor?: Prisma.TwoFactorOmit;
  user?: Prisma.UserOmit;
  session?: Prisma.SessionOmit;
  account?: Prisma.AccountOmit;
  verification?: Prisma.VerificationOmit;
  clinicMember?: Prisma.ClinicMemberOmit;
  role?: Prisma.RoleOmit;
  clinicInvitation?: Prisma.clinicInvitationOmit;
  notification?: Prisma.NotificationOmit;
  twoFactorAuth?: Prisma.TwoFactorAuthOmit;
  passkey?: Prisma.PasskeyOmit;
  systemSettings?: Prisma.SystemSettingsOmit;
  aPIKey?: Prisma.APIKeyOmit;
  settings?: Prisma.SettingsOmit;
  auditLog?: Prisma.AuditLogOmit;
  todo?: Prisma.TodoOmit;
  feature?: Prisma.FeatureOmit;
  file?: Prisma.FileOmit;
  folder?: Prisma.FolderOmit;
  clinic?: Prisma.ClinicOmit;
  doctor?: Prisma.DoctorOmit;
  workingDays?: Prisma.WorkingDaysOmit;
  staff?: Prisma.StaffOmit;
  payment?: Prisma.PaymentOmit;
  reminder?: Prisma.ReminderOmit;
  patientBill?: Prisma.PatientBillOmit;
  service?: Prisma.ServiceOmit;
  clinicSetting?: Prisma.ClinicSettingOmit;
  wHOGrowthStandard?: Prisma.WHOGrowthStandardOmit;
  rating?: Prisma.RatingOmit;
  prescription?: Prisma.PrescriptionOmit;
  drug?: Prisma.DrugOmit;
  doseGuideline?: Prisma.DoseGuidelineOmit;
  prescribedItem?: Prisma.PrescribedItemOmit;
  guardian?: Prisma.GuardianOmit;
  patient?: Prisma.PatientOmit;
  appointment?: Prisma.AppointmentOmit;
  medicalRecords?: Prisma.MedicalRecordsOmit;
  medicalRecordAccess?: Prisma.MedicalRecordAccessOmit;
  diagnosis?: Prisma.DiagnosisOmit;
  vitalSigns?: Prisma.VitalSignsOmit;
  growthRecord?: Prisma.GrowthRecordOmit;
  immunization?: Prisma.ImmunizationOmit;
  configStore?: Prisma.ConfigStoreOmit;
  userQuota?: Prisma.UserQuotaOmit;
  labTest?: Prisma.LabTestOmit;
  feedingLog?: Prisma.FeedingLogOmit;
  developmentalMilestone?: Prisma.DevelopmentalMilestoneOmit;
  developmentalCheck?: Prisma.DevelopmentalCheckOmit;
  vaccineSchedule?: Prisma.VaccineScheduleOmit;
  expense?: Prisma.ExpenseOmit;
  expenseCategory?: Prisma.ExpenseCategoryOmit;
  expenseSubCategory?: Prisma.ExpenseSubCategoryOmit;
  fileStorage?: Prisma.FileStorageOmit;
  trainingFile?: Prisma.TrainingFileOmit;
  knowledgeBase?: Prisma.KnowledgeBaseOmit;
  trainingWebsite?: Prisma.TrainingWebsiteOmit;
  agent?: Prisma.AgentOmit;
  clinicDashboardMV?: Prisma.ClinicDashboardMVOmit;
  patientOverviewMV?: Prisma.PatientOverviewMVOmit;
  doctorPerformanceMV?: Prisma.DoctorPerformanceMVOmit;
  financialOverviewMV?: Prisma.FinancialOverviewMVOmit;
  appointmentScheduleMV?: Prisma.AppointmentScheduleMVOmit;
  patientGrowthChartMV?: Prisma.PatientGrowthChartMVOmit;
  immunizationScheduleMV?: Prisma.ImmunizationScheduleMVOmit;
  medicalRecordsMV?: Prisma.MedicalRecordsMVOmit;
  notificationsMV?: Prisma.NotificationsMVOmit;
  expenseAnalysisMV?: Prisma.ExpenseAnalysisMVOmit;
};

/* Types for Logging */
export type LogLevel = "info" | "query" | "warn" | "error";
export type LogDefinition = {
  level: LogLevel;
  emit: "stdout" | "event";
};

export type CheckIsLogLevel<T> = T extends LogLevel ? T : never;

export type GetLogType<T> = CheckIsLogLevel<
  T extends LogDefinition ? T["level"] : T
>;

export type GetEvents<T extends any[]> =
  T extends Array<LogLevel | LogDefinition> ? GetLogType<T[number]> : never;

export type QueryEvent = {
  timestamp: Date;
  query: string;
  params: string;
  duration: number;
  target: string;
};

export type LogEvent = {
  timestamp: Date;
  message: string;
  target: string;
};
/* End Types for Logging */

export type PrismaAction =
  | "findUnique"
  | "findUniqueOrThrow"
  | "findMany"
  | "findFirst"
  | "findFirstOrThrow"
  | "create"
  | "createMany"
  | "createManyAndReturn"
  | "update"
  | "updateMany"
  | "updateManyAndReturn"
  | "upsert"
  | "delete"
  | "deleteMany"
  | "executeRaw"
  | "queryRaw"
  | "aggregate"
  | "count"
  | "runCommandRaw"
  | "findRaw"
  | "groupBy";

/**
 * `PrismaClient` proxy available in interactive transactions.
 */
export type TransactionClient = Omit<
  DefaultPrismaClient,
  runtime.ITXClientDenyList
>;
